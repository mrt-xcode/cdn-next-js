{"version":3,"file":"static/chunks/2b7b2d2a-a3163fc7734f894b.js","mappings":"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","sources":["webpack://_N_E/./node_modules/pdfjs-dist/build/pdf.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2022 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pdfjs-dist/build/pdf\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pdfjs-dist/build/pdf\"] = factory();\n\telse\n\t\troot[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isAscii = isAscii;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF16BEString = stringToUTF16BEString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\n\n__w_pdfjs_require__(2);\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst LINE_FACTOR = 1.35;\nexports.LINE_FACTOR = LINE_FACTOR;\nconst LINE_DESCENT_FACTOR = 0.35;\nexports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nexports.AnnotationEditorPrefix = AnnotationEditorPrefix;\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  INK: 15\n};\nexports.AnnotationEditorType = AnnotationEditorType;\nconst AnnotationEditorParamsType = {\n  FREETEXT_SIZE: 1,\n  FREETEXT_COLOR: 2,\n  FREETEXT_OPACITY: 3,\n  INK_COLOR: 11,\n  INK_THICKNESS: 12,\n  INK_OPACITY: 13\n};\nexports.AnnotationEditorParamsType = AnnotationEditorParamsType;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nconst AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nconst AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nconst FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1STANDARD: \"TYPE1STANDARD\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  signatures: \"signatures\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontBuildPath: \"errorFontBuildPath\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\",\n  errorContentSubStream: \"errorContentSubStream\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n\n        if (dots && dots.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch (ex) {}\n      }\n    }\n\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n\n}\n\nexports.PasswordException = PasswordException;\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n\n}\n\nexports.UnknownErrorException = UnknownErrorException;\n\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n\n}\n\nexports.InvalidPDFException = InvalidPDFException;\n\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n\n}\n\nexports.MissingPDFException = MissingPDFException;\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n\n}\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n\n}\n\nexports.FormatError = FormatError;\n\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n\n}\n\nexports.AbortException = AbortException;\n\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes === null || bytes.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  const strBuf = [];\n\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  if (arr.byteLength !== undefined) {\n    return arr.byteLength;\n  }\n\n  unreachable(\"Invalid argument for arrayByteLength\");\n}\n\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  let resultLength = 0;\n\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n\n}\n\nexports.FeatureTest = FeatureTest;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n\n  static scaleMinMax(transform, minMax) {\n    let temp;\n\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n\n      minMax[0] *= transform[0];\n      minMax[1] *= transform[0];\n\n      if (transform[3] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n\n      minMax[2] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[2];\n      minMax[2] = temp;\n      temp = minMax[1];\n      minMax[1] = minMax[3];\n      minMax[3] = temp;\n\n      if (transform[1] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n\n      minMax[2] *= transform[1];\n      minMax[3] *= transform[1];\n\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n\n      minMax[0] *= transform[2];\n      minMax[1] *= transform[2];\n    }\n\n    minMax[0] += transform[4];\n    minMax[1] += transform[4];\n    minMax[2] += transform[5];\n    minMax[3] += transform[5];\n  }\n\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n\n  static apply3dTransform(m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n  }\n\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  }\n\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n\n    if (xLow > xHigh) {\n      return null;\n    }\n\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n\n    if (yLow > yHigh) {\n      return null;\n    }\n\n    return [xLow, yLow, xHigh, yHigh];\n  }\n\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n          bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n\n      if (b2ac < 0) {\n        continue;\n      }\n\n      t1 = (-b + sqrtb2ac) / (2 * a);\n\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n\n      t2 = (-b - sqrtb2ac) / (2 * a);\n\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n\n    let j = tvalues.length,\n        mt;\n    const jlen = j;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n\n}\n\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        return decoder.decode(buffer);\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n\n  const strBuf = [];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const code = PDFStringTranslateTable[str.charCodeAt(i)];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n\n    return `\\\\${match}`;\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  const buf = [\"\\xFE\\xFF\"];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n  }\n\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get() {\n      return isSettled;\n    }\n\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\n\nvar _is_node = __w_pdfjs_require__(3);\n\n;\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isNodeJS = void 0;\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.version = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _annotation_storage = __w_pdfjs_require__(5);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _font_loader = __w_pdfjs_require__(11);\n\nvar _canvas = __w_pdfjs_require__(12);\n\nvar _worker_options = __w_pdfjs_require__(15);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _message_handler = __w_pdfjs_require__(16);\n\nvar _metadata = __w_pdfjs_require__(17);\n\nvar _optional_content_config = __w_pdfjs_require__(18);\n\nvar _transport_stream = __w_pdfjs_require__(19);\n\nvar _xfa_text = __w_pdfjs_require__(20);\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nlet DefaultCanvasFactory = _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nlet DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nlet DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n\nif (_is_node.isNodeJS) {\n  const {\n    NodeCanvasFactory,\n    NodeCMapReaderFactory,\n    NodeStandardFontDataFactory\n  } = __w_pdfjs_require__(21);\n\n  exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;\n  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;\n  exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;\n}\n\nlet createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n  let source;\n\n  if (typeof src === \"string\" || src instanceof URL) {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (typeof src !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, TypedArray, or parameter object.\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  const params = Object.create(null);\n  let rangeTransport = null,\n      worker = null;\n\n  for (const key in source) {\n    const value = source[key];\n\n    switch (key) {\n      case \"url\":\n        if (typeof window !== \"undefined\") {\n          try {\n            params[key] = new URL(value, window.location).href;\n            continue;\n          } catch (ex) {\n            (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`);\n          }\n        } else if (typeof value === \"string\" || value instanceof URL) {\n          params[key] = value.toString();\n          continue;\n        }\n\n        throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n\n      case \"range\":\n        rangeTransport = value;\n        continue;\n\n      case \"worker\":\n        worker = value;\n        continue;\n\n      case \"data\":\n        if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) {\n          params[key] = new Uint8Array(value);\n        } else if (value instanceof Uint8Array) {\n          break;\n        } else if (typeof value === \"string\") {\n          params[key] = (0, _util.stringToBytes)(value);\n        } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) {\n          params[key] = new Uint8Array(value);\n        } else if ((0, _util.isArrayBuffer)(value)) {\n          params[key] = new Uint8Array(value);\n        } else {\n          throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n        }\n\n        continue;\n    }\n\n    params[key] = value;\n  }\n\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n  params.enableXfa = params.enableXfa === true;\n\n  if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {\n    params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;\n  }\n\n  if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {\n    params.docBaseUrl = null;\n  }\n\n  if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.cMapUrl !== \"string\") {\n    params.cMapUrl = null;\n  }\n\n  if (typeof params.standardFontDataUrl !== \"string\") {\n    params.standardFontDataUrl = null;\n  }\n\n  if (typeof params.useWorkerFetch !== \"boolean\") {\n    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _is_node.isNodeJS;\n  }\n\n  if (typeof params.useSystemFonts !== \"boolean\") {\n    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;\n  }\n\n  if (typeof params.ownerDocument !== \"object\" || params.ownerDocument === null) {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  const docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          contentDispositionFilename: params.contentDispositionFilename,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\n\nasync function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;\n  }\n\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId,\n    apiVersion: '2.16.105',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties,\n    enableXfa: source.enableXfa,\n    useSystemFonts: source.useSystemFonts,\n    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null\n  });\n\n  if (source.data) {\n    source.data = null;\n  }\n\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  return workerId;\n}\n\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n\n  constructor() {\n    this._capability = (0, _util.createPromiseCapability)();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n    this.onUnsupportedFeature = null;\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  async destroy() {\n    this.destroyed = true;\n    await this._transport?.destroy();\n    this._transport = null;\n\n    if (this._worker) {\n      this._worker.destroy();\n\n      this._worker = null;\n    }\n  }\n\n}\n\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n\n  abort() {}\n\n}\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"fingerprint\", {\n      get() {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.fingerprint`, \" + \"please use `PDFDocumentProxy.fingerprints` instead.\");\n        return this.fingerprints[0];\n      }\n\n    });\n    Object.defineProperty(this, \"getStats\", {\n      value: async () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getStats`, \" + \"please use the `PDFDocumentProxy.stats`-getter instead.\");\n        return this.stats || {\n          streamTypes: {},\n          fontTypes: {}\n        };\n      }\n    });\n  }\n\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n\n  get stats() {\n    return this._transport.stats;\n  }\n\n  get isPureXfa() {\n    return !!this._transport._htmlForXfa;\n  }\n\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n\n  getData() {\n    return this._transport.getData();\n  }\n\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  saveDocument() {\n    if (this._transport.annotationStorage.size <= 0) {\n      (0, _display_utils.deprecated)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n\n    return this._transport.saveDocument();\n  }\n\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n\n}\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._bitmaps = new Set();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this._annotationPromises = new Map();\n    this.destroyed = false;\n  }\n\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n\n    let promise = this._annotationPromises.get(intentArgs.cacheKey);\n\n    if (!promise) {\n      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n\n      this._annotationPromises.set(intentArgs.cacheKey, promise);\n\n      promise = promise.then(annotations => {\n        for (const annotation of annotations) {\n          if (annotation.titleObj !== undefined) {\n            Object.defineProperty(annotation, \"title\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`title`-property on annotation, please use `titleObj` instead.\");\n                return annotation.titleObj.str;\n              }\n\n            });\n          }\n\n          if (annotation.contentsObj !== undefined) {\n            Object.defineProperty(annotation, \"contents\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`contents`-property on annotation, please use `contentsObj` instead.\");\n                return annotation.contentsObj.str;\n              }\n\n            });\n          }\n        }\n\n        return annotations;\n      });\n    }\n\n    return promise;\n  }\n\n  getJSActions() {\n    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);\n  }\n\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null\n  }) {\n    if (arguments[0]?.renderInteractiveForms !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `renderInteractiveForms`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_FORMS;\n      }\n    }\n\n    if (arguments[0]?.includeAnnotationStorage !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `includeAnnotationStorage`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;\n      }\n    }\n\n    if (this._stats) {\n      this._stats.time(\"Overall\");\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n      ownerDocument: this._ownerDocument\n    });\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n\n      if (this.cleanupAfterRender || intentPrint) {\n        this.pendingCleanup = true;\n      }\n\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n\n        this._stats.timeEnd(\"Overall\");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.pendingCleanup) {\n        complete();\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.time(\"Rendering\");\n      }\n\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    printAnnotationStorage = null\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    return intentState.opListReadCapability.promise;\n  }\n\n  streamTextContent({\n    disableCombineTextItems = false,\n    includeMarkedContent = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      combineTextItems: disableCombineTextItems !== true,\n      includeMarkedContent: includeMarkedContent === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n      size(textContent) {\n        return textContent.items.length;\n      }\n\n    });\n  }\n\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n\n  getStructTree() {\n    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);\n  }\n\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n\n    this.objs.clear();\n\n    for (const bitmap of this._bitmaps) {\n      bitmap.close();\n    }\n\n    this._bitmaps.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n\n    if (resetStats && this._stats) {\n      this._stats = new _display_utils.StatTimer();\n    }\n\n    for (const bitmap of this._bitmaps) {\n      bitmap.close();\n    }\n\n    this._bitmaps.clear();\n\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n\n    if (!intentState) {\n      return;\n    }\n\n    if (this._stats) {\n      this._stats.timeEnd(\"Page Request\");\n    }\n\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageMap\n  }) {\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: annotationStorageMap\n    });\n\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(cacheKey);\n\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        this._renderPageChunk(value, intentState);\n\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n\n          this._tryCleanup();\n        }\n\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n\n    pump();\n  }\n\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return;\n    }\n\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n\n        break;\n      }\n    }\n\n    this.cleanup();\n  }\n\n  get stats() {\n    return this._stats;\n  }\n\n}\n\nexports.PDFPageProxy = PDFPageProxy;\n\nclass LoopbackPort {\n  constructor() {\n    this._listeners = [];\n    this._deferred = Promise.resolve();\n  }\n\n  postMessage(obj, transfers) {\n    const event = {\n      data: structuredClone(obj, transfers)\n    };\n\n    this._deferred.then(() => {\n      for (const listener of this._listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n\n}\n\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\nexports.PDFWorkerUtil = PDFWorkerUtil;\n{\n  if (_is_node.isNodeJS && typeof require === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {\n    let base;\n\n    try {\n      base = new URL(baseUrl);\n\n      if (!base.origin || base.origin === \"null\") {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n\n    const other = new URL(otherUrl, base);\n    return base.origin === other.origin;\n  };\n\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\n\nclass PDFWorker {\n  static #workerPorts = new WeakMap();\n\n  constructor({\n    name = null,\n    port = null,\n    verbosity = (0, _util.getVerbosityLevel)()\n  } = {}) {\n    if (port && PDFWorker.#workerPorts.has(port)) {\n      throw new Error(\"Cannot use more than one PDFWorker per port.\");\n    }\n\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = (0, _util.createPromiseCapability)();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n\n    if (port) {\n      PDFWorker.#workerPorts.set(port, this);\n\n      this._initializeFromPort(port);\n\n      return;\n    }\n\n    this._initialize();\n  }\n\n  get promise() {\n    return this._readyCapability.promise;\n  }\n\n  get port() {\n    return this._port;\n  }\n\n  get messageHandler() {\n    return this._messageHandler;\n  }\n\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n    this._messageHandler.on(\"ready\", function () {});\n\n    this._readyCapability.resolve();\n  }\n\n  _initialize() {\n    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let {\n        workerSrc\n      } = PDFWorker;\n\n      try {\n        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n\n            this._readyCapability.resolve();\n\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          try {\n            sendTest();\n          } catch (e) {\n            this._setupFakeWorker();\n          }\n        });\n\n        const sendTest = () => {\n          const testObj = new Uint8Array();\n          messageHandler.send(\"test\", testObj, [testObj.buffer]);\n        };\n\n        sendTest();\n        return;\n      } catch (e) {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n\n    this._setupFakeWorker();\n  }\n\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n        return;\n      }\n\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n\n      this._readyCapability.resolve();\n\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n\n  destroy() {\n    this.destroyed = true;\n\n    if (this._webWorker) {\n      this._webWorker.terminate();\n\n      this._webWorker = null;\n    }\n\n    PDFWorker.#workerPorts.delete(this._port);\n    this._port = null;\n\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n\n      this._messageHandler = null;\n    }\n  }\n\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n\n    if (this.#workerPorts.has(params.port)) {\n      return this.#workerPorts.get(params.port);\n    }\n\n    return new PDFWorker(params);\n  }\n\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch (ex) {\n      return null;\n    }\n  }\n\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n\n      if (_is_node.isNodeJS && typeof require === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n\n}\n\nexports.PDFWorker = PDFWorker;\n{\n  PDFWorker.getWorkerSrc = function () {\n    (0, _display_utils.deprecated)(\"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\");\n    return this.workerSrc;\n  };\n}\n\nclass WorkerTransport {\n  #docStats = null;\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #metadataPromise = null;\n\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n\n    if (!params.useWorkerFetch) {\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked\n      });\n      this.StandardFontDataFactory = new params.StandardFontDataFactory({\n        baseUrl: params.standardFontDataUrl\n      });\n    }\n\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n\n  get stats() {\n    return this.#docStats;\n  }\n\n  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let annotationMap = null;\n\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n\n      case \"display\":\n        break;\n\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n\n      case _util.AnnotationMode.ENABLE:\n        break;\n\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        annotationMap = annotationStorage.serializable;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,\n      annotationStorageMap: annotationMap\n    };\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = (0, _util.createPromiseCapability)();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    }\n\n    const waitOn = [];\n\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#metadataPromise = null;\n      this._getFieldObjectsPromise = null;\n      this._hasJSActionsPromise = null;\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = (0, _util.createPromiseCapability)();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this._passwordCapability = (0, _util.createPromiseCapability)();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this._passwordCapability.reject(password);\n          } else {\n            this._passwordCapability.resolve({\n              password\n            });\n          }\n        };\n\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n\n      return this._passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const page = this.#pageCache.get(data.pageIndex);\n\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              }\n\n            };\n          }\n\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const pageProxy = this.#pageCache.get(pageIndex);\n\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n          if (imageData) {\n            let length;\n\n            if (imageData.bitmap) {\n              const {\n                bitmap,\n                width,\n                height\n              } = imageData;\n              length = width * height * 4;\n\n              pageProxy._bitmaps.add(bitmap);\n            } else {\n              length = imageData.data?.length || 0;\n            }\n\n            if (length > MAX_IMAGE_SIZE_TO_STORE) {\n              pageProxy.cleanupAfterRender = true;\n            }\n          }\n\n          break;\n\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"DocStats\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      this.#docStats = Object.freeze({\n        streamTypes: Object.freeze(data.streamTypes),\n        fontTypes: Object.freeze(data.fontTypes)\n      });\n    });\n    messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.CMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.CMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.StandardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.StandardFontDataFactory.fetch(data);\n    });\n  }\n\n  _onUnsupportedFeature({\n    featureId\n  }) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.loadingTask.onUnsupportedFeature?.(featureId);\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n\n    const pageIndex = pageNumber - 1,\n          cachedPromise = this.#pagePromises.get(pageIndex);\n\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n\n  saveDocument() {\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: this.annotationStorage.serializable,\n      filename: this._fullReader?.filename ?? null\n    }).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n\n  getFieldObjects() {\n    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n  }\n\n  hasJSActions() {\n    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null);\n  }\n\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n  }\n\n  getDocJSActions() {\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n  }\n\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n\n  getMetadata() {\n    return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n  }\n\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n\n  async startCleanup(keepLoadedFonts = false) {\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n\n    if (this.destroyed) {\n      return;\n    }\n\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n\n    this.commonObjs.clear();\n\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n\n    this.#metadataPromise = null;\n    this._getFieldObjectsPromise = null;\n    this._hasJSActionsPromise = null;\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch: params.disableAutoFetch,\n      enableXfa: params.enableXfa\n    });\n  }\n\n}\n\nclass PDFObjects {\n  #objs = Object.create(null);\n\n  #ensureObj(objId) {\n    const obj = this.#objs[objId];\n\n    if (obj) {\n      return obj;\n    }\n\n    return this.#objs[objId] = {\n      capability: (0, _util.createPromiseCapability)(),\n      data: null\n    };\n  }\n\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.capability.promise.then(() => callback(obj.data));\n      return null;\n    }\n\n    const obj = this.#objs[objId];\n\n    if (!obj?.capability.settled) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this.#objs[objId];\n    return obj?.capability.settled || false;\n  }\n\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.capability.resolve();\n  }\n\n  clear() {\n    this.#objs = Object.create(null);\n  }\n\n}\n\nclass RenderTask {\n  #internalRenderTask = null;\n\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n\n  cancel() {\n    this.#internalRenderTask.cancel();\n  }\n\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n\n    if (!separateAnnots) {\n      return false;\n    }\n\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n\n}\n\nexports.RenderTask = RenderTask;\n\nclass InternalRenderTask {\n  static #canvasInUse = new WeakSet();\n\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = (0, _util.createPromiseCapability)();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      imageLayer,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n\n    if (this.graphicsReadyCallback) {\n      this.graphicsReadyCallback();\n    }\n  }\n\n  cancel(error = null) {\n    this.running = false;\n    this.cancelled = true;\n\n    if (this.gfx) {\n      this.gfx.endDrawing();\n    }\n\n    if (this._canvas) {\n      InternalRenderTask.#canvasInUse.delete(this._canvas);\n    }\n\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n  }\n\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      if (!this.graphicsReadyCallback) {\n        this.graphicsReadyCallback = this._continueBound;\n      }\n\n      return;\n    }\n\n    if (this.stepper) {\n      this.stepper.updateOperatorList(this.operatorList);\n    }\n\n    if (this.running) {\n      return;\n    }\n\n    this._continue();\n  }\n\n  _continue() {\n    this.running = true;\n\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n\n        if (this._canvas) {\n          InternalRenderTask.#canvasInUse.delete(this._canvas);\n        }\n\n        this.callback();\n      }\n    }\n  }\n\n}\n\nconst version = '2.16.105';\nexports.version = version;\nconst build = '172ccdbe5';\nexports.build = build;\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _editor = __w_pdfjs_require__(6);\n\nvar _murmurhash = __w_pdfjs_require__(10);\n\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n\n  getValue(key, defaultValue) {\n    const value = this._storage.get(key);\n\n    if (value === undefined) {\n      return defaultValue;\n    }\n\n    return Object.assign(defaultValue, value);\n  }\n\n  getRawValue(key) {\n    return this._storage.get(key);\n  }\n\n  remove(key) {\n    this._storage.delete(key);\n\n    if (this._storage.size === 0) {\n      this.resetModified();\n    }\n\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this._storage.values()) {\n        if (value instanceof _editor.AnnotationEditor) {\n          return;\n        }\n      }\n\n      this.onAnnotationEditor(null);\n    }\n  }\n\n  setValue(key, value) {\n    const obj = this._storage.get(key);\n\n    let modified = false;\n\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n\n      this._storage.set(key, value);\n    }\n\n    if (modified) {\n      this.#setModified();\n    }\n\n    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n\n  has(key) {\n    return this._storage.has(key);\n  }\n\n  getAll() {\n    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  #setModified() {\n    if (!this._modified) {\n      this._modified = true;\n\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n\n  get serializable() {\n    if (this._storage.size === 0) {\n      return null;\n    }\n\n    const clone = new Map();\n\n    for (const [key, val] of this._storage) {\n      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;\n\n      if (serialized) {\n        clone.set(key, serialized);\n      }\n    }\n\n    return clone;\n  }\n\n  static getHash(map) {\n    if (!map) {\n      return \"\";\n    }\n\n    const hash = new _murmurhash.MurmurHash3_64();\n\n    for (const [key, val] of map) {\n      hash.update(`${key}:${JSON.stringify(val)}`);\n    }\n\n    return hash.hexdigest();\n  }\n\n}\n\nexports.AnnotationStorage = AnnotationStorage;\n\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable = null;\n\n  constructor(parent) {\n    super();\n    this.#serializable = structuredClone(parent.serializable);\n  }\n\n  get print() {\n    (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n  }\n\n  get serializable() {\n    return this.#serializable;\n  }\n\n}\n\nexports.PrintAnnotationStorage = PrintAnnotationStorage;\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditor = void 0;\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _util = __w_pdfjs_require__(1);\n\nclass AnnotationEditor {\n  #boundFocusin = this.focusin.bind(this);\n  #boundFocusout = this.focusout.bind(this);\n  #hasBeenSelected = false;\n  #isEditing = false;\n  #isInEditMode = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _colorManager = new _tools.ColorManager();\n  static _zIndex = 1;\n\n  constructor(parameters) {\n    if (this.constructor === AnnotationEditor) {\n      (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n    }\n\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    const [width, height] = this.parent.viewportBaseDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.rotation = this.parent.viewport.rotation;\n    this.isAttachedToDOM = false;\n  }\n\n  static get _defaultLineColor() {\n    return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n\n  focusin(event) {\n    if (!this.#hasBeenSelected) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenSelected = false;\n    }\n  }\n\n  focusout(event) {\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n\n    const target = event.relatedTarget;\n\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (!this.parent.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n\n  commit() {\n    this.parent.addToAnnotationStorage(this);\n  }\n\n  dragstart(event) {\n    const rect = this.parent.div.getBoundingClientRect();\n    this.startX = event.clientX - rect.x;\n    this.startY = event.clientY - rect.y;\n    event.dataTransfer.setData(\"text/plain\", this.id);\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parent.viewportBaseDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.div.style.left = `${100 * this.x}%`;\n    this.div.style.top = `${100 * this.y}%`;\n  }\n\n  translate(x, y) {\n    const [width, height] = this.parent.viewportBaseDimensions;\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this.div.style.left = `${100 * this.x}%`;\n    this.div.style.top = `${100 * this.y}%`;\n  }\n\n  screenToPageTranslation(x, y) {\n    const {\n      rotation\n    } = this.parent.viewport;\n\n    switch (rotation) {\n      case 90:\n        return [y, -x];\n\n      case 180:\n        return [-x, -y];\n\n      case 270:\n        return [-y, x];\n\n      default:\n        return [x, y];\n    }\n  }\n\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.div.style.width = `${100 * width / parentWidth}%`;\n    this.div.style.height = `${100 * height / parentHeight}%`;\n  }\n\n  getInitialTranslation() {\n    return [0, 0];\n  }\n\n  render() {\n    this.div = document.createElement(\"div\");\n    this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    this.div.className = this.name;\n    this.div.setAttribute(\"id\", this.id);\n    this.div.setAttribute(\"tabIndex\", 0);\n    this.setInForeground();\n    this.div.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div.addEventListener(\"focusout\", this.#boundFocusout);\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    (0, _tools.bindEvents)(this, this.div, [\"dragstart\", \"pointerdown\"]);\n    return this.div;\n  }\n\n  pointerdown(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n\n    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n      this.parent.toggleSelected(this);\n    } else {\n      this.parent.setSelected(this);\n    }\n\n    this.#hasBeenSelected = true;\n  }\n\n  getRect(tx, ty) {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    const [pageWidth, pageHeight] = this.parent.pageDimensions;\n    const shiftX = pageWidth * tx / parentWidth;\n    const shiftY = pageHeight * ty / parentHeight;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n\n    switch (this.rotation) {\n      case 0:\n        return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];\n\n      case 90:\n        return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];\n\n      case 180:\n        return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];\n\n      case 270:\n        return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];\n\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n\n  onceAdded() {}\n\n  isEmpty() {\n    return false;\n  }\n\n  enableEditMode() {\n    this.#isInEditMode = true;\n  }\n\n  disableEditMode() {\n    this.#isInEditMode = false;\n  }\n\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n\n  shouldGetKeyboardEvents() {\n    return false;\n  }\n\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n\n  rebuild() {\n    this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n  }\n\n  serialize() {\n    (0, _util.unreachable)(\"An editor must be serializable\");\n  }\n\n  static deserialize(data, parent) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId()\n    });\n    editor.rotation = data.rotation;\n    const [pageWidth, pageHeight] = parent.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n\n  remove() {\n    this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n    this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n\n    this.parent.remove(this);\n  }\n\n  select() {\n    this.div?.classList.add(\"selectedEditor\");\n  }\n\n  unselect() {\n    this.div?.classList.remove(\"selectedEditor\");\n  }\n\n  updateParams(type, value) {}\n\n  disableEditing() {}\n\n  enableEditing() {}\n\n  get propertiesToUpdate() {\n    return {};\n  }\n\n  get contentDiv() {\n    return this.div;\n  }\n\n  get isEditing() {\n    return this.#isEditing;\n  }\n\n  set isEditing(value) {\n    this.#isEditing = value;\n\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n\n}\n\nexports.AnnotationEditor = AnnotationEditor;\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;\nexports.bindEvents = bindEvents;\nexports.opacityToHex = opacityToHex;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\n\nfunction opacityToHex(opacity) {\n  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\n\nclass IdManager {\n  #id = 0;\n\n  getId() {\n    return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n  }\n\n}\n\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n\n  add({\n    cmd,\n    undo,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n\n    if (this.#locked) {\n      return;\n    }\n\n    const save = {\n      cmd,\n      undo,\n      type\n    };\n\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n\n      this.#commands[this.#position] = save;\n      return;\n    }\n\n    const next = this.#position + 1;\n\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n\n    this.#commands.push(save);\n  }\n\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n\n    this.#locked = true;\n    this.#commands[this.#position].undo();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      this.#commands[this.#position].cmd();\n      this.#locked = false;\n    }\n  }\n\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n\n  destroy() {\n    this.#commands = null;\n  }\n\n}\n\nexports.CommandManager = CommandManager;\n\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const isMac = KeyboardManager.platform.isMac;\n\n    for (const [keys, callback] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), callback);\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, callback);\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n\n    const callback = this.callbacks.get(this.#serialize(event));\n\n    if (!callback) {\n      return;\n    }\n\n    callback.bind(self)();\n    event.stopPropagation();\n    event.preventDefault();\n  }\n\n}\n\nexports.KeyboardManager = KeyboardManager;\n\nclass ClipboardManager {\n  #elements = null;\n\n  copy(element) {\n    if (!element) {\n      return;\n    }\n\n    if (Array.isArray(element)) {\n      this.#elements = element.map(el => el.serialize());\n    } else {\n      this.#elements = [element.serialize()];\n    }\n\n    this.#elements = this.#elements.filter(el => !!el);\n\n    if (this.#elements.length === 0) {\n      this.#elements = null;\n    }\n  }\n\n  paste() {\n    return this.#elements;\n  }\n\n  isEmpty() {\n    return this.#elements === null;\n  }\n\n  destroy() {\n    this.#elements = null;\n  }\n\n}\n\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    (0, _display_utils.getColorValues)(colors);\n    return (0, _util.shadow)(this, \"_colors\", colors);\n  }\n\n  convert(color) {\n    const rgb = (0, _display_utils.getRGB)(color);\n\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n\n    return rgb;\n  }\n\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n\n    if (!rgb) {\n      return name;\n    }\n\n    return _util.Util.makeHexColor(...rgb);\n  }\n\n}\n\nexports.ColorManager = ColorManager;\n\nclass AnnotationEditorUIManager {\n  #activeEditor = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #clipboardManager = new ClipboardManager();\n  #commandManager = new CommandManager();\n  #currentPageIndex = 0;\n  #editorTypes = null;\n  #eventBus = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #mode = _util.AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #boundKeydown = this.keydown.bind(this);\n  #boundOnEditingAction = this.onEditingAction.bind(this);\n  #boundOnPageChanging = this.onPageChanging.bind(this);\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasEmptyClipboard: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false\n  };\n  #container = null;\n  static _keyboardManager = new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], AnnotationEditorUIManager.prototype.selectAll], [[\"ctrl+c\", \"mac+meta+c\"], AnnotationEditorUIManager.prototype.copy], [[\"ctrl+v\", \"mac+meta+v\"], AnnotationEditorUIManager.prototype.paste], [[\"ctrl+x\", \"mac+meta+x\"], AnnotationEditorUIManager.prototype.cut], [[\"ctrl+z\", \"mac+meta+z\"], AnnotationEditorUIManager.prototype.undo], [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], AnnotationEditorUIManager.prototype.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\"], AnnotationEditorUIManager.prototype.delete], [[\"Escape\", \"mac+Escape\"], AnnotationEditorUIManager.prototype.unselectAll]]);\n\n  constructor(container, eventBus) {\n    this.#container = container;\n    this.#eventBus = eventBus;\n\n    this.#eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n\n    this.#eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n  }\n\n  destroy() {\n    this.#removeKeyboardManager();\n\n    this.#eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n\n    this.#eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#clipboardManager.destroy();\n    this.#commandManager.destroy();\n  }\n\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n\n  focusMainContainer() {\n    this.#container.focus();\n  }\n\n  #addKeyboardManager() {\n    this.#container.addEventListener(\"keydown\", this.#boundKeydown);\n  }\n\n  #removeKeyboardManager() {\n    this.#container.removeEventListener(\"keydown\", this.#boundKeydown);\n  }\n\n  keydown(event) {\n    if (!this.getActive()?.shouldGetKeyboardEvents()) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n\n  onEditingAction(details) {\n    if ([\"undo\", \"redo\", \"cut\", \"copy\", \"paste\", \"delete\", \"selectAll\"].includes(details.name)) {\n      this[details.name]();\n    }\n  }\n\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n\n    if (hasChanged) {\n      this.#eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n    }\n  }\n\n  #dispatchUpdateUI(details) {\n    this.#eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addKeyboardManager();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false,\n        hasEmptyClipboard: this.#clipboardManager.isEmpty()\n      });\n    } else {\n      this.#removeKeyboardManager();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n    }\n  }\n\n  registerEditorTypes(types) {\n    this.#editorTypes = types;\n\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n\n  getId() {\n    return this.#idManager.getId();\n  }\n\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n\n  updateMode(mode) {\n    this.#mode = mode;\n\n    if (mode === _util.AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n    } else {\n      this.setEditingState(true);\n      this.#enableAll();\n\n      for (const layer of this.#allLayers.values()) {\n        layer.updateMode(mode);\n      }\n    }\n  }\n\n  updateToolbar(mode) {\n    if (mode === this.#mode) {\n      return;\n    }\n\n    this.#eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      mode\n    });\n  }\n\n  updateParams(type, value) {\n    for (const editor of this.#selectedEditors) {\n      editor.updateParams(type, value);\n    }\n\n    for (const editorType of this.#editorTypes) {\n      editorType.updateDefaultParams(type, value);\n    }\n  }\n\n  #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n\n      for (const layer of this.#allLayers.values()) {\n        layer.enable();\n      }\n    }\n  }\n\n  #disableAll() {\n    this.unselectAll();\n\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n    }\n  }\n\n  getEditors(pageIndex) {\n    const editors = [];\n\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n\n    return editors;\n  }\n\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n\n  removeEditor(editor) {\n    this.#allEditors.delete(editor.id);\n    this.unselect(editor);\n  }\n\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n    }\n  }\n\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n\n    this.#activeEditor = editor;\n\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  setSelected(editor) {\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n\n    return false;\n  }\n\n  delete() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n    }\n\n    if (!this.hasSelection) {\n      return;\n    }\n\n    const editors = [...this.#selectedEditors];\n\n    const cmd = () => {\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  copy() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n    }\n\n    if (this.hasSelection) {\n      const editors = [];\n\n      for (const editor of this.#selectedEditors) {\n        if (!editor.isEmpty()) {\n          editors.push(editor);\n        }\n      }\n\n      if (editors.length === 0) {\n        return;\n      }\n\n      this.#clipboardManager.copy(editors);\n      this.#dispatchUpdateStates({\n        hasEmptyClipboard: false\n      });\n    }\n  }\n\n  cut() {\n    this.copy();\n    this.delete();\n  }\n\n  paste() {\n    if (this.#clipboardManager.isEmpty()) {\n      return;\n    }\n\n    this.unselectAll();\n    const layer = this.#allLayers.get(this.#currentPageIndex);\n    const newEditors = this.#clipboardManager.paste().map(data => layer.deserialize(data));\n\n    const cmd = () => {\n      for (const editor of newEditors) {\n        this.#addEditorToLayer(editor);\n      }\n\n      this.#selectEditors(newEditors);\n    };\n\n    const undo = () => {\n      for (const editor of newEditors) {\n        editor.remove();\n      }\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  #selectEditors(editors) {\n    this.#selectedEditors.clear();\n\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n\n    this.#selectEditors(this.#allEditors.values());\n  }\n\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      return;\n    }\n\n    if (this.#selectEditors.size === 0) {\n      return;\n    }\n\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n\n  getActive() {\n    return this.#activeEditor;\n  }\n\n  getMode() {\n    return this.#mode;\n  }\n\n}\n\nexports.AnnotationEditorUIManager = AnnotationEditorUIManager;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0;\nexports.deprecated = deprecated;\nexports.getColorValues = getColorValues;\nexports.getCurrentTransform = getCurrentTransform;\nexports.getCurrentTransformInverse = getCurrentTransformInverse;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getRGB = getRGB;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\n\nvar _base_factory = __w_pdfjs_require__(9);\n\nvar _util = __w_pdfjs_require__(1);\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nexports.AnnotationPrefix = AnnotationPrefix;\n\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\n\nexports.PixelsPerInch = PixelsPerInch;\n\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n}\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nasync function fetchData(url, asTypedArray = false) {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n\n      if (request.status === 200 || request.status === 0) {\n        let data;\n\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n\n      reject(new Error(request.statusText));\n    };\n\n    request.send(null);\n  });\n}\n\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n\n}\n\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n\n}\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n\n    if (rotation < 0) {\n      rotation += 360;\n    }\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n\n}\n\nexports.PageViewport = PageViewport;\n\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, type) {\n    super(msg, \"RenderingCancelledException\");\n    this.type = type;\n  }\n\n}\n\nexports.RenderingCancelledException = RenderingCancelledException;\n\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\n\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf(\"#\");\n  const query = url.indexOf(\"?\");\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch (ex) {}\n    }\n  }\n\n  return suggestedFilename || defaultFilename;\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n\n    for (const time of this.times) {\n      const name = time.name;\n\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n\n    return outBuf.join(\"\");\n  }\n\n}\n\nexports.StatTimer = StatTimer;\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n\n      resolve(evt);\n    };\n\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n\n    (document.head || document.documentElement).append(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    }\n\n    const matches = pdfDateStringRegex.exec(input);\n\n    if (!matches) {\n      return null;\n    }\n\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n\n}\n\nexports.PDFDateString = PDFDateString;\n\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\n\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n\n  (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\n\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  document.body.append(span);\n\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n\n  span.remove();\n}\n\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\n\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    const canvas = this._createCanvas(width, height);\n\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n\n}\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = false\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n  }\n\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n\n    const svg = this._createSVG(\"svg:svg\");\n\n    svg.setAttribute(\"version\", \"1.1\");\n\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n\n    return this._createSVG(type);\n  }\n\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n\n}\n\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MurmurHash3_64 = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\n\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n\n  update(input) {\n    let data, length;\n\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if ((0, _util.isArrayBuffer)(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n    }\n\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n        k2 = 0;\n    let h1 = this.h1,\n        h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n          C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n          C2_LOW = C2 & MASK_LOW;\n\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n\n    k1 = 0;\n\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n\n    }\n\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n\n  hexdigest() {\n    let h1 = this.h1,\n        h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    const hex1 = (h1 >>> 0).toString(16),\n          hex2 = (h2 >>> 0).toString(16);\n    return hex1.padStart(8, \"0\") + hex2.padStart(8, \"0\");\n  }\n\n}\n\nexports.MurmurHash3_64 = MurmurHash3_64;\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement(\"style\");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(styleElement);\n    }\n\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    if (font.attached || font.missingFile) {\n      return;\n    }\n\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n          });\n\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n\n      return;\n    }\n\n    const rule = font.createFontFaceRule();\n\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n  }\n\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n\n  get isSyncFontLoadingSupported() {\n    (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n  }\n\n  get _loadTestFont() {\n    (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n  }\n\n}\n\nlet FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n\n      if (typeof navigator === \"undefined\") {\n        supported = true;\n      } else {\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n        if (m?.[1] >= 14) {\n          supported = true;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n        request.done = true;\n\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n      };\n\n      return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      function int32(data, offset) {\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      let i, ii;\n\n      const canvas = this._document.createElement(\"canvas\");\n\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n      let called = 0;\n\n      function isFontReady(name, callback) {\n        called++;\n\n        if (called > 30) {\n          (0, _util.warn)(\"Load test font never loaded.\");\n          callback();\n          return;\n        }\n\n        ctx.font = \"30px \" + name;\n        ctx.fillText(\".\", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976;\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858;\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n      }\n\n      if (i < loadTestFontId.length) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n      }\n\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n      this.insertRule(rule);\n      const names = [];\n\n      for (const font of fonts) {\n        names.push(font.loadedName);\n      }\n\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement(\"div\");\n\n      div.style.visibility = \"hidden\";\n      div.style.width = div.style.height = \"10px\";\n      div.style.position = \"absolute\";\n      div.style.top = div.style.left = \"0px\";\n\n      for (const name of names) {\n        const span = this._document.createElement(\"span\");\n\n        span.textContent = \"Hi\";\n        span.style.fontFamily = name;\n        div.append(span);\n      }\n\n      this._document.body.append(div);\n\n      isFontReady(loadTestFontId, () => {\n        div.remove();\n        request.complete();\n      });\n    }\n\n  };\n}\n\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    onUnsupportedFeature,\n    fontRegistry = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    let nativeFontFace;\n\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds;\n\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n\n      this._onUnsupportedFeature({\n        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n      });\n\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n\n    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n      const jsBuf = [];\n\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n\n}\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _pattern_helper = __w_pdfjs_require__(13);\n\nvar _image_utils = __w_pdfjs_require__(14);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = _is_node.isNodeJS && typeof Path2D === \"undefined\" ? -1 : 1000;\nconst FULL_CHUNK_HEIGHT = 16;\n\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n\n  ctx.save = function ctxSave() {\n    destCtx.save();\n\n    this.__originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n\n    this.__originalRestore();\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n\n    this.__originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n\n    this.__originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n\n    this.__originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n\n    this.__originalRotate(angle);\n  };\n\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n\n    this.__originalClip(rule);\n  };\n\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n\n    this.__originalMoveTo(x, y);\n  };\n\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n\n    this.__originalLineTo(x, y);\n  };\n\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n\n    this.__originalRect(x, y, width, height);\n  };\n\n  ctx.closePath = function () {\n    destCtx.closePath();\n\n    this.__originalClosePath();\n  };\n\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n\n    this.__originalBeginPath();\n  };\n}\n\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  getCanvas(id, width, height) {\n    let canvasEntry;\n\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n\n    return canvasEntry;\n  }\n\n  delete(id) {\n    delete this.cache[id];\n  }\n\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n\n}\n\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\n\nfunction compileType3Glyph(imgData) {\n  const {\n    width,\n    height\n  } = imgData;\n\n  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n    return null;\n  }\n\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width1 = width + 1;\n  let points = new Uint8Array(width1 * (height + 1));\n  let i, j, j0;\n  const lineSize = width + 7 & ~7;\n  let data = new Uint8Array(lineSize * height),\n      pos = 0;\n\n  for (const elem of imgData.data) {\n    let mask = 128;\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  let count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const path = new Path2D();\n\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    path.moveTo(p % width1, i);\n    const p0 = p;\n    let type = points[p];\n\n    do {\n      const step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      const pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      path.lineTo(p % width1, p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    --i;\n  }\n\n  data = null;\n  points = null;\n\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.fill(path);\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = null;\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n\n  updateRectMinMax(transform, rect) {\n    const p1 = _util.Util.applyTransform(rect, transform);\n\n    const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n\n    this.minX = Math.min(this.minX, p1[0], p2[0]);\n    this.minY = Math.min(this.minY, p1[1], p2[1]);\n    this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n    this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n  }\n\n  updateScalingPathMinMax(transform, minMax) {\n    _util.Util.scaleMinMax(transform, minMax);\n\n    this.minX = Math.min(this.minX, minMax[0]);\n    this.maxX = Math.max(this.maxX, minMax[1]);\n    this.minY = Math.min(this.minY, minMax[2]);\n    this.maxY = Math.max(this.maxY, minMax[3]);\n  }\n\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], box[0], box[2]);\n      minMax[1] = Math.max(minMax[1], box[0], box[2]);\n      minMax[2] = Math.min(minMax[2], box[1], box[3]);\n      minMax[3] = Math.max(minMax[3], box[1], box[3]);\n      return;\n    }\n\n    this.updateRectMinMax(transform, box);\n  }\n\n  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n\n    return box;\n  }\n\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n\n  isEmptyClip() {\n    return this.minX === Infinity;\n  }\n\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n\n  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n\n}\n\nfunction putBinaryImageData(ctx, imgData, transferMaps = null) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n      destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n  if (transferMaps) {\n    switch (transferMaps.length) {\n      case 1:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[0];\n        transferMapBlue = transferMaps[0];\n        transferMapGray = transferMaps[0];\n        break;\n\n      case 4:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[1];\n        transferMapBlue = transferMaps[2];\n        transferMapGray = transferMaps[3];\n        break;\n    }\n  }\n\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    let white = 0xffffffff;\n    let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n\n    if (transferMapGray) {\n      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n        [white, black] = [black, white];\n      }\n    }\n\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n\n      destPos = 0;\n\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < destPos; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\n\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = (0, _image_utils.applyMaskImageData)({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\n\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n  for (let i = 0, ii = properties.length; i < ii; i++) {\n    const property = properties[i];\n\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\n\nfunction resetCtxToDefault(ctx, foregroundColor) {\n  ctx.strokeStyle = ctx.fillStyle = foregroundColor || \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n}\n\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\n\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\n\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\n\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  let composeFn;\n\n  if (subtype === \"Luminosity\") {\n    composeFn = composeSMaskLuminosity;\n  } else {\n    composeFn = composeSMaskAlpha;\n  }\n\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\n\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\n\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n\n  return false;\n}\n\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\n\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.backgroundColor = pageColors?.background || null;\n    this.foregroundColor = pageColors?.foreground || null;\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n  }\n\n  getObject(data, fallback = null) {\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n\n    return fallback;\n  }\n\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const defaultBackgroundColor = background || \"#ffffff\";\n    this.ctx.save();\n\n    if (this.foregroundColor && this.backgroundColor) {\n      this.ctx.fillStyle = this.foregroundColor;\n      const fg = this.foregroundColor = this.ctx.fillStyle;\n      this.ctx.fillStyle = this.backgroundColor;\n      const bg = this.backgroundColor = this.ctx.fillStyle;\n      let isValidDefaultBg = true;\n      let defaultBg = defaultBackgroundColor;\n      this.ctx.fillStyle = defaultBackgroundColor;\n      defaultBg = this.ctx.fillStyle;\n      isValidDefaultBg = typeof defaultBg === \"string\" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);\n\n      if (fg === \"#000000\" && bg === \"#ffffff\" || fg === bg || !isValidDefaultBg) {\n        this.foregroundColor = this.backgroundColor = null;\n      } else {\n        const [rB, gB, bB] = (0, _display_utils.getRGB)(defaultBg);\n\n        const newComp = x => {\n          x /= 255;\n          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        };\n\n        const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));\n\n        this.selectColor = (r, g, b) => {\n          const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);\n          return Math.round(lumC) === lumB ? bg : fg;\n        };\n      }\n    }\n\n    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.restore();\n\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n    }\n\n    this.ctx.save();\n    resetCtxToDefault(this.ctx, this.foregroundColor);\n\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n    if (this.imageLayer) {\n      (0, _display_utils.deprecated)(\"The `imageLayer` functionality will be removed in the future.\");\n      this.imageLayer.beginLayout();\n    }\n  }\n\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n\n    if (argsArrayLen === i) {\n      return i;\n    }\n\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n\n      fnId = fnArray[i];\n\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n\n      i++;\n\n      if (i === argsArrayLen) {\n        return i;\n      }\n\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n\n        steps = 0;\n      }\n    }\n  }\n\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n\n    this.ctx.restore();\n\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n\n      cache.clear();\n    }\n\n    this._cachedBitmapsMap.clear();\n\n    if (this.imageLayer) {\n      this.imageLayer.endLayout();\n    }\n  }\n\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n        paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n          newHeight = paintHeight;\n\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = Math.ceil(paintHeight / 2);\n        heightScale /= paintHeight / newHeight;\n      }\n\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      const withoutTranslation = currentTransform.slice(0, 4);\n      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n\n      if (!cache) {\n        cache = new Map();\n\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n\n      const cachedImage = cache.get(cacheKey);\n\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n\n      scaled = cachedImage;\n    }\n\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n\n    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n\n    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n      scaled = scaled.img;\n\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n\n    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n\n  setLineWidth(width) {\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking = null;\n    }\n\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n\n  setRenderingIntent(intent) {}\n\n  setFlatness(flatness) {}\n\n  setGState(states) {\n    for (let i = 0, ii = states.length; i < ii; i++) {\n      const state = states[i];\n      const key = state[0];\n      const value = state[1];\n\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n\n        case \"CA\":\n          this.current.strokeAlpha = state[1];\n          break;\n\n        case \"ca\":\n          this.current.fillAlpha = state[1];\n          this.ctx.globalAlpha = state[1];\n          break;\n\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n\n        case \"TR\":\n          this.current.transferMaps = value;\n      }\n    }\n  }\n\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n\n    this.ctx._removeMirroring();\n\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedScaleForStroking = null;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  constructPath(ops, args, minMax) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n        y = current.y;\n    let startX, startY;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n\n          if (!isScalingMatrix) {\n            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n          }\n\n          ctx.closePath();\n          break;\n\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n\n          break;\n\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n\n          break;\n\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n          j += 6;\n          break;\n\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n          j += 4;\n          break;\n\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n\n    if (isScalingMatrix) {\n      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n    }\n\n    current.setCurrentPoint(x, y);\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n\n  stroke(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n        this.rescaleAndStroke(false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(true);\n      }\n    }\n\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n\n  fill(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n\n    const intersect = this.current.getClippedPathBoundingBox();\n\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n\n    if (needRestore) {\n      ctx.restore();\n    }\n\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n\n  endPath() {\n    this.consumePath();\n  }\n\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n\n    ctx.save();\n    ctx.beginPath();\n\n    for (const path of paths) {\n      ctx.setTransform(...path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n\n    if (fontObj.isType3Font) {\n      return;\n    }\n\n    const name = fontObj.loadedName || \"sans-serif\";\n    let bold = \"normal\";\n\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n    let browserFontSize = size;\n\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n\n  paintChar(character, x, y, patternTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n\n      if (patternTransform) {\n        ctx.setTransform(...patternTransform);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.strokeText(character, x, y);\n      }\n    }\n\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n      paths.push({\n        transform: (0, _display_utils.getCurrentTransform)(ctx),\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n\n    const fontSize = current.fontSize;\n\n    if (fontSize === 0) {\n      return undefined;\n    }\n\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n\n    let patternTransform;\n\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n\n    ctx.lineWidth = lineWidth;\n    let x = 0,\n        i;\n\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform);\n\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n          }\n        }\n      }\n\n      let charWidth;\n\n      if (vertical) {\n        charWidth = width * widthAdvanceScale - spacing * fontDirection;\n      } else {\n        charWidth = width * widthAdvanceScale + spacing * fontDirection;\n      }\n\n      x += charWidth;\n\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n\n    ctx.restore();\n    this.processingType3 = null;\n  }\n\n  setCharWidth(xWidth, yWidth) {}\n\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip();\n    this.endPath();\n  }\n\n  getColorN_Pattern(IR) {\n    let pattern;\n\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n\n    return pattern;\n  }\n\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n\n  setStrokeRGBColor(r, g, b) {\n    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n\n  setFillRGBColor(r, g, b) {\n    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n\n  _getPattern(objId, matrix = null) {\n    let pattern;\n\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n\n    return pattern;\n  }\n\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    this.save();\n\n    const pattern = this._getPattern(objId);\n\n    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n\n    if (inv) {\n      const canvas = ctx.canvas;\n      const width = canvas.width;\n      const height = canvas.height;\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(...matrix);\n    }\n\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n      this.clip();\n      this.endPath();\n    }\n  }\n\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n\n    const currentCtx = this.ctx;\n\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n\n    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n        scaleY = 1;\n\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx, this.foregroundColor);\n    this.ctx.save();\n    this.save();\n\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        resetCtxToDefault(this.ctx, this.foregroundColor);\n      } else {\n        resetCtxToDefault(this.ctx, this.foregroundColor);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.ctx.clip();\n        this.endPath();\n      }\n    }\n\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(...transform);\n    this.transform(...matrix);\n  }\n\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const count = img.count;\n    img = this.getObject(img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const glyph = this.processingType3;\n\n    if (glyph) {\n      if (glyph.compiled === undefined) {\n        glyph.compiled = compileType3Glyph(img);\n      }\n\n      if (glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n    }\n\n    const mask = this._createMaskCanvas(img);\n\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    img = this.getObject(img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n\n    const mask = this._createMaskCanvas(img);\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n\n      ctx.drawImage(mask.canvas, x, y);\n    }\n\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = this.getObject(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    this.paintInlineImageXObject(imgData);\n  }\n\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = this.getObject(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n\n    if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n      imgToPaint = tmpCanvas.canvas;\n    }\n\n    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n    const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n\n    if (this.imageLayer) {\n      const [left, top] = _util.Util.applyTransform([0, -height], (0, _display_utils.getCurrentTransform)(this.ctx));\n\n      this.imageLayer.appendImage({\n        imgData,\n        left,\n        top,\n        width: rWidth,\n        height: rHeight\n      });\n    }\n\n    this.compose();\n    this.restore();\n  }\n\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const w = imgData.width;\n    const h = imgData.height;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n    const tmpCtx = tmpCanvas.context;\n    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n      if (this.imageLayer) {\n        const [left, top] = _util.Util.applyTransform([entry.x, entry.y], (0, _display_utils.getCurrentTransform)(this.ctx));\n\n        this.imageLayer.appendImage({\n          imgData,\n          left,\n          top,\n          width: w,\n          height: h\n        });\n      }\n\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n\n  markPoint(tag) {}\n\n  markPointProps(tag, properties) {}\n\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n\n    this.contentVisible = this.isContentVisible();\n  }\n\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n\n  beginCompat() {}\n\n  endCompat() {}\n\n  consumePath(clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n\n    const ctx = this.ctx;\n\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n      }\n\n      this.pendingClip = null;\n    }\n\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n\n    return this._cachedGetSinglePixelWidth;\n  }\n\n  getScaleForStroking() {\n    if (!this._cachedScaleForStroking) {\n      const {\n        lineWidth\n      } = this.current;\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n      let scaleX, scaleY;\n\n      if (m[1] === 0 && m[2] === 0) {\n        const normX = Math.abs(m[0]);\n        const normY = Math.abs(m[3]);\n\n        if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[1]);\n        const normY = Math.hypot(m[2], m[3]);\n\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n\n      this._cachedScaleForStroking = [scaleX, scaleY];\n    }\n\n    return this._cachedScaleForStroking;\n  }\n\n  rescaleAndStroke(saveRestore) {\n    const {\n      ctx\n    } = this;\n    const {\n      lineWidth\n    } = this.current;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    ctx.lineWidth = lineWidth || 1;\n\n    if (scaleX === 1 && scaleY === 1) {\n      ctx.stroke();\n      return;\n    }\n\n    let savedMatrix, savedDashes, savedDashOffset;\n\n    if (saveRestore) {\n      savedMatrix = (0, _display_utils.getCurrentTransform)(ctx);\n      savedDashes = ctx.getLineDash().slice();\n      savedDashOffset = ctx.lineDashOffset;\n    }\n\n    ctx.scale(scaleX, scaleY);\n    const scale = Math.max(scaleX, scaleY);\n    ctx.setLineDash(ctx.getLineDash().map(x => x / scale));\n    ctx.lineDashOffset /= scale;\n    ctx.stroke();\n\n    if (saveRestore) {\n      ctx.setTransform(...savedMatrix);\n      ctx.setLineDash(savedDashes);\n      ctx.lineDashOffset = savedDashOffset;\n    }\n  }\n\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.CanvasGraphics = CanvasGraphics;\n\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || _is_node.isNodeJS) {\n    return;\n  }\n\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n\n}\n\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n\n  _createGradient(ctx) {\n    let grad;\n\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n\n    return grad;\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n\n      try {\n        pattern.setTransform(domMatrix);\n      } catch (ex) {\n        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n      }\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n\n    return pattern;\n  }\n\n}\n\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n        colors = context.colors;\n  const bytes = data.data,\n        rowSize = data.width * 4;\n  let tmp;\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n  if (y1 >= y3) {\n    return;\n  }\n\n  const c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n        maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      let k;\n\n      if (y < y1) {\n        k = 0;\n      } else {\n        k = (y1 - y) / (y1 - y2);\n      }\n\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n\n    let k;\n\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\n\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n\n      break;\n\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\n\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n\n    if (backgroundColor) {\n      const bytes = data.data;\n\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n\n}\n\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n\n}\n\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\n\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\n\nclass TilingPattern {\n  static get MAX_PATTERN_SIZE() {\n    return (0, _util.shadow)(this, \"MAX_PATTERN_SIZE\", 3000);\n  }\n\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n\n    return {\n      scale,\n      size\n    };\n  }\n\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);\n    graphics.clip();\n    graphics.endPath();\n  }\n\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n          current = graphics.current;\n\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n\n    try {\n      pattern.setTransform(domMatrix);\n    } catch (ex) {\n      (0, _util.warn)(`TilingPattern.getPattern: \"${ex?.message}\".`);\n    }\n\n    return pattern;\n  }\n\n}\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.applyMaskImageData = applyMaskImageData;\n\nvar _util = __w_pdfjs_require__(1);\n\nfunction applyMaskImageData({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height,\n  inverseDecode = false\n}) {\n  const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n\n    if (widthRemainder === 0) {\n      continue;\n    }\n\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n\n  return {\n    srcPos,\n    destPos\n  };\n}\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      const action = this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n\n    ah[actionName] = handler;\n  }\n\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = (0, _util.createPromiseCapability)();\n    this.callbackCapabilities[callbackId] = capability;\n\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n\n    return capability.promise;\n  }\n\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n          sourceName = this.sourceName,\n          targetName = this.targetName,\n          comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n\n  _createStreamSink(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const self = this,\n          action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = (0, _util.createPromiseCapability)();\n          this.ready = this.sinkCapability.promise;\n        }\n\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n\n      sinkCapability: (0, _util.createPromiseCapability)(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n\n  _processStreamMessage(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n          streamSink = this.streamSinks[streamId];\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull && streamSink.onPull());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.controller.enqueue(data.chunk);\n        break;\n\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.isClosed = true;\n        streamController.controller.close();\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n\n  async _deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);\n    delete this.streamControllers[streamId];\n  }\n\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n}\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass Metadata {\n  #metadataMap;\n  #data;\n\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n\n  getRaw() {\n    return this.#data;\n  }\n\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n\n}\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst INTERNAL = Symbol(\"INTERNAL\");\n\nclass OptionalContentGroup {\n  #visible = true;\n\n  constructor(name, intent) {\n    this.name = name;\n    this.intent = intent;\n  }\n\n  get visible() {\n    return this.#visible;\n  }\n\n  _setVisible(internal, visible) {\n    if (internal !== INTERNAL) {\n      (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n    }\n\n    this.#visible = visible;\n  }\n\n}\n\nclass OptionalContentConfig {\n  #cachedHasInitialVisibility = true;\n  #groups = new Map();\n  #initialVisibility = null;\n  #order = null;\n\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n\n    this.#initialVisibility = new Map();\n\n    for (const [id, group] of this.#groups) {\n      this.#initialVisibility.set(id, group.visible);\n    }\n  }\n\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n\n    if (length < 2) {\n      return true;\n    }\n\n    const operator = array[0];\n\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n\n          break;\n\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n\n          break;\n\n        case \"Not\":\n          return !state;\n\n        default:\n          return true;\n      }\n    }\n\n    return operator === \"And\";\n  }\n\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this.#groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n\n    this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n\n    this.#cachedHasInitialVisibility = null;\n  }\n\n  get hasInitialVisibility() {\n    if (this.#cachedHasInitialVisibility !== null) {\n      return this.#cachedHasInitialVisibility;\n    }\n\n    for (const [id, group] of this.#groups) {\n      const visible = this.#initialVisibility.get(id);\n\n      if (group.visible !== visible) {\n        return this.#cachedHasInitialVisibility = false;\n      }\n    }\n\n    return this.#cachedHasInitialVisibility = true;\n  }\n\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n\n    if (this.#order) {\n      return this.#order.slice();\n    }\n\n    return [...this.#groups.keys()];\n  }\n\n  getGroups() {\n    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n  }\n\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n\n}\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    this._contentDispositionFilename = params.contentDispositionFilename || null;\n    const initialData = params.initialData;\n\n    if (initialData?.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n\n        rangeReader._enqueue(buffer);\n\n        return true;\n      });\n\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      const firstReader = this._rangeReaders[0];\n\n      if (firstReader?.onProgress) {\n        firstReader.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n\n      if (fullReader?.onProgress) {\n        fullReader.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n    this._rangeReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n\n    this._pdfDataRangeTransport.abort();\n  }\n\n}\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n\n    this._done = true;\n  }\n\n}\n\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      this._requests.length = 0;\n    }\n\n    this._done = true;\n\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._stream._removeRangeReader(this);\n  }\n\n}\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\n\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n\n      let str = null;\n      const name = node.name;\n\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n\n      if (!node.children) {\n        return;\n      }\n\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n\n    walk(xfa);\n    return output;\n  }\n\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n\n}\n\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n\nvar _base_factory = __w_pdfjs_require__(9);\n\n;\n\nconst fetchData = function (url) {\n  return new Promise((resolve, reject) => {\n    const fs = require(\"fs\");\n\n    fs.readFile(url, (error, data) => {\n      if (error || !data) {\n        reject(new Error(error));\n        return;\n      }\n\n      resolve(new Uint8Array(data));\n    });\n  });\n};\n\nclass NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const Canvas = require(\"canvas\");\n\n    return Canvas.createCanvas(width, height);\n  }\n\n}\n\nexports.NodeCanvasFactory = NodeCanvasFactory;\n\nclass NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\nclass NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url);\n  }\n\n}\n\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditorLayer = void 0;\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _freetext = __w_pdfjs_require__(23);\n\nvar _ink = __w_pdfjs_require__(24);\n\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #boundPointerup = this.pointerup.bind(this);\n  #boundPointerdown = this.pointerdown.bind(this);\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isCleaningUp = false;\n  #uiManager;\n  static _initialized = false;\n\n  constructor(options) {\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n\n      _freetext.FreeTextEditor.initialize(options.l10n);\n\n      _ink.InkEditor.initialize(options.l10n);\n\n      options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);\n    }\n\n    this.#uiManager = options.uiManager;\n    this.annotationStorage = options.annotationStorage;\n    this.pageIndex = options.pageIndex;\n    this.div = options.div;\n    this.#accessibilityManager = options.accessibilityManager;\n    this.#uiManager.addLayer(this);\n  }\n\n  updateToolbar(mode) {\n    this.#uiManager.updateToolbar(mode);\n  }\n\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n\n    if (mode === _util.AnnotationEditorType.INK) {\n      this.addInkEditorIfNeeded(false);\n      this.disableClick();\n    } else {\n      this.enableClick();\n    }\n\n    this.#uiManager.unselectAll();\n  }\n\n  addInkEditorIfNeeded(isCommitting) {\n    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n      return;\n    }\n\n    if (!isCommitting) {\n      for (const editor of this.#editors.values()) {\n        if (editor.isEmpty()) {\n          editor.setInBackground();\n          return;\n        }\n      }\n    }\n\n    const editor = this.#createAndAddNewEditor({\n      offsetX: 0,\n      offsetY: 0\n    });\n    editor.setInBackground();\n  }\n\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n\n  enable() {\n    this.div.style.pointerEvents = \"auto\";\n\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n    }\n  }\n\n  disable() {\n    this.div.style.pointerEvents = \"none\";\n\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n    }\n  }\n\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n\n    if (currentActive === editor) {\n      return;\n    }\n\n    this.#uiManager.setActiveEditor(editor);\n  }\n\n  enableClick() {\n    this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n  }\n\n  disableClick() {\n    this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n  }\n\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n  }\n\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n  }\n\n  remove(editor) {\n    this.#uiManager.removeEditor(editor);\n    this.detach(editor);\n    this.annotationStorage.remove(editor.id);\n    editor.div.style.display = \"none\";\n    setTimeout(() => {\n      editor.div.style.display = \"\";\n      editor.div.remove();\n      editor.isAttachedToDOM = false;\n\n      if (document.activeElement === document.body) {\n        this.#uiManager.focusMainContainer();\n      }\n    }, 0);\n\n    if (!this.#isCleaningUp) {\n      this.addInkEditorIfNeeded(false);\n    }\n  }\n\n  #changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n\n    this.attach(editor);\n    editor.pageIndex = this.pageIndex;\n    editor.parent?.detach(editor);\n    editor.parent = this;\n\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n\n  add(editor) {\n    this.#changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n\n    this.moveEditorInDOM(editor);\n    editor.onceAdded();\n    this.addToAnnotationStorage(editor);\n  }\n\n  moveEditorInDOM(editor) {\n    this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {\n      this.annotationStorage.setValue(editor.id, editor);\n    }\n  }\n\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.rebuild();\n    } else {\n      this.add(editor);\n    }\n  }\n\n  addANewEditor(editor) {\n    const cmd = () => {\n      this.addOrRebuild(editor);\n    };\n\n    const undo = () => {\n      editor.remove();\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  addUndoableEditor(editor) {\n    const cmd = () => {\n      this.addOrRebuild(editor);\n    };\n\n    const undo = () => {\n      editor.remove();\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n\n  #createNewEditor(params) {\n    switch (this.#uiManager.getMode()) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return new _freetext.FreeTextEditor(params);\n\n      case _util.AnnotationEditorType.INK:\n        return new _ink.InkEditor(params);\n    }\n\n    return null;\n  }\n\n  deserialize(data) {\n    switch (data.annotationType) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return _freetext.FreeTextEditor.deserialize(data, this);\n\n      case _util.AnnotationEditorType.INK:\n        return _ink.InkEditor.deserialize(data, this);\n    }\n\n    return null;\n  }\n\n  #createAndAddNewEditor(event) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY\n    });\n\n    if (editor) {\n      this.add(editor);\n    }\n\n    return editor;\n  }\n\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n\n  isSelected(editor) {\n    return this.#uiManager.isSelected(editor);\n  }\n\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n\n  pointerup(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n\n    if (event.target !== this.div) {\n      return;\n    }\n\n    if (!this.#hadPointerDown) {\n      return;\n    }\n\n    this.#hadPointerDown = false;\n\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n\n    this.#createAndAddNewEditor(event);\n  }\n\n  pointerdown(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n\n    if (event.target !== this.div) {\n      return;\n    }\n\n    this.#hadPointerDown = true;\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n\n  drop(event) {\n    const id = event.dataTransfer.getData(\"text/plain\");\n    const editor = this.#uiManager.getEditor(id);\n\n    if (!editor) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n    this.#changeParent(editor);\n    const rect = this.div.getBoundingClientRect();\n    const endX = event.clientX - rect.x;\n    const endY = event.clientY - rect.y;\n    editor.translate(endX - editor.startX, endY - editor.startY);\n    this.moveEditorInDOM(editor);\n    editor.div.focus();\n  }\n\n  dragover(event) {\n    event.preventDefault();\n  }\n\n  destroy() {\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.setActiveEditor(null);\n    }\n\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n      editor.parent = null;\n    }\n\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n\n  #cleanup() {\n    this.#isCleaningUp = true;\n\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n\n    this.#isCleaningUp = false;\n  }\n\n  render(parameters) {\n    this.viewport = parameters.viewport;\n    (0, _tools.bindEvents)(this, this.div, [\"dragover\", \"drop\"]);\n    this.setDimensions();\n\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n    }\n\n    this.updateMode();\n  }\n\n  update(parameters) {\n    this.viewport = parameters.viewport;\n    this.setDimensions();\n    this.updateMode();\n  }\n\n  get scaleFactor() {\n    return this.viewport.scale;\n  }\n\n  get pageDimensions() {\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const width = pageURx - pageLLx;\n    const height = pageURy - pageLLy;\n    return [width, height];\n  }\n\n  get viewportBaseDimensions() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.viewport;\n    return rotation % 180 === 0 ? [width, height] : [height, width];\n  }\n\n  setDimensions() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.viewport;\n    const flipOrientation = rotation % 180 !== 0,\n          widthStr = Math.floor(width) + \"px\",\n          heightStr = Math.floor(height) + \"px\";\n    this.div.style.width = flipOrientation ? heightStr : widthStr;\n    this.div.style.height = flipOrientation ? widthStr : heightStr;\n    this.div.setAttribute(\"data-main-rotation\", rotation);\n  }\n\n}\n\nexports.AnnotationEditorLayer = AnnotationEditorLayer;\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FreeTextEditor = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _editor = __w_pdfjs_require__(6);\n\nclass FreeTextEditor extends _editor.AnnotationEditor {\n  #boundEditorDivBlur = this.editorDivBlur.bind(this);\n  #boundEditorDivFocus = this.editorDivFocus.bind(this);\n  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n  #color;\n  #content = \"\";\n  #hasAlreadyBeenCommitted = false;\n  #fontSize;\n  static _freeTextDefaultContent = \"\";\n  static _l10nPromise;\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static _keyboardManager = new _tools.KeyboardManager([[[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], FreeTextEditor.prototype.commitOrRemove]]);\n  static _type = \"freetext\";\n\n  constructor(params) {\n    super({ ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n  }\n\n  static initialize(l10n) {\n    this._l10nPromise = new Map([\"free_text_default_content\", \"editor_free_text_aria_label\"].map(str => [str, l10n.get(str)]));\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];\n  }\n\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parent.scaleFactor);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n\n    const savedFontsize = this.#fontSize;\n    this.parent.addCommands({\n      cmd: () => {\n        setFontsize(fontSize);\n      },\n      undo: () => {\n        setFontsize(savedFontsize);\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateColor(color) {\n    const savedColor = this.#color;\n    this.parent.addCommands({\n      cmd: () => {\n        this.#color = color;\n        this.editorDiv.style.color = color;\n      },\n      undo: () => {\n        this.#color = savedColor;\n        this.editorDiv.style.color = savedColor;\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  getInitialTranslation() {\n    return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + this.#fontSize) * this.parent.scaleFactor];\n  }\n\n  rebuild() {\n    super.rebuild();\n\n    if (this.div === null) {\n      return;\n    }\n\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return;\n    }\n\n    this.parent.setEditingState(false);\n    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n    super.enableEditMode();\n    this.enableEditing();\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this.div.draggable = false;\n    this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n  }\n\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n\n    this.parent.setEditingState(true);\n    super.disableEditMode();\n    this.disableEditing();\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.draggable = true;\n    this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.div.focus();\n    this.isEditing = false;\n  }\n\n  focusin(event) {\n    super.focusin(event);\n\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n\n  onceAdded() {\n    if (this.width) {\n      return;\n    }\n\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n\n  remove() {\n    this.isEditing = false;\n    this.parent.setEditingState(true);\n    super.remove();\n  }\n\n  #extractText() {\n    const divs = this.editorDiv.getElementsByTagName(\"div\");\n\n    if (divs.length === 0) {\n      return this.editorDiv.innerText;\n    }\n\n    const buffer = [];\n\n    for (let i = 0, ii = divs.length; i < ii; i++) {\n      const div = divs[i];\n      const first = div.firstChild;\n\n      if (first?.nodeName === \"#text\") {\n        buffer.push(first.data);\n      } else {\n        buffer.push(\"\");\n      }\n    }\n\n    return buffer.join(\"\\n\");\n  }\n\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    const rect = this.div.getBoundingClientRect();\n    this.width = rect.width / parentWidth;\n    this.height = rect.height / parentHeight;\n  }\n\n  commit() {\n    super.commit();\n\n    if (!this.#hasAlreadyBeenCommitted) {\n      this.#hasAlreadyBeenCommitted = true;\n      this.parent.addUndoableEditor(this);\n    }\n\n    this.disableEditMode();\n    this.#content = this.#extractText().trimEnd();\n    this.#setEditorDimensions();\n  }\n\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n\n  dblclick(event) {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enableEditMode();\n      this.editorDiv.focus();\n    }\n  }\n\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n\n    let baseX, baseY;\n\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", `${this.id}-editor`);\n    this.enableEditing();\n\n    FreeTextEditor._l10nPromise.get(\"editor_free_text_aria_label\").then(msg => this.editorDiv?.setAttribute(\"aria-label\", msg));\n\n    FreeTextEditor._l10nPromise.get(\"free_text_default_content\").then(msg => this.editorDiv?.setAttribute(\"default-content\", msg));\n\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]);\n\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n\n      for (const line of this.#content.split(\"\\n\")) {\n        const div = document.createElement(\"div\");\n        div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n        this.editorDiv.append(div);\n      }\n\n      this.div.draggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this.div.draggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n\n    return this.div;\n  }\n\n  get contentDiv() {\n    return this.editorDiv;\n  }\n\n  static deserialize(data, parent) {\n    const editor = super.deserialize(data, parent);\n    editor.#fontSize = data.fontSize;\n    editor.#color = _util.Util.makeHexColor(...data.color);\n    editor.#content = data.value;\n    return editor;\n  }\n\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor;\n    const rect = this.getRect(padding, padding);\n\n    const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);\n\n    return {\n      annotationType: _util.AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#content,\n      pageIndex: this.parent.pageIndex,\n      rect,\n      rotation: this.rotation\n    };\n  }\n\n}\n\nexports.FreeTextEditor = FreeTextEditor;\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.InkEditor = void 0;\nObject.defineProperty(exports, \"fitCurve\", ({\n  enumerable: true,\n  get: function () {\n    return _pdfjsFitCurve.fitCurve;\n  }\n}));\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _editor = __w_pdfjs_require__(6);\n\nvar _pdfjsFitCurve = __w_pdfjs_require__(25);\n\nvar _tools = __w_pdfjs_require__(7);\n\nconst RESIZER_SIZE = 16;\n\nclass InkEditor extends _editor.AnnotationEditor {\n  #aspectRatio = 0;\n  #baseHeight = 0;\n  #baseWidth = 0;\n  #boundCanvasPointermove = this.canvasPointermove.bind(this);\n  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n  #boundCanvasPointerup = this.canvasPointerup.bind(this);\n  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n  #disableEditing = false;\n  #isCanvasInitialized = false;\n  #lastPoint = null;\n  #observer = null;\n  #realWidth = 0;\n  #realHeight = 0;\n  #requestFrameCallback = null;\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 1;\n  static _l10nPromise;\n  static _type = \"ink\";\n\n  constructor(params) {\n    super({ ...params,\n      name: \"inkEditor\"\n    });\n    this.color = params.color || null;\n    this.thickness = params.thickness || null;\n    this.opacity = params.opacity || null;\n    this.paths = [];\n    this.bezierPath2D = [];\n    this.currentPath = [];\n    this.scaleFactor = 1;\n    this.translationX = this.translationY = 0;\n    this.x = 0;\n    this.y = 0;\n  }\n\n  static initialize(l10n) {\n    this._l10nPromise = new Map([\"editor_ink_canvas_aria_label\", \"editor_ink_aria_label\"].map(str => [str, l10n.get(str)]));\n  }\n\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        InkEditor._defaultThickness = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        InkEditor._defaultColor = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        InkEditor._defaultOpacity = value / 100;\n        break;\n    }\n  }\n\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        this.#updateThickness(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        this.#updateColor(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        this.#updateOpacity(value);\n        break;\n    }\n  }\n\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n  }\n\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];\n  }\n\n  #updateThickness(thickness) {\n    const savedThickness = this.thickness;\n    this.parent.addCommands({\n      cmd: () => {\n        this.thickness = thickness;\n        this.#fitToContent();\n      },\n      undo: () => {\n        this.thickness = savedThickness;\n        this.#fitToContent();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateColor(color) {\n    const savedColor = this.color;\n    this.parent.addCommands({\n      cmd: () => {\n        this.color = color;\n        this.#redraw();\n      },\n      undo: () => {\n        this.color = savedColor;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateOpacity(opacity) {\n    opacity /= 100;\n    const savedOpacity = this.opacity;\n    this.parent.addCommands({\n      cmd: () => {\n        this.opacity = opacity;\n        this.#redraw();\n      },\n      undo: () => {\n        this.opacity = savedOpacity;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_OPACITY,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  rebuild() {\n    super.rebuild();\n\n    if (this.div === null) {\n      return;\n    }\n\n    if (!this.canvas) {\n      this.#createCanvas();\n      this.#createObserver();\n    }\n\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n      this.#setCanvasDims();\n    }\n\n    this.#fitToContent();\n  }\n\n  remove() {\n    if (this.canvas === null) {\n      return;\n    }\n\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.remove();\n    this.canvas = null;\n    this.#observer.disconnect();\n    this.#observer = null;\n    super.remove();\n  }\n\n  enableEditMode() {\n    if (this.#disableEditing || this.canvas === null) {\n      return;\n    }\n\n    super.enableEditMode();\n    this.div.draggable = false;\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n  }\n\n  disableEditMode() {\n    if (!this.isInEditMode() || this.canvas === null) {\n      return;\n    }\n\n    super.disableEditMode();\n    this.div.draggable = !this.isEmpty();\n    this.div.classList.remove(\"editing\");\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n  }\n\n  onceAdded() {\n    this.div.draggable = !this.isEmpty();\n  }\n\n  isEmpty() {\n    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n  }\n\n  #getInitialBBox() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.parent.viewport;\n\n    switch (rotation) {\n      case 90:\n        return [0, width, width, height];\n\n      case 180:\n        return [width, height, width, height];\n\n      case 270:\n        return [height, 0, width, height];\n\n      default:\n        return [0, 0, width, height];\n    }\n  }\n\n  #setStroke() {\n    this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineJoin = \"round\";\n    this.ctx.miterLimit = 10;\n    this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;\n  }\n\n  #startDrawing(x, y) {\n    this.isEditing = true;\n\n    if (!this.#isCanvasInitialized) {\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.thickness ||= InkEditor._defaultThickness;\n      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n      this.opacity ??= InkEditor._defaultOpacity;\n    }\n\n    this.currentPath.push([x, y]);\n    this.#lastPoint = null;\n    this.#setStroke();\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, y);\n\n    this.#requestFrameCallback = () => {\n      if (!this.#requestFrameCallback) {\n        return;\n      }\n\n      if (this.#lastPoint) {\n        if (this.isEmpty()) {\n          this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        } else {\n          this.#redraw();\n        }\n\n        this.ctx.lineTo(...this.#lastPoint);\n        this.#lastPoint = null;\n        this.ctx.stroke();\n      }\n\n      window.requestAnimationFrame(this.#requestFrameCallback);\n    };\n\n    window.requestAnimationFrame(this.#requestFrameCallback);\n  }\n\n  #draw(x, y) {\n    const [lastX, lastY] = this.currentPath.at(-1);\n\n    if (x === lastX && y === lastY) {\n      return;\n    }\n\n    this.currentPath.push([x, y]);\n    this.#lastPoint = [x, y];\n  }\n\n  #stopDrawing(x, y) {\n    this.ctx.closePath();\n    this.#requestFrameCallback = null;\n    x = Math.min(Math.max(x, 0), this.canvas.width);\n    y = Math.min(Math.max(y, 0), this.canvas.height);\n    const [lastX, lastY] = this.currentPath.at(-1);\n\n    if (x !== lastX || y !== lastY) {\n      this.currentPath.push([x, y]);\n    }\n\n    let bezier;\n\n    if (this.currentPath.length !== 1) {\n      bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);\n    } else {\n      const xy = [x, y];\n      bezier = [[xy, xy.slice(), xy.slice(), xy]];\n    }\n\n    const path2D = InkEditor.#buildPath2D(bezier);\n    this.currentPath.length = 0;\n\n    const cmd = () => {\n      this.paths.push(bezier);\n      this.bezierPath2D.push(path2D);\n      this.rebuild();\n    };\n\n    const undo = () => {\n      this.paths.pop();\n      this.bezierPath2D.pop();\n\n      if (this.paths.length === 0) {\n        this.remove();\n      } else {\n        if (!this.canvas) {\n          this.#createCanvas();\n          this.#createObserver();\n        }\n\n        this.#fitToContent();\n      }\n    };\n\n    this.parent.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  #redraw() {\n    if (this.isEmpty()) {\n      this.#updateTransform();\n      return;\n    }\n\n    this.#setStroke();\n    const {\n      canvas,\n      ctx\n    } = this;\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    this.#updateTransform();\n\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n  }\n\n  commit() {\n    if (this.#disableEditing) {\n      return;\n    }\n\n    super.commit();\n    this.isEditing = false;\n    this.disableEditMode();\n    this.setInForeground();\n    this.#disableEditing = true;\n    this.div.classList.add(\"disabled\");\n    this.#fitToContent(true);\n    this.parent.addInkEditorIfNeeded(true);\n    this.parent.moveEditorInDOM(this);\n    this.div.focus();\n  }\n\n  focusin(event) {\n    super.focusin(event);\n    this.enableEditMode();\n  }\n\n  canvasPointerdown(event) {\n    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n      return;\n    }\n\n    this.setInForeground();\n\n    if (event.type !== \"mouse\") {\n      this.div.focus();\n    }\n\n    event.stopPropagation();\n    this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.#startDrawing(event.offsetX, event.offsetY);\n  }\n\n  canvasPointermove(event) {\n    event.stopPropagation();\n    this.#draw(event.offsetX, event.offsetY);\n  }\n\n  canvasPointerup(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    if (this.isInEditMode() && this.currentPath.length !== 0) {\n      event.stopPropagation();\n      this.#endDrawing(event);\n      this.setInBackground();\n    }\n  }\n\n  canvasPointerleave(event) {\n    this.#endDrawing(event);\n    this.setInBackground();\n  }\n\n  #endDrawing(event) {\n    this.#stopDrawing(event.offsetX, event.offsetY);\n    this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.parent.addToAnnotationStorage(this);\n  }\n\n  #createCanvas() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.className = \"inkEditorCanvas\";\n\n    InkEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(msg => this.canvas?.setAttribute(\"aria-label\", msg));\n\n    this.div.append(this.canvas);\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n\n      if (rect.width && rect.height) {\n        this.setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n\n    let baseX, baseY;\n\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n\n    super.render();\n\n    InkEditor._l10nPromise.get(\"editor_ink_aria_label\").then(msg => this.div?.setAttribute(\"aria-label\", msg));\n\n    const [x, y, w, h] = this.#getInitialBBox();\n    this.setAt(x, y, 0, 0);\n    this.setDims(w, h);\n    this.#createCanvas();\n\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n      this.#redraw();\n      this.#setMinDims();\n      this.div.classList.add(\"disabled\");\n    } else {\n      this.div.classList.add(\"editing\");\n      this.enableEditMode();\n    }\n\n    this.#createObserver();\n    return this.div;\n  }\n\n  #setCanvasDims() {\n    if (!this.#isCanvasInitialized) {\n      return;\n    }\n\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.canvas.width = Math.ceil(this.width * parentWidth);\n    this.canvas.height = Math.ceil(this.height * parentHeight);\n    this.#updateTransform();\n  }\n\n  setDimensions(width, height) {\n    const roundedWidth = Math.round(width);\n    const roundedHeight = Math.round(height);\n\n    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n      return;\n    }\n\n    this.#realWidth = roundedWidth;\n    this.#realHeight = roundedHeight;\n    this.canvas.style.visibility = \"hidden\";\n\n    if (this.#aspectRatio && Math.abs(this.#aspectRatio - width / height) > 1e-2) {\n      height = Math.ceil(width / this.#aspectRatio);\n      this.setDims(width, height);\n    }\n\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n\n    if (this.#disableEditing) {\n      this.#setScaleFactor(width, height);\n    }\n\n    this.#setCanvasDims();\n    this.#redraw();\n    this.canvas.style.visibility = \"visible\";\n  }\n\n  #setScaleFactor(width, height) {\n    const padding = this.#getPadding();\n    const scaleFactorW = (width - padding) / this.#baseWidth;\n    const scaleFactorH = (height - padding) / this.#baseHeight;\n    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n  }\n\n  #updateTransform() {\n    const padding = this.#getPadding() / 2;\n    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n  }\n\n  static #buildPath2D(bezier) {\n    const path2D = new Path2D();\n\n    for (let i = 0, ii = bezier.length; i < ii; i++) {\n      const [first, control1, control2, second] = bezier[i];\n\n      if (i === 0) {\n        path2D.moveTo(...first);\n      }\n\n      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n    }\n\n    return path2D;\n  }\n\n  #serializePaths(s, tx, ty, h) {\n    const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;\n    const paths = [];\n    const padding = this.thickness / 2;\n    let buffer, points;\n\n    for (const bezier of this.paths) {\n      buffer = [];\n      points = [];\n\n      for (let i = 0, ii = bezier.length; i < ii; i++) {\n        const [first, control1, control2, second] = bezier[i];\n        const p10 = s * (first[0] + tx) + padding;\n        const p11 = h - s * (first[1] + ty) - padding;\n        const p20 = s * (control1[0] + tx) + padding;\n        const p21 = h - s * (control1[1] + ty) - padding;\n        const p30 = s * (control2[0] + tx) + padding;\n        const p31 = h - s * (control2[1] + ty) - padding;\n        const p40 = s * (second[0] + tx) + padding;\n        const p41 = h - s * (second[1] + ty) - padding;\n\n        if (i === 0) {\n          buffer.push(p10, p11);\n          points.push(p10, p11);\n        }\n\n        buffer.push(p20, p21, p30, p31, p40, p41);\n        this.#extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);\n      }\n\n      paths.push({\n        bezier: buffer,\n        points\n      });\n    }\n\n    return paths;\n  }\n\n  #extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {\n    if (this.#isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41)) {\n      points.push(p40, p41);\n      return;\n    }\n\n    for (let i = 1; i < n - 1; i++) {\n      const t = i / n;\n      const mt = 1 - t;\n      let q10 = t * p10 + mt * p20;\n      let q11 = t * p11 + mt * p21;\n      let q20 = t * p20 + mt * p30;\n      let q21 = t * p21 + mt * p31;\n      const q30 = t * p30 + mt * p40;\n      const q31 = t * p31 + mt * p41;\n      q10 = t * q10 + mt * q20;\n      q11 = t * q11 + mt * q21;\n      q20 = t * q20 + mt * q30;\n      q21 = t * q21 + mt * q31;\n      q10 = t * q10 + mt * q20;\n      q11 = t * q11 + mt * q21;\n      points.push(q10, q11);\n    }\n\n    points.push(p40, p41);\n  }\n\n  #isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41) {\n    const tol = 10;\n    const ax = (3 * p20 - 2 * p10 - p40) ** 2;\n    const ay = (3 * p21 - 2 * p11 - p41) ** 2;\n    const bx = (3 * p30 - p10 - 2 * p40) ** 2;\n    const by = (3 * p31 - p11 - 2 * p41) ** 2;\n    return Math.max(ax, bx) + Math.max(ay, by) <= tol;\n  }\n\n  #getBbox() {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n\n    for (const path of this.paths) {\n      for (const [first, control1, control2, second] of path) {\n        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n\n        xMin = Math.min(xMin, bbox[0]);\n        yMin = Math.min(yMin, bbox[1]);\n        xMax = Math.max(xMax, bbox[2]);\n        yMax = Math.max(yMax, bbox[3]);\n      }\n    }\n\n    return [xMin, yMin, xMax, yMax];\n  }\n\n  #getPadding() {\n    return this.#disableEditing ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;\n  }\n\n  #fitToContent(firstTime = false) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    if (!this.#disableEditing) {\n      this.#redraw();\n      return;\n    }\n\n    const bbox = this.#getBbox();\n    const padding = this.#getPadding();\n    this.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);\n    this.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);\n    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.#aspectRatio = width / height;\n    this.#setMinDims();\n    const prevTranslationX = this.translationX;\n    const prevTranslationY = this.translationY;\n    this.translationX = -bbox[0];\n    this.translationY = -bbox[1];\n    this.#setCanvasDims();\n    this.#redraw();\n    this.#realWidth = width;\n    this.#realHeight = height;\n    this.setDims(width, height);\n    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n  }\n\n  #setMinDims() {\n    const {\n      style\n    } = this.div;\n\n    if (this.#aspectRatio >= 1) {\n      style.minHeight = `${RESIZER_SIZE}px`;\n      style.minWidth = `${Math.round(this.#aspectRatio * RESIZER_SIZE)}px`;\n    } else {\n      style.minWidth = `${RESIZER_SIZE}px`;\n      style.minHeight = `${Math.round(RESIZER_SIZE / this.#aspectRatio)}px`;\n    }\n  }\n\n  static deserialize(data, parent) {\n    const editor = super.deserialize(data, parent);\n    editor.thickness = data.thickness;\n    editor.color = _util.Util.makeHexColor(...data.color);\n    editor.opacity = data.opacity;\n    const [pageWidth, pageHeight] = parent.pageDimensions;\n    const width = editor.width * pageWidth;\n    const height = editor.height * pageHeight;\n    const scaleFactor = parent.scaleFactor;\n    const padding = data.thickness / 2;\n    editor.#aspectRatio = width / height;\n    editor.#disableEditing = true;\n    editor.#realWidth = Math.round(width);\n    editor.#realHeight = Math.round(height);\n\n    for (const {\n      bezier\n    } of data.paths) {\n      const path = [];\n      editor.paths.push(path);\n      let p0 = scaleFactor * (bezier[0] - padding);\n      let p1 = scaleFactor * (height - bezier[1] - padding);\n\n      for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n        const p10 = scaleFactor * (bezier[i] - padding);\n        const p11 = scaleFactor * (height - bezier[i + 1] - padding);\n        const p20 = scaleFactor * (bezier[i + 2] - padding);\n        const p21 = scaleFactor * (height - bezier[i + 3] - padding);\n        const p30 = scaleFactor * (bezier[i + 4] - padding);\n        const p31 = scaleFactor * (height - bezier[i + 5] - padding);\n        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n        p0 = p30;\n        p1 = p31;\n      }\n\n      const path2D = this.#buildPath2D(path);\n      editor.bezierPath2D.push(path2D);\n    }\n\n    const bbox = editor.#getBbox();\n    editor.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);\n    editor.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);\n    editor.#setScaleFactor(width, height);\n    return editor;\n  }\n\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const rect = this.getRect(0, 0);\n    const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];\n\n    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n\n    return {\n      annotationType: _util.AnnotationEditorType.INK,\n      color,\n      thickness: this.thickness,\n      opacity: this.opacity,\n      paths: this.#serializePaths(this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),\n      pageIndex: this.parent.pageIndex,\n      rect,\n      rotation: this.rotation\n    };\n  }\n\n}\n\nexports.InkEditor = InkEditor;\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fitCurve = void 0;\n\nconst fitCurve = __w_pdfjs_require__(26);\n\nexports.fitCurve = fitCurve;\n\n/***/ }),\n/* 26 */\n/***/ ((module) => {\n\n\n\nfunction fitCurve(points, maxError, progressCallback) {\n  if (!Array.isArray(points)) {\n    throw new TypeError(\"First argument should be an array\");\n  }\n\n  points.forEach(point => {\n    if (!Array.isArray(point) || point.some(item => typeof item !== 'number') || point.length !== points[0].length) {\n      throw Error(\"Each point should be an array of numbers. Each point should have the same amount of numbers.\");\n    }\n  });\n  points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));\n\n  if (points.length < 2) {\n    return [];\n  }\n\n  const len = points.length;\n  const leftTangent = createTangent(points[1], points[0]);\n  const rightTangent = createTangent(points[len - 2], points[len - 1]);\n  return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);\n}\n\nfunction fitCubic(points, leftTangent, rightTangent, error, progressCallback) {\n  const MaxIterations = 20;\n  var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;\n\n  if (points.length === 2) {\n    dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;\n    bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];\n    return [bezCurve];\n  }\n\n  u = chordLengthParameterize(points);\n  [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);\n\n  if (maxError === 0 || maxError < error) {\n    return [bezCurve];\n  }\n\n  if (maxError < error * error) {\n    uPrime = u;\n    prevErr = maxError;\n    prevSplit = splitPoint;\n\n    for (i = 0; i < MaxIterations; i++) {\n      uPrime = reparameterize(bezCurve, points, uPrime);\n      [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);\n\n      if (maxError < error) {\n        return [bezCurve];\n      } else if (splitPoint === prevSplit) {\n        let errChange = maxError / prevErr;\n\n        if (errChange > .9999 && errChange < 1.0001) {\n          break;\n        }\n      }\n\n      prevErr = maxError;\n      prevSplit = splitPoint;\n    }\n  }\n\n  beziers = [];\n  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);\n\n  if (centerVector.every(val => val === 0)) {\n    centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);\n    [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];\n  }\n\n  toCenterTangent = maths.normalize(centerVector);\n  fromCenterTangent = maths.mulItems(toCenterTangent, -1);\n  beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));\n  beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));\n  return beziers;\n}\n\n;\n\nfunction generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {\n  var bezCurve, maxError, splitPoint;\n  bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);\n  [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);\n\n  if (progressCallback) {\n    progressCallback({\n      bez: bezCurve,\n      points: points,\n      params: paramsOrig,\n      maxErr: maxError,\n      maxPoint: splitPoint\n    });\n  }\n\n  return [bezCurve, maxError, splitPoint];\n}\n\nfunction generateBezier(points, parameters, leftTangent, rightTangent) {\n  var bezCurve,\n      A,\n      a,\n      C,\n      X,\n      det_C0_C1,\n      det_C0_X,\n      det_X_C1,\n      alpha_l,\n      alpha_r,\n      epsilon,\n      segLength,\n      i,\n      len,\n      tmp,\n      u,\n      ux,\n      firstPoint = points[0],\n      lastPoint = points[points.length - 1];\n  bezCurve = [firstPoint, null, null, lastPoint];\n  A = maths.zeros_Xx2x2(parameters.length);\n\n  for (i = 0, len = parameters.length; i < len; i++) {\n    u = parameters[i];\n    ux = 1 - u;\n    a = A[i];\n    a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));\n    a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));\n  }\n\n  C = [[0, 0], [0, 0]];\n  X = [0, 0];\n\n  for (i = 0, len = points.length; i < len; i++) {\n    u = parameters[i];\n    a = A[i];\n    C[0][0] += maths.dot(a[0], a[0]);\n    C[0][1] += maths.dot(a[0], a[1]);\n    C[1][0] += maths.dot(a[0], a[1]);\n    C[1][1] += maths.dot(a[1], a[1]);\n    tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));\n    X[0] += maths.dot(a[0], tmp);\n    X[1] += maths.dot(a[1], tmp);\n  }\n\n  det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n  det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];\n  det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];\n  alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;\n  alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;\n  segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));\n  epsilon = 1.0e-6 * segLength;\n\n  if (alpha_l < epsilon || alpha_r < epsilon) {\n    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));\n    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));\n  } else {\n    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));\n    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));\n  }\n\n  return bezCurve;\n}\n\n;\n\nfunction reparameterize(bezier, points, parameters) {\n  return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p));\n}\n\n;\n\nfunction newtonRaphsonRootFind(bez, point, u) {\n  var d = maths.subtract(bezier.q(bez, u), point),\n      qprime = bezier.qprime(bez, u),\n      numerator = maths.mulMatrix(d, qprime),\n      denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));\n\n  if (denominator === 0) {\n    return u;\n  } else {\n    return u - numerator / denominator;\n  }\n}\n\n;\n\nfunction chordLengthParameterize(points) {\n  var u = [],\n      currU,\n      prevU,\n      prevP;\n  points.forEach((p, i) => {\n    currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;\n    u.push(currU);\n    prevU = currU;\n    prevP = p;\n  });\n  u = u.map(x => x / prevU);\n  return u;\n}\n\n;\n\nfunction computeMaxError(points, bez, parameters) {\n  var dist, maxDist, splitPoint, v, i, count, point, t;\n  maxDist = 0;\n  splitPoint = Math.floor(points.length / 2);\n  const t_distMap = mapTtoRelativeDistances(bez, 10);\n\n  for (i = 0, count = points.length; i < count; i++) {\n    point = points[i];\n    t = find_t(bez, parameters[i], t_distMap, 10);\n    v = maths.subtract(bezier.q(bez, t), point);\n    dist = v[0] * v[0] + v[1] * v[1];\n\n    if (dist > maxDist) {\n      maxDist = dist;\n      splitPoint = i;\n    }\n  }\n\n  return [maxDist, splitPoint];\n}\n\n;\n\nvar mapTtoRelativeDistances = function (bez, B_parts) {\n  var B_t_curr;\n  var B_t_dist = [0];\n  var B_t_prev = bez[0];\n  var sumLen = 0;\n\n  for (var i = 1; i <= B_parts; i++) {\n    B_t_curr = bezier.q(bez, i / B_parts);\n    sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));\n    B_t_dist.push(sumLen);\n    B_t_prev = B_t_curr;\n  }\n\n  B_t_dist = B_t_dist.map(x => x / sumLen);\n  return B_t_dist;\n};\n\nfunction find_t(bez, param, t_distMap, B_parts) {\n  if (param < 0) {\n    return 0;\n  }\n\n  if (param > 1) {\n    return 1;\n  }\n\n  var lenMax, lenMin, tMax, tMin, t;\n\n  for (var i = 1; i <= B_parts; i++) {\n    if (param <= t_distMap[i]) {\n      tMin = (i - 1) / B_parts;\n      tMax = i / B_parts;\n      lenMin = t_distMap[i - 1];\n      lenMax = t_distMap[i];\n      t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;\n      break;\n    }\n  }\n\n  return t;\n}\n\nfunction createTangent(pointA, pointB) {\n  return maths.normalize(maths.subtract(pointA, pointB));\n}\n\nclass maths {\n  static zeros_Xx2x2(x) {\n    var zs = [];\n\n    while (x--) {\n      zs.push([0, 0]);\n    }\n\n    return zs;\n  }\n\n  static mulItems(items, multiplier) {\n    return items.map(x => x * multiplier);\n  }\n\n  static mulMatrix(m1, m2) {\n    return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);\n  }\n\n  static subtract(arr1, arr2) {\n    return arr1.map((x1, i) => x1 - arr2[i]);\n  }\n\n  static addArrays(arr1, arr2) {\n    return arr1.map((x1, i) => x1 + arr2[i]);\n  }\n\n  static addItems(items, addition) {\n    return items.map(x => x + addition);\n  }\n\n  static sum(items) {\n    return items.reduce((sum, x) => sum + x);\n  }\n\n  static dot(m1, m2) {\n    return maths.mulMatrix(m1, m2);\n  }\n\n  static vectorLen(v) {\n    return Math.hypot(...v);\n  }\n\n  static divItems(items, divisor) {\n    return items.map(x => x / divisor);\n  }\n\n  static squareItems(items) {\n    return items.map(x => x * x);\n  }\n\n  static normalize(v) {\n    return this.divItems(v, this.vectorLen(v));\n  }\n\n}\n\nclass bezier {\n  static q(ctrlPoly, t) {\n    var tx = 1.0 - t;\n    var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),\n        pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),\n        pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),\n        pD = maths.mulItems(ctrlPoly[3], t * t * t);\n    return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));\n  }\n\n  static qprime(ctrlPoly, t) {\n    var tx = 1.0 - t;\n    var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),\n        pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),\n        pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);\n    return maths.addArrays(maths.addArrays(pA, pB), pC);\n  }\n\n  static qprimeprime(ctrlPoly, t) {\n    return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));\n  }\n\n}\n\nmodule.exports = fitCurve;\nmodule.exports.fitCubic = fitCubic;\nmodule.exports.createTangent = createTangent;\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationLayer = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _annotation_storage = __w_pdfjs_require__(5);\n\nvar _scripting_utils = __w_pdfjs_require__(28);\n\nvar _xfa_layer = __w_pdfjs_require__(29);\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\n\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\n\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n\n            return new PushButtonWidgetAnnotationElement(parameters);\n\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n\n        return new WidgetAnnotationElement(parameters);\n\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n\n}\n\nclass AnnotationElement {\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n    const container = document.createElement(\"section\");\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    container.setAttribute(\"data-annotation-id\", data.id);\n\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n\n        default:\n          break;\n      }\n\n      const borderColor = data.borderColor || null;\n\n      if (borderColor) {\n        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;\n    container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n\n    if (data.hasOwnCanvas || rotation === 0) {\n      container.style.width = `${100 * width / pageWidth}%`;\n      container.style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n\n    return container;\n  }\n\n  setRotation(angle, container = this.container) {\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    const {\n      width,\n      height\n    } = getRectDims(this.data.rect);\n    let elementWidth, elementHeight;\n\n    if (angle % 180 === 0) {\n      elementWidth = 100 * width / pageWidth;\n      elementHeight = 100 * height / pageHeight;\n    } else {\n      elementWidth = 100 * height / pageWidth;\n      elementHeight = 100 * width / pageHeight;\n    }\n\n    container.style.width = `${elementWidth}%`;\n    container.style.height = `${elementHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n    };\n\n    return (0, _util.shadow)(this, \"_commonActions\", {\n      display: event => {\n        const hidden = event.detail.display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden,\n          print: event.detail.display === 0 || event.detail.display === 3\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          print: event.detail.print\n        });\n      },\n      hidden: event => {\n        this.container.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden: event.detail.hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        if (event.detail.readonly) {\n          event.target.setAttribute(\"readonly\", \"\");\n        } else {\n          event.target.removeAttribute(\"readonly\");\n        }\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n\n      if (action) {\n        action(jsEvent);\n      }\n    }\n  }\n\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n\n    if (!storedData) {\n      return;\n    }\n\n    const commonActions = this._commonActions;\n\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n\n  _createQuadrilaterals(ignoreBorder = false) {\n    if (!this.data.quadPoints) {\n      return null;\n    }\n\n    const quadrilaterals = [];\n    const savedRect = this.data.rect;\n\n    for (const quadPoint of this.data.quadPoints) {\n      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n      quadrilaterals.push(this._createContainer(ignoreBorder));\n    }\n\n    this.data.rect = savedRect;\n    return quadrilaterals;\n  }\n\n  _createPopup(trigger, data) {\n    let container = this.container;\n\n    if (this.quadrilaterals) {\n      trigger = trigger || this.quadrilaterals;\n      container = this.quadrilaterals[0];\n    }\n\n    if (!trigger) {\n      trigger = document.createElement(\"div\");\n      trigger.className = \"popupTriggerArea\";\n      container.append(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      titleObj: data.titleObj,\n      modificationDate: data.modificationDate,\n      contentsObj: data.contentsObj,\n      richText: data.richText,\n      hideWrapper: true\n    });\n    const popup = popupElement.render();\n    popup.style.left = \"100%\";\n    container.append(popup);\n  }\n\n  _renderQuadrilaterals(className) {\n    for (const quadrilateral of this.quadrilaterals) {\n      quadrilateral.className = className;\n    }\n\n    return this.quadrilaterals;\n  }\n\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n\n          if (id === skipId) {\n            continue;\n          }\n\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n\n      return fields;\n    }\n\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        id,\n        exportValue\n      } = domElement;\n\n      if (id === skipId) {\n        continue;\n      }\n\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n\n    return fields;\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n\n        isBound = true;\n      }\n\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n\n        isBound = true;\n      }\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n        const linkElement = index === 0 ? link : link.cloneNode();\n        quadrilateral.append(linkElement);\n        return quadrilateral;\n      });\n    }\n\n    this.container.className = \"linkAnnotation\";\n\n    if (isBound) {\n      this.container.append(link);\n    }\n\n    return this.container;\n  }\n\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n\n      return false;\n    };\n\n    if (destination || destination === \"\") {\n      link.className = \"internalLink\";\n    }\n  }\n\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n\n    link.className = \"internalLink\";\n  }\n\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n\n      if (!jsName) {\n        continue;\n      }\n\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n\n    link.className = \"internalLink\";\n  }\n\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n\n    link.className = \"internalLink\";\n\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n\n      return;\n    }\n\n    link.onclick = () => {\n      if (otherClickAction) {\n        otherClickAction();\n      }\n\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n\n      const storage = this.annotationStorage;\n      const allIds = [];\n\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          default:\n            continue;\n        }\n\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n\n      return false;\n    };\n  }\n\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    this.container.className = \"textAnnotation\";\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(image, this.data);\n    }\n\n    this.container.append(image);\n    return this.container;\n  }\n\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n\n    return this.container;\n  }\n\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = AnnotationElement.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n\n  _setEventListener(element, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n\n  _setEventListeners(element, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        this._setEventListener(element, baseName, eventName, getter);\n      }\n    }\n  }\n\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);\n      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util.LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);\n      computedFontSize = Math.min(fontSize, Math.round(height / _util.LINE_FACTOR));\n    }\n\n    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.className = \"textWidgetAnnotation\";\n    let element = null;\n\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.formattedValue || storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n\n      const elementData = {\n        userValue: textContent,\n        formattedValue: null,\n        valueOnFocus: \"\"\n      };\n\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = textContent;\n\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", textContent);\n\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n\n      this._setRequired(element, this.data.required);\n\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n\n        event.target.scrollLeft = 0;\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.userValue) {\n            event.target.value = elementData.userValue;\n          }\n\n          elementData.valueOnFocus = event.target.value;\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n              event.target.value = elementData.userValue;\n            },\n\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n\n              storage.setValue(id, {\n                formattedValue\n              });\n            },\n\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          let commitKey = -1;\n\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\") {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            commitKey = 3;\n          }\n\n          if (commitKey === -1) {\n            return;\n          }\n\n          const {\n            value\n          } = event.target;\n\n          if (elementData.valueOnFocus === value) {\n            return;\n          }\n\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          const {\n            value\n          } = event.target;\n          elementData.userValue = value;\n\n          if (this._mouseState.isDown && elementData.valueOnFocus !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: 1,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n\n          _blurListener(event);\n        });\n\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n                selEnd = selectionEnd;\n\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n\n                  break;\n                }\n\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n\n                  break;\n                }\n\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n\n                break;\n\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n\n                break;\n            }\n\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n\n        this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n\n    this._setTextStyle(element);\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n\n    this._setRequired(element, this.data.required);\n\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n\n    this._setRequired(element, this.data.required);\n\n    element.type = \"radio\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n\n  render() {\n    const container = super.render();\n    container.className = \"buttonWidgetAnnotation pushButton\";\n\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n\n    const linkElement = container.lastChild;\n\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n\n    return container;\n  }\n\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"choiceWidgetAnnotation\";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n\n    this._setRequired(selectElement, this.data.required);\n\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n\n      selectElement.append(optionElement);\n    }\n\n    let removeEmptyEntry = null;\n\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n\n    const getValue = (event, isExport) => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const options = event.target.options;\n\n      if (!event.target.multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n          },\n\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          items(event) {\n            const {\n              items\n            } = event.detail;\n\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(event, true);\n        const value = getValue(event, false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value,\n            changeEx: exportValue,\n            willCommit: true,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n\n      this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(event, true)\n        });\n      });\n    }\n\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n\n    this._setBackgroundColor(selectElement);\n\n    this._setDefaultPropertiesFromJS(selectElement);\n\n    this.container.append(selectElement);\n    return this.container;\n  }\n\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n    this.container.className = \"popupAnnotation\";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n    const parentElements = this.layer.querySelectorAll(selector);\n\n    if (parentElements.length === 0) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: Array.from(parentElements),\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText\n    });\n    const page = this.page;\n\n    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n    const popupTop = rect[1];\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;\n    this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;\n    this.container.append(popup.render());\n    return this.container;\n  }\n\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.titleObj = parameters.titleObj;\n    this.modificationDate = parameters.modificationDate;\n    this.contentsObj = parameters.contentsObj;\n    this.richText = parameters.richText;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"popupWrapper\";\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.hidden = true;\n    const popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    const color = this.color;\n\n    if (color) {\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement(\"h1\");\n    title.dir = this.titleObj.dir;\n    title.textContent = this.titleObj.str;\n    popup.append(title);\n\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n    if (dateObject) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.textContent = \"{{date}}, {{time}}\";\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n      popup.append(modificationDate);\n    }\n\n    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: this.richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n\n      popup.lastChild.className = \"richText popupContent\";\n    } else {\n      const contents = this._formatContents(this.contentsObj);\n\n      popup.append(contents);\n    }\n\n    if (!Array.isArray(this.trigger)) {\n      this.trigger = [this.trigger];\n    }\n\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this._toggle.bind(this));\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n    }\n\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\n    wrapper.append(popup);\n    return wrapper;\n  }\n\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.className = \"popupContent\";\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n\n    return p;\n  }\n\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n\n    if (this.hideElement.hidden) {\n      this.hideElement.hidden = false;\n      this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000;\n    }\n  }\n\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n\n    if (!this.hideElement.hidden && !this.pinned) {\n      this.hideElement.hidden = true;\n      this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000;\n    }\n  }\n\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n  }\n\n  render() {\n    this.container.className = \"freeTextAnnotation\";\n\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.className = \"annotationTextContent\";\n      content.setAttribute(\"role\", \"comment\");\n\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n\n      this.container.append(content);\n    }\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"lineAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n\n    this._createPopup(line, data);\n\n    return this.container;\n  }\n\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"squareAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n\n    this._createPopup(square, data);\n\n    return this.container;\n  }\n\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"circleAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n\n    this._createPopup(circle, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n\n    points = points.join(\" \");\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n\n    this._createPopup(polyline, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"caretAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n\n    for (const inkList of data.inkLists) {\n      let points = [];\n\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n\n      this._createPopup(polyline, data);\n\n      svg.append(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\n    }\n\n    this.container.className = \"highlightAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\n    }\n\n    this.container.className = \"underlineAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\n    }\n\n    this.container.className = \"squigglyAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n    }\n\n    this.container.className = \"strikeoutAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"stampAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      filename,\n      content\n    });\n  }\n\n  render() {\n    this.container.className = \"fileAttachmentAnnotation\";\n    const trigger = document.createElement(\"div\");\n    trigger.className = \"popupTriggerArea\";\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {\n      this._createPopup(trigger, this.data);\n    }\n\n    this.container.append(trigger);\n    return this.container;\n  }\n\n  _download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n\n}\n\nclass AnnotationLayer {\n  static #appendElement(element, id, div, accessibilityManager) {\n    const contentElement = element.firstChild || element;\n    contentElement.id = `${_display_utils.AnnotationPrefix}${id}`;\n    div.append(element);\n    accessibilityManager?.moveElementInDOM(div, element, contentElement, false);\n  }\n\n  static render(parameters) {\n    const {\n      annotations,\n      div,\n      viewport,\n      accessibilityManager\n    } = parameters;\n    this.#setDimensions(div, viewport);\n    let zIndex = 0;\n\n    for (const data of annotations) {\n      if (data.annotationType !== _util.AnnotationType.POPUP) {\n        const {\n          width,\n          height\n        } = getRectDims(data.rect);\n\n        if (width <= 0 || height <= 0) {\n          continue;\n        }\n      }\n\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: div,\n        page: parameters.page,\n        viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\n        renderForms: parameters.renderForms !== false,\n        svgFactory: new _display_utils.DOMSVGFactory(),\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n        enableScripting: parameters.enableScripting,\n        hasJSActions: parameters.hasJSActions,\n        fieldObjects: parameters.fieldObjects,\n        mouseState: parameters.mouseState || {\n          isDown: false\n        }\n      });\n\n      if (element.isRenderable) {\n        const rendered = element.render();\n\n        if (data.hidden) {\n          rendered.style.visibility = \"hidden\";\n        }\n\n        if (Array.isArray(rendered)) {\n          for (const renderedElement of rendered) {\n            renderedElement.style.zIndex = zIndex++;\n            AnnotationLayer.#appendElement(renderedElement, data.id, div, accessibilityManager);\n          }\n        } else {\n          rendered.style.zIndex = zIndex++;\n\n          if (element instanceof PopupAnnotationElement) {\n            div.prepend(rendered);\n          } else {\n            AnnotationLayer.#appendElement(rendered, data.id, div, accessibilityManager);\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n  }\n\n  static update(parameters) {\n    const {\n      annotationCanvasMap,\n      div,\n      viewport\n    } = parameters;\n    this.#setDimensions(div, viewport);\n    this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n    div.hidden = false;\n  }\n\n  static #setDimensions(div, {\n    width,\n    height,\n    rotation\n  }) {\n    const {\n      style\n    } = div;\n    const flipOrientation = rotation % 180 !== 0,\n          widthStr = Math.floor(width) + \"px\",\n          heightStr = Math.floor(height) + \"px\";\n    style.width = flipOrientation ? heightStr : widthStr;\n    style.height = flipOrientation ? widthStr : heightStr;\n    div.setAttribute(\"data-main-rotation\", rotation);\n  }\n\n  static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n    if (!annotationCanvasMap) {\n      return;\n    }\n\n    for (const [id, canvas] of annotationCanvasMap) {\n      const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n\n      if (!element) {\n        continue;\n      }\n\n      const {\n        firstChild\n      } = element;\n\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else {\n        firstChild.before(canvas);\n      }\n    }\n\n    annotationCanvasMap.clear();\n  }\n\n}\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 28 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\n\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return \"#00000000\";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n\n}\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 29 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\n\nvar _xfa_text = __w_pdfjs_require__(20);\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n\n        if (intent === \"print\") {\n          break;\n        }\n\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n\n        break;\n\n      case \"select\":\n        if (storedData.value !== null) {\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            }\n          }\n        }\n\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n\n          break;\n\n        case \"dataId\":\n          break;\n\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n\n        case \"textContent\":\n          html.textContent = value;\n          break;\n\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n\n      }\n    }\n\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n\n    const textDivs = [];\n\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n\n      const child = parent.children[++stack.at(-1)[1]];\n\n      if (child === null) {\n        continue;\n      }\n\n      const {\n        name\n      } = child;\n\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n\n      let childHtml;\n\n      if (child?.attributes?.xmlns) {\n        childHtml = document.createElementNS(child.attributes.xmlns, name);\n      } else {\n        childHtml = document.createElement(name);\n      }\n\n      html.append(childHtml);\n\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n\n        childHtml.append(node);\n      }\n    }\n\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n\n    return {\n      textDivs\n    };\n  }\n\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n\n}\n\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 30 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TextLayerRenderTask = void 0;\nexports.renderTextLayer = renderTextLayer;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nconst AllWhitespaceRegexp = /^\\s+$/g;\n\nfunction getAscent(fontFamily, ctx) {\n  const cachedAscent = ascentCache.get(fontFamily);\n\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n\n  ctx.save();\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n\n  if (ascent) {\n    ctx.restore();\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.restore();\n\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\n\nfunction appendText(task, geom, styles, ctx) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = task._enhanceTextSelection ? {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    originalTransform: null,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 0,\n    scale: 1,\n    fontSize: 0\n  } : {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    fontSize: 0\n  };\n\n  task._textDivs.push(textDiv);\n\n  const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n  let left, top;\n\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n\n  textDiv.style.left = `${left}px`;\n  textDiv.style.top = `${top}px`;\n  textDiv.style.fontSize = `${fontHeight}px`;\n  textDiv.style.fontFamily = style.fontFamily;\n  textDivProperties.fontSize = fontHeight;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n\n  let shouldScaleText = false;\n\n  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n\n  if (shouldScaleText) {\n    if (style.vertical) {\n      textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n    } else {\n      textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n    }\n  }\n\n  task._textDivProperties.set(textDiv, textDivProperties);\n\n  if (task._textContentStream) {\n    task._layoutText(textDiv);\n  }\n\n  if (task._enhanceTextSelection && textDivProperties.hasText) {\n    let angleCos = 1,\n        angleSin = 0;\n\n    if (angle !== 0) {\n      angleCos = Math.cos(angle);\n      angleSin = Math.sin(angle);\n    }\n\n    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n    const divHeight = fontHeight;\n    let m, b;\n\n    if (angle !== 0) {\n      m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n    } else {\n      b = [left, top, left + divWidth, top + divHeight];\n    }\n\n    task._bounds.push({\n      left: b[0],\n      top: b[1],\n      right: b[2],\n      bottom: b[3],\n      div: textDiv,\n      size: [divWidth, divHeight],\n      m\n    });\n  }\n}\n\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    task._renderingDone = true;\n    capability.resolve();\n    return;\n  }\n\n  if (!task._textContentStream) {\n    for (let i = 0; i < textDivsLength; i++) {\n      task._layoutText(textDivs[i]);\n    }\n  }\n\n  task._renderingDone = true;\n  capability.resolve();\n}\n\nfunction findPositiveMin(ts, offset, count) {\n  let result = 0;\n\n  for (let i = 0; i < count; i++) {\n    const t = ts[offset++];\n\n    if (t > 0) {\n      result = result ? Math.min(t, result) : t;\n    }\n  }\n\n  return result;\n}\n\nfunction expand(task) {\n  const bounds = task._bounds;\n  const viewport = task._viewport;\n  const expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n  for (let i = 0; i < expanded.length; i++) {\n    const div = bounds[i].div;\n\n    const divProperties = task._textDivProperties.get(div);\n\n    if (divProperties.angle === 0) {\n      divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n      divProperties.paddingTop = bounds[i].top - expanded[i].top;\n      divProperties.paddingRight = expanded[i].right - bounds[i].right;\n      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n      task._textDivProperties.set(div, divProperties);\n\n      continue;\n    }\n\n    const e = expanded[i],\n          b = bounds[i];\n    const m = b.m,\n          c = m[0],\n          s = m[1];\n    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n    const ts = new Float64Array(64);\n\n    for (let j = 0, jj = points.length; j < jj; j++) {\n      const t = _util.Util.applyTransform(points[j], m);\n\n      ts[j + 0] = c && (e.left - t[0]) / c;\n      ts[j + 4] = s && (e.top - t[1]) / s;\n      ts[j + 8] = c && (e.right - t[0]) / c;\n      ts[j + 12] = s && (e.bottom - t[1]) / s;\n      ts[j + 16] = s && (e.left - t[0]) / -s;\n      ts[j + 20] = c && (e.top - t[1]) / c;\n      ts[j + 24] = s && (e.right - t[0]) / -s;\n      ts[j + 28] = c && (e.bottom - t[1]) / c;\n      ts[j + 32] = c && (e.left - t[0]) / -c;\n      ts[j + 36] = s && (e.top - t[1]) / -s;\n      ts[j + 40] = c && (e.right - t[0]) / -c;\n      ts[j + 44] = s && (e.bottom - t[1]) / -s;\n      ts[j + 48] = s && (e.left - t[0]) / s;\n      ts[j + 52] = c && (e.top - t[1]) / -c;\n      ts[j + 56] = s && (e.right - t[0]) / s;\n      ts[j + 60] = c && (e.bottom - t[1]) / -c;\n    }\n\n    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n    task._textDivProperties.set(div, divProperties);\n  }\n}\n\nfunction expandBounds(width, height, boxes) {\n  const bounds = boxes.map(function (box, i) {\n    return {\n      x1: box.left,\n      y1: box.top,\n      x2: box.right,\n      y2: box.bottom,\n      index: i,\n      x1New: undefined,\n      x2New: undefined\n    };\n  });\n  expandBoundsLTR(width, bounds);\n  const expanded = new Array(boxes.length);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i] = {\n      left: b.x1New,\n      top: 0,\n      right: b.x2New,\n      bottom: 0\n    };\n  }\n\n  boxes.map(function (box, i) {\n    const e = expanded[i],\n          b = bounds[i];\n    b.x1 = box.top;\n    b.y1 = width - e.right;\n    b.x2 = box.bottom;\n    b.y2 = width - e.left;\n    b.index = i;\n    b.x1New = undefined;\n    b.x2New = undefined;\n  });\n  expandBoundsLTR(height, bounds);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i].top = b.x1New;\n    expanded[i].bottom = b.x2New;\n  }\n\n  return expanded;\n}\n\nfunction expandBoundsLTR(width, bounds) {\n  bounds.sort(function (a, b) {\n    return a.x1 - b.x1 || a.index - b.index;\n  });\n  const fakeBoundary = {\n    x1: -Infinity,\n    y1: -Infinity,\n    x2: 0,\n    y2: Infinity,\n    index: -1,\n    x1New: 0,\n    x2New: 0\n  };\n  const horizon = [{\n    start: -Infinity,\n    end: Infinity,\n    boundary: fakeBoundary\n  }];\n\n  for (const boundary of bounds) {\n    let i = 0;\n\n    while (i < horizon.length && horizon[i].end <= boundary.y1) {\n      i++;\n    }\n\n    let j = horizon.length - 1;\n\n    while (j >= 0 && horizon[j].start >= boundary.y2) {\n      j--;\n    }\n\n    let horizonPart, affectedBoundary;\n    let q,\n        k,\n        maxXNew = -Infinity;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      let xNew;\n\n      if (affectedBoundary.x2 > boundary.x1) {\n        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n      } else if (affectedBoundary.x2New === undefined) {\n        xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n      } else {\n        xNew = affectedBoundary.x2New;\n      }\n\n      if (xNew > maxXNew) {\n        maxXNew = xNew;\n      }\n    }\n\n    boundary.x1New = maxXNew;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        if (affectedBoundary.x2 > boundary.x1) {\n          if (affectedBoundary.index > boundary.index) {\n            affectedBoundary.x2New = affectedBoundary.x2;\n          }\n        } else {\n          affectedBoundary.x2New = maxXNew;\n        }\n      } else if (affectedBoundary.x2New > maxXNew) {\n        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n      }\n    }\n\n    const changedHorizon = [];\n    let lastBoundary = null;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n      if (lastBoundary === useBoundary) {\n        changedHorizon.at(-1).end = horizonPart.end;\n      } else {\n        changedHorizon.push({\n          start: horizonPart.start,\n          end: horizonPart.end,\n          boundary: useBoundary\n        });\n        lastBoundary = useBoundary;\n      }\n    }\n\n    if (horizon[i].start < boundary.y1) {\n      changedHorizon[0].start = boundary.y1;\n      changedHorizon.unshift({\n        start: horizon[i].start,\n        end: boundary.y1,\n        boundary: horizon[i].boundary\n      });\n    }\n\n    if (boundary.y2 < horizon[j].end) {\n      changedHorizon.at(-1).end = boundary.y2;\n      changedHorizon.push({\n        start: boundary.y2,\n        end: horizon[j].end,\n        boundary: horizon[j].boundary\n      });\n    }\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New !== undefined) {\n        continue;\n      }\n\n      let used = false;\n\n      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = 0; !used && k < changedHorizon.length; k++) {\n        used = changedHorizon[k].boundary === affectedBoundary;\n      }\n\n      if (!used) {\n        affectedBoundary.x2New = maxXNew;\n      }\n    }\n\n    Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);\n  }\n\n  for (const horizonPart of horizon) {\n    const affectedBoundary = horizonPart.boundary;\n\n    if (affectedBoundary.x2New === undefined) {\n      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n    }\n  }\n}\n\nclass TextLayerRenderTask {\n  constructor({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection\n  }) {\n    if (enhanceTextSelection) {\n      (0, _display_utils.deprecated)(\"The `enhanceTextSelection` functionality will be removed in the future.\");\n    }\n\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n    this._devicePixelRatio = globalThis.devicePixelRatio || 1;\n\n    this._capability.promise.finally(() => {\n      if (!this._enhanceTextSelection) {\n        this._textDivProperties = null;\n      }\n\n      if (this._layoutTextCtx) {\n        this._layoutTextCtx.canvas.width = 0;\n        this._layoutTextCtx.canvas.height = 0;\n        this._layoutTextCtx = null;\n      }\n    }).catch(() => {});\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  cancel() {\n    this._canceled = true;\n\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n\n      this._reader = null;\n    }\n\n    if (this._renderTimer !== null) {\n      clearTimeout(this._renderTimer);\n      this._renderTimer = null;\n    }\n\n    this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n  }\n\n  _processItems(items, styleCache) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      if (items[i].str === undefined) {\n        if (items[i].type === \"beginMarkedContentProps\" || items[i].type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n\n          this._container.classList.add(\"markedContent\");\n\n          if (items[i].id !== null) {\n            this._container.setAttribute(\"id\", `${items[i].id}`);\n          }\n\n          parent.append(this._container);\n        } else if (items[i].type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n\n        continue;\n      }\n\n      this._textContentItemsStr.push(items[i].str);\n\n      appendText(this, items[i], styleCache, this._layoutTextCtx);\n    }\n  }\n\n  _layoutText(textDiv) {\n    const textDivProperties = this._textDivProperties.get(textDiv);\n\n    let transform = \"\";\n\n    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n      const {\n        fontFamily\n      } = textDiv.style;\n      const {\n        fontSize\n      } = textDivProperties;\n\n      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n        this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;\n        this._layoutTextLastFontSize = fontSize;\n        this._layoutTextLastFontFamily = fontFamily;\n      }\n\n      const {\n        width\n      } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n      if (width > 0) {\n        const scale = this._devicePixelRatio * textDivProperties.canvasWidth / width;\n\n        if (this._enhanceTextSelection) {\n          textDivProperties.scale = scale;\n        }\n\n        transform = `scaleX(${scale})`;\n      }\n    }\n\n    if (textDivProperties.angle !== 0) {\n      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n    }\n\n    if (transform.length > 0) {\n      if (this._enhanceTextSelection) {\n        textDivProperties.originalTransform = transform;\n      }\n\n      textDiv.style.transform = transform;\n    }\n\n    if (textDivProperties.hasText) {\n      this._container.append(textDiv);\n    }\n\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n\n      this._container.append(br);\n    }\n  }\n\n  _render(timeout = 0) {\n    const capability = (0, _util.createPromiseCapability)();\n    let styleCache = Object.create(null);\n\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n    this._layoutTextCtx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n\n    if (this._textContent) {\n      const textItems = this._textContent.items;\n      const textStyles = this._textContent.styles;\n\n      this._processItems(textItems, textStyles);\n\n      capability.resolve();\n    } else if (this._textContentStream) {\n      const pump = () => {\n        this._reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n\n          Object.assign(styleCache, value.styles);\n\n          this._processItems(value.items, styleCache);\n\n          pump();\n        }, capability.reject);\n      };\n\n      this._reader = this._textContentStream.getReader();\n      pump();\n    } else {\n      throw new Error('Neither \"textContent\" nor \"textContentStream\" parameters specified.');\n    }\n\n    capability.promise.then(() => {\n      styleCache = null;\n\n      if (!timeout) {\n        render(this);\n      } else {\n        this._renderTimer = setTimeout(() => {\n          render(this);\n          this._renderTimer = null;\n        }, timeout);\n      }\n    }, this._capability.reject);\n  }\n\n  expandTextDivs(expandDivs = false) {\n    if (!this._enhanceTextSelection || !this._renderingDone) {\n      return;\n    }\n\n    if (this._bounds !== null) {\n      expand(this);\n      this._bounds = null;\n    }\n\n    const transformBuf = [],\n          paddingBuf = [];\n\n    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n      const div = this._textDivs[i];\n\n      const divProps = this._textDivProperties.get(div);\n\n      if (!divProps.hasText) {\n        continue;\n      }\n\n      if (expandDivs) {\n        transformBuf.length = 0;\n        paddingBuf.length = 0;\n\n        if (divProps.originalTransform) {\n          transformBuf.push(divProps.originalTransform);\n        }\n\n        if (divProps.paddingTop > 0) {\n          paddingBuf.push(`${divProps.paddingTop}px`);\n          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingRight > 0) {\n          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingBottom > 0) {\n          paddingBuf.push(`${divProps.paddingBottom}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingLeft > 0) {\n          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        div.style.padding = paddingBuf.join(\" \");\n\n        if (transformBuf.length) {\n          div.style.transform = transformBuf.join(\" \");\n        }\n      } else {\n        div.style.padding = null;\n        div.style.transform = divProps.originalTransform;\n      }\n    }\n  }\n\n}\n\nexports.TextLayerRenderTask = TextLayerRenderTask;\n\nfunction renderTextLayer(renderParameters) {\n  const task = new TextLayerRenderTask({\n    textContent: renderParameters.textContent,\n    textContentStream: renderParameters.textContentStream,\n    container: renderParameters.container,\n    viewport: renderParameters.viewport,\n    textDivs: renderParameters.textDivs,\n    textContentItemsStr: renderParameters.textContentItemsStr,\n    enhanceTextSelection: renderParameters.enhanceTextSelection\n  });\n\n  task._render(renderParameters.timeout);\n\n  return task;\n}\n\n/***/ }),\n/* 31 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nlet SVGGraphics = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n  }\n\n};\nexports.SVGGraphics = SVGGraphics;\n{\n  const SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  const createObjectURL = function (data, contentType = \"\", forceDataSchema = false) {\n    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n      return URL.createObjectURL(new Blob([data], {\n        type: contentType\n      }));\n    }\n\n    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let buffer = `data:${contentType};base64,`;\n\n    for (let i = 0, ii = data.length; i < ii; i += 3) {\n      const b1 = data[i] & 0xff;\n      const b2 = data[i + 1] & 0xff;\n      const b3 = data[i + 2] & 0xff;\n      const d1 = b1 >> 2,\n            d2 = (b1 & 3) << 4 | b2 >> 4;\n      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n\n  const convertImgDataToPng = function () {\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    const CHUNK_WRAPPER_SIZE = 12;\n    const crcTable = new Int32Array(256);\n\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      const crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        let input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        const output = require(\"zlib\").deflateSync(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      let pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      const adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++;\n\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      const idat = deflateSync(literals);\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return createObjectURL(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n  }\n\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === \"save\") {\n        opTree.push({\n          fnId: 92,\n          fn: \"group\",\n          items: []\n        });\n        tmp.push(opTree);\n        opTree = opTree.at(-1).items;\n        continue;\n      }\n\n      if (opListElement.fn === \"restore\") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n\n    return opTree;\n  }\n\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  }\n\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = Math.acos(m[0]) * 180 / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n  }\n\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n  exports.SVGGraphics = SVGGraphics = class {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (const op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== _util.OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i]\n        });\n      }\n\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case _util.OPS.beginText:\n            this.beginText();\n            break;\n\n          case _util.OPS.dependency:\n            break;\n\n          case _util.OPS.setLeading:\n            this.setLeading(args);\n            break;\n\n          case _util.OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setFont:\n            this.setFont(args);\n            break;\n\n          case _util.OPS.showText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.endText:\n            this.endText();\n            break;\n\n          case _util.OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n\n          case _util.OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n\n          case _util.OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n\n          case _util.OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n\n          case _util.OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n\n          case _util.OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n\n          case _util.OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n\n          case _util.OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n\n          case _util.OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n\n          case _util.OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n\n          case _util.OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n\n          case _util.OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n\n          case _util.OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n\n          case _util.OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n\n          case _util.OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n\n          case _util.OPS.setGState:\n            this.setGState(args[0]);\n            break;\n\n          case _util.OPS.fill:\n            this.fill();\n            break;\n\n          case _util.OPS.eoFill:\n            this.eoFill();\n            break;\n\n          case _util.OPS.stroke:\n            this.stroke();\n            break;\n\n          case _util.OPS.fillStroke:\n            this.fillStroke();\n            break;\n\n          case _util.OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n\n          case _util.OPS.clip:\n            this.clip(\"nonzero\");\n            break;\n\n          case _util.OPS.eoClip:\n            this.clip(\"evenodd\");\n            break;\n\n          case _util.OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n\n          case _util.OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n\n          case _util.OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n\n          case _util.OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n\n          case _util.OPS.closePath:\n            this.closePath();\n            break;\n\n          case _util.OPS.closeStroke:\n            this.closeStroke();\n            break;\n\n          case _util.OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n\n          case _util.OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n\n          case _util.OPS.nextLine:\n            this.nextLine();\n            break;\n\n          case _util.OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n\n          case _util.OPS.endPath:\n            this.endPath();\n            break;\n\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.hypot(a, b);\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtElement.append(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = _util.IDENTITY_MATRIX;\n      current.lineMatrix = _util.IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n      let x = 0;\n\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (typeof glyph === \"number\") {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n\n          current.tspan.textContent += character;\n        } else {}\n\n        let charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n\n      current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n      if (vertical) {\n        current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n      } else {\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n      }\n\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n      }\n\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n        }\n\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n      } else {\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      let textMatrix = current.textMatrix;\n\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n      current.txtElement.append(current.tspan);\n      current.txtgrp.append(current.txtElement);\n\n      this._ensureTransformGroup().append(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n      }\n\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n        this.defs.append(this.cssStyle);\n      }\n\n      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n      this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      let bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n        current.element = current.txtElement;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", x0);\n      rect.setAttributeNS(null, \"y\", y0);\n      rect.setAttributeNS(null, \"width\", x1 - x0);\n      rect.setAttributeNS(null, \"height\", y1 - y0);\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n      }\n\n      this._ensureTransformGroup().append(rect);\n    }\n\n    _makeColorN_Pattern(args) {\n      if (args[0] === \"TilingPattern\") {\n        return this._makeTilingPattern(args);\n      }\n\n      return this._makeShadingPattern(args);\n    }\n\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n      const tilingId = `shading${shadingCount++}`;\n\n      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\n      tiling.setAttributeNS(null, \"id\", tilingId);\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n      tiling.setAttributeNS(null, \"width\", txstep);\n      tiling.setAttributeNS(null, \"height\", tystep);\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n\n      if (paintType === 2) {\n        const cssColor = _util.Util.makeHexColor(...color);\n\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n\n      this.executeOpTree(this.convertOpList(operatorList));\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n      tiling.append(bbox.childNodes[0]);\n      this.defs.append(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    _makeShadingPattern(args) {\n      if (typeof args === \"string\") {\n        args = this.objs.get(args);\n      }\n\n      switch (args[0]) {\n        case \"RadialAxial\":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case \"axial\":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\n              break;\n\n            case \"radial\":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n              gradient.setAttributeNS(null, \"r\", circleRadius);\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\n              break;\n\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement(\"svg:stop\");\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n            gradient.append(stop);\n          }\n\n          this.defs.append(gradient);\n          return `url(#${shadingId})`;\n\n        case \"Mesh\":\n          (0, _util.warn)(\"Unimplemented pattern Mesh\");\n          return null;\n\n        case \"Dummy\":\n          return \"hotpink\";\n\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n          y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"M\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"L\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            d.push(\"Z\");\n            break;\n        }\n      }\n\n      d = d.join(\" \");\n\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n        d = current.path.getAttributeNS(null, \"d\") + d;\n      } else {\n        current.path = this.svgFactory.createElement(\"svg:path\");\n\n        this._ensureTransformGroup().append(current.path);\n      }\n\n      current.path.setAttributeNS(null, \"d\", d);\n      current.path.setAttributeNS(null, \"fill\", \"none\");\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n      clipPath.setAttributeNS(null, \"id\", clipId);\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      const clipElement = current.element.cloneNode(true);\n\n      if (this.pendingClip === \"evenodd\") {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n      } else {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n      }\n\n      this.pendingClip = null;\n      clipPath.append(clipElement);\n      this.defs.append(clipPath);\n\n      if (current.activeClipUrl) {\n        current.clipGroup = null;\n\n        for (const prev of this.extraStack) {\n          prev.clipGroup = null;\n        }\n\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n      }\n\n      current.activeClipUrl = `url(#${clipId})`;\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n        current.path.setAttributeNS(null, \"d\", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {}\n\n    setFlatness(flatness) {}\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value);\n            break;\n\n          case \"CA\":\n            this.setStrokeAlpha(value);\n            break;\n\n          case \"ca\":\n            this.setFillAlpha(value);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n\n      if (current.element) {\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n\n        current.element.setAttributeNS(null, \"fill\", \"none\");\n        this.endPath();\n      }\n    }\n\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n      element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n      element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n      element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fill();\n    }\n\n    fillStroke() {\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", \"1px\");\n      rect.setAttributeNS(null, \"height\", \"1px\");\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n      this._ensureTransformGroup().append(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", \"0\");\n      cliprect.setAttributeNS(null, \"y\", \"0\");\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n      imgEl.setAttributeNS(null, \"x\", \"0\");\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n      imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n      if (mask) {\n        mask.append(imgEl);\n      } else {\n        this._ensureTransformGroup().append(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement(\"svg:mask\");\n      mask.setAttributeNS(null, \"id\", current.maskId);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", pf(width));\n      rect.setAttributeNS(null, \"height\", pf(height));\n      rect.setAttributeNS(null, \"fill\", fillColor);\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n      this.defs.append(mask);\n\n      this._ensureTransformGroup().append(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\n      svg.append(definitions);\n      this.defs = definitions;\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n      svg.append(rootGroup);\n      this.svg = rootGroup;\n      return svg;\n    }\n\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n        this.svg.append(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n\n      return this.current.clipGroup;\n    }\n\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().append(this.tgrp);\n        } else {\n          this.svg.append(this.tgrp);\n        }\n      }\n\n      return this.tgrp;\n    }\n\n  };\n}\n\n/***/ }),\n/* 32 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\n\nconst fs = require(\"fs\");\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst url = require(\"url\");\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n    this._rangeRequestReaders.push(rangeReader);\n\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNodeStream = PDFNodeStream;\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._headersCapability.resolve();\n\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n\n      this._headersCapability.reject(reason);\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      this._httpHeaders[property] = value;\n    }\n\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n\n      this._headersCapability.resolve();\n    });\n  }\n\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n\n}\n\n/***/ }),\n/* 33 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _content_disposition = __w_pdfjs_require__(34);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 34 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nvar _util = __w_pdfjs_require__(1);\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch (e) {}\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    const parts = [];\n\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n\n      if (quot) {\n        part = unescape(part);\n\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n\n      parts.push(part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 35 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  const array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      xhr.setRequestHeader(property, value);\n    }\n\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n\n    xhr.responseType = \"arraybuffer\";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    pendingRequest.onProgress?.(evt);\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    const xhr = pendingRequest.xhr;\n\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n\n}\n\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n\n    this._done = true;\n\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    this._headersReceivedCapability.reject(this._storedError);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._headersReceivedCapability.reject(reason);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n\n    this._fullRequestReader = null;\n  }\n\n}\n\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    this.onClosed?.(this);\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._close();\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n\n    this._close();\n  }\n\n}\n\n/***/ }),\n/* 36 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFFetchStream = PDFFetchStream;\n\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._reader = response.body.getReader();\n\n      this._headersCapability.resolve();\n\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    this._abortController.abort();\n  }\n\n}\n\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._readCapability.resolve();\n\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    this._abortController.abort();\n  }\n\n}\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AnnotationEditorLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_editor_layer.AnnotationEditorLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorParamsType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorParamsType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorUIManager\", ({\n  enumerable: true,\n  get: function () {\n    return _tools.AnnotationEditorUIManager;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"LoopbackPort\", ({\n  enumerable: true,\n  get: function () {\n    return _api.LoopbackPort;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _svg.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createPromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createPromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(4);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _annotation_editor_layer = __w_pdfjs_require__(22);\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _annotation_layer = __w_pdfjs_require__(27);\n\nvar _worker_options = __w_pdfjs_require__(15);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _text_layer = __w_pdfjs_require__(30);\n\nvar _svg = __w_pdfjs_require__(31);\n\nvar _xfa_layer = __w_pdfjs_require__(29);\n\nconst pdfjsVersion = '2.16.105';\nconst pdfjsBuild = '172ccdbe5';\n{\n  if (_is_node.isNodeJS) {\n    const {\n      PDFNodeStream\n    } = __w_pdfjs_require__(32);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const {\n      PDFNetworkStream\n    } = __w_pdfjs_require__(35);\n\n    const {\n      PDFFetchStream\n    } = __w_pdfjs_require__(36);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      if ((0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map","(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[4577],{\n\n/***/ 99299:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/* provided dependency */ var process = __webpack_require__(83454);\n/* provided dependency */ var Buffer = __webpack_require__(21876)[\"Buffer\"];\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2022 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isAscii = isAscii;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF16BEString = stringToUTF16BEString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\n\n__w_pdfjs_require__(2);\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst LINE_FACTOR = 1.35;\nexports.LINE_FACTOR = LINE_FACTOR;\nconst LINE_DESCENT_FACTOR = 0.35;\nexports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nexports.AnnotationEditorPrefix = AnnotationEditorPrefix;\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  INK: 15\n};\nexports.AnnotationEditorType = AnnotationEditorType;\nconst AnnotationEditorParamsType = {\n  FREETEXT_SIZE: 1,\n  FREETEXT_COLOR: 2,\n  FREETEXT_OPACITY: 3,\n  INK_COLOR: 11,\n  INK_THICKNESS: 12,\n  INK_OPACITY: 13\n};\nexports.AnnotationEditorParamsType = AnnotationEditorParamsType;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nconst AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nconst AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nconst FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1STANDARD: \"TYPE1STANDARD\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  signatures: \"signatures\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontBuildPath: \"errorFontBuildPath\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\",\n  errorContentSubStream: \"errorContentSubStream\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n\n        if (dots && dots.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch (ex) {}\n      }\n    }\n\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n\n}\n\nexports.PasswordException = PasswordException;\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n\n}\n\nexports.UnknownErrorException = UnknownErrorException;\n\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n\n}\n\nexports.InvalidPDFException = InvalidPDFException;\n\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n\n}\n\nexports.MissingPDFException = MissingPDFException;\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n\n}\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n\n}\n\nexports.FormatError = FormatError;\n\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n\n}\n\nexports.AbortException = AbortException;\n\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes === null || bytes.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  const strBuf = [];\n\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  if (arr.byteLength !== undefined) {\n    return arr.byteLength;\n  }\n\n  unreachable(\"Invalid argument for arrayByteLength\");\n}\n\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  let resultLength = 0;\n\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n\n}\n\nexports.FeatureTest = FeatureTest;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n\n  static scaleMinMax(transform, minMax) {\n    let temp;\n\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n\n      minMax[0] *= transform[0];\n      minMax[1] *= transform[0];\n\n      if (transform[3] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n\n      minMax[2] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[2];\n      minMax[2] = temp;\n      temp = minMax[1];\n      minMax[1] = minMax[3];\n      minMax[3] = temp;\n\n      if (transform[1] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n\n      minMax[2] *= transform[1];\n      minMax[3] *= transform[1];\n\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n\n      minMax[0] *= transform[2];\n      minMax[1] *= transform[2];\n    }\n\n    minMax[0] += transform[4];\n    minMax[1] += transform[4];\n    minMax[2] += transform[5];\n    minMax[3] += transform[5];\n  }\n\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n\n  static apply3dTransform(m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n  }\n\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  }\n\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n\n    if (xLow > xHigh) {\n      return null;\n    }\n\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n\n    if (yLow > yHigh) {\n      return null;\n    }\n\n    return [xLow, yLow, xHigh, yHigh];\n  }\n\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n          bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n\n      if (b2ac < 0) {\n        continue;\n      }\n\n      t1 = (-b + sqrtb2ac) / (2 * a);\n\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n\n      t2 = (-b - sqrtb2ac) / (2 * a);\n\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n\n    let j = tvalues.length,\n        mt;\n    const jlen = j;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n\n}\n\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        return decoder.decode(buffer);\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n\n  const strBuf = [];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const code = PDFStringTranslateTable[str.charCodeAt(i)];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n\n    return `\\\\${match}`;\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  const buf = [\"\\xFE\\xFF\"];\n\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n  }\n\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getModificationDate(date = new Date()) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get() {\n      return isSettled;\n    }\n\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\n\nvar _is_node = __w_pdfjs_require__(3);\n\n;\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isNodeJS = void 0;\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.version = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _annotation_storage = __w_pdfjs_require__(5);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _font_loader = __w_pdfjs_require__(11);\n\nvar _canvas = __w_pdfjs_require__(12);\n\nvar _worker_options = __w_pdfjs_require__(15);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _message_handler = __w_pdfjs_require__(16);\n\nvar _metadata = __w_pdfjs_require__(17);\n\nvar _optional_content_config = __w_pdfjs_require__(18);\n\nvar _transport_stream = __w_pdfjs_require__(19);\n\nvar _xfa_text = __w_pdfjs_require__(20);\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nlet DefaultCanvasFactory = _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nlet DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nlet DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n\nif (_is_node.isNodeJS) {\n  const {\n    NodeCanvasFactory,\n    NodeCMapReaderFactory,\n    NodeStandardFontDataFactory\n  } = __w_pdfjs_require__(21);\n\n  exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;\n  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;\n  exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;\n}\n\nlet createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n  let source;\n\n  if (typeof src === \"string\" || src instanceof URL) {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (typeof src !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, TypedArray, or parameter object.\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  const params = Object.create(null);\n  let rangeTransport = null,\n      worker = null;\n\n  for (const key in source) {\n    const value = source[key];\n\n    switch (key) {\n      case \"url\":\n        if (typeof window !== \"undefined\") {\n          try {\n            params[key] = new URL(value, window.location).href;\n            continue;\n          } catch (ex) {\n            (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`);\n          }\n        } else if (typeof value === \"string\" || value instanceof URL) {\n          params[key] = value.toString();\n          continue;\n        }\n\n        throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n\n      case \"range\":\n        rangeTransport = value;\n        continue;\n\n      case \"worker\":\n        worker = value;\n        continue;\n\n      case \"data\":\n        if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) {\n          params[key] = new Uint8Array(value);\n        } else if (value instanceof Uint8Array) {\n          break;\n        } else if (typeof value === \"string\") {\n          params[key] = (0, _util.stringToBytes)(value);\n        } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) {\n          params[key] = new Uint8Array(value);\n        } else if ((0, _util.isArrayBuffer)(value)) {\n          params[key] = new Uint8Array(value);\n        } else {\n          throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n        }\n\n        continue;\n    }\n\n    params[key] = value;\n  }\n\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n  params.enableXfa = params.enableXfa === true;\n\n  if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {\n    params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;\n  }\n\n  if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {\n    params.docBaseUrl = null;\n  }\n\n  if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.cMapUrl !== \"string\") {\n    params.cMapUrl = null;\n  }\n\n  if (typeof params.standardFontDataUrl !== \"string\") {\n    params.standardFontDataUrl = null;\n  }\n\n  if (typeof params.useWorkerFetch !== \"boolean\") {\n    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _is_node.isNodeJS;\n  }\n\n  if (typeof params.useSystemFonts !== \"boolean\") {\n    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;\n  }\n\n  if (typeof params.ownerDocument !== \"object\" || params.ownerDocument === null) {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  const docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          contentDispositionFilename: params.contentDispositionFilename,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\n\nasync function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;\n  }\n\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId,\n    apiVersion: '2.16.105',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties,\n    enableXfa: source.enableXfa,\n    useSystemFonts: source.useSystemFonts,\n    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null\n  });\n\n  if (source.data) {\n    source.data = null;\n  }\n\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  return workerId;\n}\n\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n\n  constructor() {\n    this._capability = (0, _util.createPromiseCapability)();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n    this.onUnsupportedFeature = null;\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  async destroy() {\n    this.destroyed = true;\n    await this._transport?.destroy();\n    this._transport = null;\n\n    if (this._worker) {\n      this._worker.destroy();\n\n      this._worker = null;\n    }\n  }\n\n}\n\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n\n  abort() {}\n\n}\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"fingerprint\", {\n      get() {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.fingerprint`, \" + \"please use `PDFDocumentProxy.fingerprints` instead.\");\n        return this.fingerprints[0];\n      }\n\n    });\n    Object.defineProperty(this, \"getStats\", {\n      value: async () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getStats`, \" + \"please use the `PDFDocumentProxy.stats`-getter instead.\");\n        return this.stats || {\n          streamTypes: {},\n          fontTypes: {}\n        };\n      }\n    });\n  }\n\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n\n  get stats() {\n    return this._transport.stats;\n  }\n\n  get isPureXfa() {\n    return !!this._transport._htmlForXfa;\n  }\n\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n\n  getData() {\n    return this._transport.getData();\n  }\n\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  saveDocument() {\n    if (this._transport.annotationStorage.size <= 0) {\n      (0, _display_utils.deprecated)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n\n    return this._transport.saveDocument();\n  }\n\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n\n}\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._bitmaps = new Set();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this._annotationPromises = new Map();\n    this.destroyed = false;\n  }\n\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n\n    let promise = this._annotationPromises.get(intentArgs.cacheKey);\n\n    if (!promise) {\n      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n\n      this._annotationPromises.set(intentArgs.cacheKey, promise);\n\n      promise = promise.then(annotations => {\n        for (const annotation of annotations) {\n          if (annotation.titleObj !== undefined) {\n            Object.defineProperty(annotation, \"title\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`title`-property on annotation, please use `titleObj` instead.\");\n                return annotation.titleObj.str;\n              }\n\n            });\n          }\n\n          if (annotation.contentsObj !== undefined) {\n            Object.defineProperty(annotation, \"contents\", {\n              get() {\n                (0, _display_utils.deprecated)(\"`contents`-property on annotation, please use `contentsObj` instead.\");\n                return annotation.contentsObj.str;\n              }\n\n            });\n          }\n        }\n\n        return annotations;\n      });\n    }\n\n    return promise;\n  }\n\n  getJSActions() {\n    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);\n  }\n\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null\n  }) {\n    if (arguments[0]?.renderInteractiveForms !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `renderInteractiveForms`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_FORMS;\n      }\n    }\n\n    if (arguments[0]?.includeAnnotationStorage !== undefined) {\n      (0, _display_utils.deprecated)(\"render no longer accepts the `includeAnnotationStorage`-option, \" + \"please use the `annotationMode`-option instead.\");\n\n      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {\n        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;\n      }\n    }\n\n    if (this._stats) {\n      this._stats.time(\"Overall\");\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n      ownerDocument: this._ownerDocument\n    });\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n\n      if (this.cleanupAfterRender || intentPrint) {\n        this.pendingCleanup = true;\n      }\n\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n\n        this._stats.timeEnd(\"Overall\");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.pendingCleanup) {\n        complete();\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.time(\"Rendering\");\n      }\n\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = _util.AnnotationMode.ENABLE,\n    printAnnotationStorage = null\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n\n      this._pumpOperatorList(intentArgs);\n    }\n\n    return intentState.opListReadCapability.promise;\n  }\n\n  streamTextContent({\n    disableCombineTextItems = false,\n    includeMarkedContent = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      combineTextItems: disableCombineTextItems !== true,\n      includeMarkedContent: includeMarkedContent === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n      size(textContent) {\n        return textContent.items.length;\n      }\n\n    });\n  }\n\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n\n  getStructTree() {\n    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);\n  }\n\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n\n    this.objs.clear();\n\n    for (const bitmap of this._bitmaps) {\n      bitmap.close();\n    }\n\n    this._bitmaps.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n\n    this.objs.clear();\n\n    this._annotationPromises.clear();\n\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n\n    if (resetStats && this._stats) {\n      this._stats = new _display_utils.StatTimer();\n    }\n\n    for (const bitmap of this._bitmaps) {\n      bitmap.close();\n    }\n\n    this._bitmaps.clear();\n\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n\n    if (!intentState) {\n      return;\n    }\n\n    if (this._stats) {\n      this._stats.timeEnd(\"Page Request\");\n    }\n\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageMap\n  }) {\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: annotationStorageMap\n    });\n\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(cacheKey);\n\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        this._renderPageChunk(value, intentState);\n\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n\n          this._tryCleanup();\n        }\n\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n\n    pump();\n  }\n\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return;\n    }\n\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n\n        break;\n      }\n    }\n\n    this.cleanup();\n  }\n\n  get stats() {\n    return this._stats;\n  }\n\n}\n\nexports.PDFPageProxy = PDFPageProxy;\n\nclass LoopbackPort {\n  constructor() {\n    this._listeners = [];\n    this._deferred = Promise.resolve();\n  }\n\n  postMessage(obj, transfers) {\n    const event = {\n      data: structuredClone(obj, transfers)\n    };\n\n    this._deferred.then(() => {\n      for (const listener of this._listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n\n}\n\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\nexports.PDFWorkerUtil = PDFWorkerUtil;\n{\n  if (_is_node.isNodeJS && \"function\" === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {\n    let base;\n\n    try {\n      base = new URL(baseUrl);\n\n      if (!base.origin || base.origin === \"null\") {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n\n    const other = new URL(otherUrl, base);\n    return base.origin === other.origin;\n  };\n\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\n\nclass PDFWorker {\n  static #workerPorts = new WeakMap();\n\n  constructor({\n    name = null,\n    port = null,\n    verbosity = (0, _util.getVerbosityLevel)()\n  } = {}) {\n    if (port && PDFWorker.#workerPorts.has(port)) {\n      throw new Error(\"Cannot use more than one PDFWorker per port.\");\n    }\n\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = (0, _util.createPromiseCapability)();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n\n    if (port) {\n      PDFWorker.#workerPorts.set(port, this);\n\n      this._initializeFromPort(port);\n\n      return;\n    }\n\n    this._initialize();\n  }\n\n  get promise() {\n    return this._readyCapability.promise;\n  }\n\n  get port() {\n    return this._port;\n  }\n\n  get messageHandler() {\n    return this._messageHandler;\n  }\n\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n    this._messageHandler.on(\"ready\", function () {});\n\n    this._readyCapability.resolve();\n  }\n\n  _initialize() {\n    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let {\n        workerSrc\n      } = PDFWorker;\n\n      try {\n        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n\n            this._readyCapability.resolve();\n\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n\n          try {\n            sendTest();\n          } catch (e) {\n            this._setupFakeWorker();\n          }\n        });\n\n        const sendTest = () => {\n          const testObj = new Uint8Array();\n          messageHandler.send(\"test\", testObj, [testObj.buffer]);\n        };\n\n        sendTest();\n        return;\n      } catch (e) {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n\n    this._setupFakeWorker();\n  }\n\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n        return;\n      }\n\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n\n      this._readyCapability.resolve();\n\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n\n  destroy() {\n    this.destroyed = true;\n\n    if (this._webWorker) {\n      this._webWorker.terminate();\n\n      this._webWorker = null;\n    }\n\n    PDFWorker.#workerPorts.delete(this._port);\n    this._port = null;\n\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n\n      this._messageHandler = null;\n    }\n  }\n\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n\n    if (this.#workerPorts.has(params.port)) {\n      return this.#workerPorts.get(params.port);\n    }\n\n    return new PDFWorker(params);\n  }\n\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch (ex) {\n      return null;\n    }\n  }\n\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n\n      if (_is_node.isNodeJS && \"function\" === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n\n}\n\nexports.PDFWorker = PDFWorker;\n{\n  PDFWorker.getWorkerSrc = function () {\n    (0, _display_utils.deprecated)(\"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\");\n    return this.workerSrc;\n  };\n}\n\nclass WorkerTransport {\n  #docStats = null;\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #metadataPromise = null;\n\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n\n    if (!params.useWorkerFetch) {\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked\n      });\n      this.StandardFontDataFactory = new params.StandardFontDataFactory({\n        baseUrl: params.standardFontDataUrl\n      });\n    }\n\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n\n  get stats() {\n    return this.#docStats;\n  }\n\n  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let annotationMap = null;\n\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n\n      case \"display\":\n        break;\n\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n\n      case _util.AnnotationMode.ENABLE:\n        break;\n\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        annotationMap = annotationStorage.serializable;\n        break;\n\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,\n      annotationStorageMap: annotationMap\n    };\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = (0, _util.createPromiseCapability)();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    }\n\n    const waitOn = [];\n\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#metadataPromise = null;\n      this._getFieldObjectsPromise = null;\n      this._hasJSActionsPromise = null;\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = (0, _util.createPromiseCapability)();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this._passwordCapability = (0, _util.createPromiseCapability)();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this._passwordCapability.reject(password);\n          } else {\n            this._passwordCapability.resolve({\n              password\n            });\n          }\n        };\n\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n\n      return this._passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const page = this.#pageCache.get(data.pageIndex);\n\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              }\n\n            };\n          }\n\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const pageProxy = this.#pageCache.get(pageIndex);\n\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n          if (imageData) {\n            let length;\n\n            if (imageData.bitmap) {\n              const {\n                bitmap,\n                width,\n                height\n              } = imageData;\n              length = width * height * 4;\n\n              pageProxy._bitmaps.add(bitmap);\n            } else {\n              length = imageData.data?.length || 0;\n            }\n\n            if (length > MAX_IMAGE_SIZE_TO_STORE) {\n              pageProxy.cleanupAfterRender = true;\n            }\n          }\n\n          break;\n\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"DocStats\", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      this.#docStats = Object.freeze({\n        streamTypes: Object.freeze(data.streamTypes),\n        fontTypes: Object.freeze(data.fontTypes)\n      });\n    });\n    messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.CMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.CMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n\n      if (!this.StandardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n\n      return this.StandardFontDataFactory.fetch(data);\n    });\n  }\n\n  _onUnsupportedFeature({\n    featureId\n  }) {\n    if (this.destroyed) {\n      return;\n    }\n\n    this.loadingTask.onUnsupportedFeature?.(featureId);\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n\n    const pageIndex = pageNumber - 1,\n          cachedPromise = this.#pagePromises.get(pageIndex);\n\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n\n  saveDocument() {\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: this.annotationStorage.serializable,\n      filename: this._fullReader?.filename ?? null\n    }).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n\n  getFieldObjects() {\n    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n  }\n\n  hasJSActions() {\n    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null);\n  }\n\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n  }\n\n  getDocJSActions() {\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n  }\n\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n\n  getMetadata() {\n    return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n  }\n\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n\n  async startCleanup(keepLoadedFonts = false) {\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n\n    if (this.destroyed) {\n      return;\n    }\n\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n\n    this.commonObjs.clear();\n\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n\n    this.#metadataPromise = null;\n    this._getFieldObjectsPromise = null;\n    this._hasJSActionsPromise = null;\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch: params.disableAutoFetch,\n      enableXfa: params.enableXfa\n    });\n  }\n\n}\n\nclass PDFObjects {\n  #objs = Object.create(null);\n\n  #ensureObj(objId) {\n    const obj = this.#objs[objId];\n\n    if (obj) {\n      return obj;\n    }\n\n    return this.#objs[objId] = {\n      capability: (0, _util.createPromiseCapability)(),\n      data: null\n    };\n  }\n\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.capability.promise.then(() => callback(obj.data));\n      return null;\n    }\n\n    const obj = this.#objs[objId];\n\n    if (!obj?.capability.settled) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this.#objs[objId];\n    return obj?.capability.settled || false;\n  }\n\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.capability.resolve();\n  }\n\n  clear() {\n    this.#objs = Object.create(null);\n  }\n\n}\n\nclass RenderTask {\n  #internalRenderTask = null;\n\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n\n  cancel() {\n    this.#internalRenderTask.cancel();\n  }\n\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n\n    if (!separateAnnots) {\n      return false;\n    }\n\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n\n}\n\nexports.RenderTask = RenderTask;\n\nclass InternalRenderTask {\n  static #canvasInUse = new WeakSet();\n\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = (0, _util.createPromiseCapability)();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      imageLayer,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n\n    if (this.graphicsReadyCallback) {\n      this.graphicsReadyCallback();\n    }\n  }\n\n  cancel(error = null) {\n    this.running = false;\n    this.cancelled = true;\n\n    if (this.gfx) {\n      this.gfx.endDrawing();\n    }\n\n    if (this._canvas) {\n      InternalRenderTask.#canvasInUse.delete(this._canvas);\n    }\n\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n  }\n\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      if (!this.graphicsReadyCallback) {\n        this.graphicsReadyCallback = this._continueBound;\n      }\n\n      return;\n    }\n\n    if (this.stepper) {\n      this.stepper.updateOperatorList(this.operatorList);\n    }\n\n    if (this.running) {\n      return;\n    }\n\n    this._continue();\n  }\n\n  _continue() {\n    this.running = true;\n\n    if (this.cancelled) {\n      return;\n    }\n\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n\n        if (this._canvas) {\n          InternalRenderTask.#canvasInUse.delete(this._canvas);\n        }\n\n        this.callback();\n      }\n    }\n  }\n\n}\n\nconst version = '2.16.105';\nexports.version = version;\nconst build = '172ccdbe5';\nexports.build = build;\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _editor = __w_pdfjs_require__(6);\n\nvar _murmurhash = __w_pdfjs_require__(10);\n\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n\n  getValue(key, defaultValue) {\n    const value = this._storage.get(key);\n\n    if (value === undefined) {\n      return defaultValue;\n    }\n\n    return Object.assign(defaultValue, value);\n  }\n\n  getRawValue(key) {\n    return this._storage.get(key);\n  }\n\n  remove(key) {\n    this._storage.delete(key);\n\n    if (this._storage.size === 0) {\n      this.resetModified();\n    }\n\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this._storage.values()) {\n        if (value instanceof _editor.AnnotationEditor) {\n          return;\n        }\n      }\n\n      this.onAnnotationEditor(null);\n    }\n  }\n\n  setValue(key, value) {\n    const obj = this._storage.get(key);\n\n    let modified = false;\n\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n\n      this._storage.set(key, value);\n    }\n\n    if (modified) {\n      this.#setModified();\n    }\n\n    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n\n  has(key) {\n    return this._storage.has(key);\n  }\n\n  getAll() {\n    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  #setModified() {\n    if (!this._modified) {\n      this._modified = true;\n\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n\n  get serializable() {\n    if (this._storage.size === 0) {\n      return null;\n    }\n\n    const clone = new Map();\n\n    for (const [key, val] of this._storage) {\n      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;\n\n      if (serialized) {\n        clone.set(key, serialized);\n      }\n    }\n\n    return clone;\n  }\n\n  static getHash(map) {\n    if (!map) {\n      return \"\";\n    }\n\n    const hash = new _murmurhash.MurmurHash3_64();\n\n    for (const [key, val] of map) {\n      hash.update(`${key}:${JSON.stringify(val)}`);\n    }\n\n    return hash.hexdigest();\n  }\n\n}\n\nexports.AnnotationStorage = AnnotationStorage;\n\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable = null;\n\n  constructor(parent) {\n    super();\n    this.#serializable = structuredClone(parent.serializable);\n  }\n\n  get print() {\n    (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n  }\n\n  get serializable() {\n    return this.#serializable;\n  }\n\n}\n\nexports.PrintAnnotationStorage = PrintAnnotationStorage;\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditor = void 0;\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _util = __w_pdfjs_require__(1);\n\nclass AnnotationEditor {\n  #boundFocusin = this.focusin.bind(this);\n  #boundFocusout = this.focusout.bind(this);\n  #hasBeenSelected = false;\n  #isEditing = false;\n  #isInEditMode = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _colorManager = new _tools.ColorManager();\n  static _zIndex = 1;\n\n  constructor(parameters) {\n    if (this.constructor === AnnotationEditor) {\n      (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n    }\n\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    const [width, height] = this.parent.viewportBaseDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.rotation = this.parent.viewport.rotation;\n    this.isAttachedToDOM = false;\n  }\n\n  static get _defaultLineColor() {\n    return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n\n  focusin(event) {\n    if (!this.#hasBeenSelected) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenSelected = false;\n    }\n  }\n\n  focusout(event) {\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n\n    const target = event.relatedTarget;\n\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (!this.parent.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n\n  commit() {\n    this.parent.addToAnnotationStorage(this);\n  }\n\n  dragstart(event) {\n    const rect = this.parent.div.getBoundingClientRect();\n    this.startX = event.clientX - rect.x;\n    this.startY = event.clientY - rect.y;\n    event.dataTransfer.setData(\"text/plain\", this.id);\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parent.viewportBaseDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.div.style.left = `${100 * this.x}%`;\n    this.div.style.top = `${100 * this.y}%`;\n  }\n\n  translate(x, y) {\n    const [width, height] = this.parent.viewportBaseDimensions;\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this.div.style.left = `${100 * this.x}%`;\n    this.div.style.top = `${100 * this.y}%`;\n  }\n\n  screenToPageTranslation(x, y) {\n    const {\n      rotation\n    } = this.parent.viewport;\n\n    switch (rotation) {\n      case 90:\n        return [y, -x];\n\n      case 180:\n        return [-x, -y];\n\n      case 270:\n        return [-y, x];\n\n      default:\n        return [x, y];\n    }\n  }\n\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.div.style.width = `${100 * width / parentWidth}%`;\n    this.div.style.height = `${100 * height / parentHeight}%`;\n  }\n\n  getInitialTranslation() {\n    return [0, 0];\n  }\n\n  render() {\n    this.div = document.createElement(\"div\");\n    this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    this.div.className = this.name;\n    this.div.setAttribute(\"id\", this.id);\n    this.div.setAttribute(\"tabIndex\", 0);\n    this.setInForeground();\n    this.div.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div.addEventListener(\"focusout\", this.#boundFocusout);\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    (0, _tools.bindEvents)(this, this.div, [\"dragstart\", \"pointerdown\"]);\n    return this.div;\n  }\n\n  pointerdown(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n\n    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n      this.parent.toggleSelected(this);\n    } else {\n      this.parent.setSelected(this);\n    }\n\n    this.#hasBeenSelected = true;\n  }\n\n  getRect(tx, ty) {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    const [pageWidth, pageHeight] = this.parent.pageDimensions;\n    const shiftX = pageWidth * tx / parentWidth;\n    const shiftY = pageHeight * ty / parentHeight;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n\n    switch (this.rotation) {\n      case 0:\n        return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];\n\n      case 90:\n        return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];\n\n      case 180:\n        return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];\n\n      case 270:\n        return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];\n\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n\n  onceAdded() {}\n\n  isEmpty() {\n    return false;\n  }\n\n  enableEditMode() {\n    this.#isInEditMode = true;\n  }\n\n  disableEditMode() {\n    this.#isInEditMode = false;\n  }\n\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n\n  shouldGetKeyboardEvents() {\n    return false;\n  }\n\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n\n  rebuild() {\n    this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n  }\n\n  serialize() {\n    (0, _util.unreachable)(\"An editor must be serializable\");\n  }\n\n  static deserialize(data, parent) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId()\n    });\n    editor.rotation = data.rotation;\n    const [pageWidth, pageHeight] = parent.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n\n  remove() {\n    this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n    this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n\n    this.parent.remove(this);\n  }\n\n  select() {\n    this.div?.classList.add(\"selectedEditor\");\n  }\n\n  unselect() {\n    this.div?.classList.remove(\"selectedEditor\");\n  }\n\n  updateParams(type, value) {}\n\n  disableEditing() {}\n\n  enableEditing() {}\n\n  get propertiesToUpdate() {\n    return {};\n  }\n\n  get contentDiv() {\n    return this.div;\n  }\n\n  get isEditing() {\n    return this.#isEditing;\n  }\n\n  set isEditing(value) {\n    this.#isEditing = value;\n\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n\n}\n\nexports.AnnotationEditor = AnnotationEditor;\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;\nexports.bindEvents = bindEvents;\nexports.opacityToHex = opacityToHex;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\n\nfunction opacityToHex(opacity) {\n  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\n\nclass IdManager {\n  #id = 0;\n\n  getId() {\n    return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n  }\n\n}\n\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n\n  add({\n    cmd,\n    undo,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n\n    if (this.#locked) {\n      return;\n    }\n\n    const save = {\n      cmd,\n      undo,\n      type\n    };\n\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n\n      this.#commands[this.#position] = save;\n      return;\n    }\n\n    const next = this.#position + 1;\n\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n\n    this.#commands.push(save);\n  }\n\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n\n    this.#locked = true;\n    this.#commands[this.#position].undo();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      this.#commands[this.#position].cmd();\n      this.#locked = false;\n    }\n  }\n\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n\n  destroy() {\n    this.#commands = null;\n  }\n\n}\n\nexports.CommandManager = CommandManager;\n\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const isMac = KeyboardManager.platform.isMac;\n\n    for (const [keys, callback] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), callback);\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, callback);\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n\n    const callback = this.callbacks.get(this.#serialize(event));\n\n    if (!callback) {\n      return;\n    }\n\n    callback.bind(self)();\n    event.stopPropagation();\n    event.preventDefault();\n  }\n\n}\n\nexports.KeyboardManager = KeyboardManager;\n\nclass ClipboardManager {\n  #elements = null;\n\n  copy(element) {\n    if (!element) {\n      return;\n    }\n\n    if (Array.isArray(element)) {\n      this.#elements = element.map(el => el.serialize());\n    } else {\n      this.#elements = [element.serialize()];\n    }\n\n    this.#elements = this.#elements.filter(el => !!el);\n\n    if (this.#elements.length === 0) {\n      this.#elements = null;\n    }\n  }\n\n  paste() {\n    return this.#elements;\n  }\n\n  isEmpty() {\n    return this.#elements === null;\n  }\n\n  destroy() {\n    this.#elements = null;\n  }\n\n}\n\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    (0, _display_utils.getColorValues)(colors);\n    return (0, _util.shadow)(this, \"_colors\", colors);\n  }\n\n  convert(color) {\n    const rgb = (0, _display_utils.getRGB)(color);\n\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n\n    return rgb;\n  }\n\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n\n    if (!rgb) {\n      return name;\n    }\n\n    return _util.Util.makeHexColor(...rgb);\n  }\n\n}\n\nexports.ColorManager = ColorManager;\n\nclass AnnotationEditorUIManager {\n  #activeEditor = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #clipboardManager = new ClipboardManager();\n  #commandManager = new CommandManager();\n  #currentPageIndex = 0;\n  #editorTypes = null;\n  #eventBus = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #mode = _util.AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #boundKeydown = this.keydown.bind(this);\n  #boundOnEditingAction = this.onEditingAction.bind(this);\n  #boundOnPageChanging = this.onPageChanging.bind(this);\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasEmptyClipboard: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false\n  };\n  #container = null;\n  static _keyboardManager = new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], AnnotationEditorUIManager.prototype.selectAll], [[\"ctrl+c\", \"mac+meta+c\"], AnnotationEditorUIManager.prototype.copy], [[\"ctrl+v\", \"mac+meta+v\"], AnnotationEditorUIManager.prototype.paste], [[\"ctrl+x\", \"mac+meta+x\"], AnnotationEditorUIManager.prototype.cut], [[\"ctrl+z\", \"mac+meta+z\"], AnnotationEditorUIManager.prototype.undo], [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], AnnotationEditorUIManager.prototype.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\"], AnnotationEditorUIManager.prototype.delete], [[\"Escape\", \"mac+Escape\"], AnnotationEditorUIManager.prototype.unselectAll]]);\n\n  constructor(container, eventBus) {\n    this.#container = container;\n    this.#eventBus = eventBus;\n\n    this.#eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n\n    this.#eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n  }\n\n  destroy() {\n    this.#removeKeyboardManager();\n\n    this.#eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n\n    this.#eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#clipboardManager.destroy();\n    this.#commandManager.destroy();\n  }\n\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n\n  focusMainContainer() {\n    this.#container.focus();\n  }\n\n  #addKeyboardManager() {\n    this.#container.addEventListener(\"keydown\", this.#boundKeydown);\n  }\n\n  #removeKeyboardManager() {\n    this.#container.removeEventListener(\"keydown\", this.#boundKeydown);\n  }\n\n  keydown(event) {\n    if (!this.getActive()?.shouldGetKeyboardEvents()) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n\n  onEditingAction(details) {\n    if ([\"undo\", \"redo\", \"cut\", \"copy\", \"paste\", \"delete\", \"selectAll\"].includes(details.name)) {\n      this[details.name]();\n    }\n  }\n\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n\n    if (hasChanged) {\n      this.#eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n    }\n  }\n\n  #dispatchUpdateUI(details) {\n    this.#eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addKeyboardManager();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false,\n        hasEmptyClipboard: this.#clipboardManager.isEmpty()\n      });\n    } else {\n      this.#removeKeyboardManager();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n    }\n  }\n\n  registerEditorTypes(types) {\n    this.#editorTypes = types;\n\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n\n  getId() {\n    return this.#idManager.getId();\n  }\n\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n\n  updateMode(mode) {\n    this.#mode = mode;\n\n    if (mode === _util.AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n    } else {\n      this.setEditingState(true);\n      this.#enableAll();\n\n      for (const layer of this.#allLayers.values()) {\n        layer.updateMode(mode);\n      }\n    }\n  }\n\n  updateToolbar(mode) {\n    if (mode === this.#mode) {\n      return;\n    }\n\n    this.#eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      mode\n    });\n  }\n\n  updateParams(type, value) {\n    for (const editor of this.#selectedEditors) {\n      editor.updateParams(type, value);\n    }\n\n    for (const editorType of this.#editorTypes) {\n      editorType.updateDefaultParams(type, value);\n    }\n  }\n\n  #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n\n      for (const layer of this.#allLayers.values()) {\n        layer.enable();\n      }\n    }\n  }\n\n  #disableAll() {\n    this.unselectAll();\n\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n    }\n  }\n\n  getEditors(pageIndex) {\n    const editors = [];\n\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n\n    return editors;\n  }\n\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n\n  removeEditor(editor) {\n    this.#allEditors.delete(editor.id);\n    this.unselect(editor);\n  }\n\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n    }\n  }\n\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n\n    this.#activeEditor = editor;\n\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  setSelected(editor) {\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n\n    return false;\n  }\n\n  delete() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n    }\n\n    if (!this.hasSelection) {\n      return;\n    }\n\n    const editors = [...this.#selectedEditors];\n\n    const cmd = () => {\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  copy() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n    }\n\n    if (this.hasSelection) {\n      const editors = [];\n\n      for (const editor of this.#selectedEditors) {\n        if (!editor.isEmpty()) {\n          editors.push(editor);\n        }\n      }\n\n      if (editors.length === 0) {\n        return;\n      }\n\n      this.#clipboardManager.copy(editors);\n      this.#dispatchUpdateStates({\n        hasEmptyClipboard: false\n      });\n    }\n  }\n\n  cut() {\n    this.copy();\n    this.delete();\n  }\n\n  paste() {\n    if (this.#clipboardManager.isEmpty()) {\n      return;\n    }\n\n    this.unselectAll();\n    const layer = this.#allLayers.get(this.#currentPageIndex);\n    const newEditors = this.#clipboardManager.paste().map(data => layer.deserialize(data));\n\n    const cmd = () => {\n      for (const editor of newEditors) {\n        this.#addEditorToLayer(editor);\n      }\n\n      this.#selectEditors(newEditors);\n    };\n\n    const undo = () => {\n      for (const editor of newEditors) {\n        editor.remove();\n      }\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  #selectEditors(editors) {\n    this.#selectedEditors.clear();\n\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n\n    this.#selectEditors(this.#allEditors.values());\n  }\n\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      return;\n    }\n\n    if (this.#selectEditors.size === 0) {\n      return;\n    }\n\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n\n  getActive() {\n    return this.#activeEditor;\n  }\n\n  getMode() {\n    return this.#mode;\n  }\n\n}\n\nexports.AnnotationEditorUIManager = AnnotationEditorUIManager;\n\n/***/ }),\n/* 8 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0;\nexports.deprecated = deprecated;\nexports.getColorValues = getColorValues;\nexports.getCurrentTransform = getCurrentTransform;\nexports.getCurrentTransformInverse = getCurrentTransformInverse;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getRGB = getRGB;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\n\nvar _base_factory = __w_pdfjs_require__(9);\n\nvar _util = __w_pdfjs_require__(1);\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nexports.AnnotationPrefix = AnnotationPrefix;\n\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\n\nexports.PixelsPerInch = PixelsPerInch;\n\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n\n}\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nasync function fetchData(url, asTypedArray = false) {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n\n      if (request.status === 200 || request.status === 0) {\n        let data;\n\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n\n      reject(new Error(request.statusText));\n    };\n\n    request.send(null);\n  });\n}\n\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n\n}\n\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n\n}\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n\n    if (rotation < 0) {\n      rotation += 360;\n    }\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n\n}\n\nexports.PageViewport = PageViewport;\n\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, type) {\n    super(msg, \"RenderingCancelledException\");\n    this.type = type;\n  }\n\n}\n\nexports.RenderingCancelledException = RenderingCancelledException;\n\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\n\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf(\"#\");\n  const query = url.indexOf(\"?\");\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch (ex) {}\n    }\n  }\n\n  return suggestedFilename || defaultFilename;\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n\n    for (const time of this.times) {\n      const name = time.name;\n\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n\n    return outBuf.join(\"\");\n  }\n\n}\n\nexports.StatTimer = StatTimer;\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n\n      resolve(evt);\n    };\n\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n\n    (document.head || document.documentElement).append(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    }\n\n    const matches = pdfDateStringRegex.exec(input);\n\n    if (!matches) {\n      return null;\n    }\n\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n\n}\n\nexports.PDFDateString = PDFDateString;\n\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\n\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n\n  (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\n\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  document.body.append(span);\n\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n\n  span.remove();\n}\n\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\n\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\n\n/***/ }),\n/* 9 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    const canvas = this._createCanvas(width, height);\n\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n\n}\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = false\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n  }\n\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n\n}\n\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n\n    const svg = this._createSVG(\"svg:svg\");\n\n    svg.setAttribute(\"version\", \"1.1\");\n\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n\n    return this._createSVG(type);\n  }\n\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n\n}\n\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MurmurHash3_64 = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\n\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n\n  update(input) {\n    let data, length;\n\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if ((0, _util.isArrayBuffer)(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n    }\n\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n        k2 = 0;\n    let h1 = this.h1,\n        h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n          C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n          C2_LOW = C2 & MASK_LOW;\n\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n\n    k1 = 0;\n\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n\n    }\n\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n\n  hexdigest() {\n    let h1 = this.h1,\n        h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    const hex1 = (h1 >>> 0).toString(16),\n          hex2 = (h2 >>> 0).toString(16);\n    return hex1.padStart(8, \"0\") + hex2.padStart(8, \"0\");\n  }\n\n}\n\nexports.MurmurHash3_64 = MurmurHash3_64;\n\n/***/ }),\n/* 11 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement(\"style\");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(styleElement);\n    }\n\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    if (font.attached || font.missingFile) {\n      return;\n    }\n\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n          });\n\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n\n      return;\n    }\n\n    const rule = font.createFontFaceRule();\n\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n  }\n\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n\n  get isSyncFontLoadingSupported() {\n    (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n  }\n\n  get _loadTestFont() {\n    (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n  }\n\n}\n\nlet FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n\n      if (typeof navigator === \"undefined\") {\n        supported = true;\n      } else {\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n        if (m?.[1] >= 14) {\n          supported = true;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n        request.done = true;\n\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n      };\n\n      return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      function int32(data, offset) {\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      let i, ii;\n\n      const canvas = this._document.createElement(\"canvas\");\n\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n      let called = 0;\n\n      function isFontReady(name, callback) {\n        called++;\n\n        if (called > 30) {\n          (0, _util.warn)(\"Load test font never loaded.\");\n          callback();\n          return;\n        }\n\n        ctx.font = \"30px \" + name;\n        ctx.fillText(\".\", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976;\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858;\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n      }\n\n      if (i < loadTestFontId.length) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n      }\n\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n      this.insertRule(rule);\n      const names = [];\n\n      for (const font of fonts) {\n        names.push(font.loadedName);\n      }\n\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement(\"div\");\n\n      div.style.visibility = \"hidden\";\n      div.style.width = div.style.height = \"10px\";\n      div.style.position = \"absolute\";\n      div.style.top = div.style.left = \"0px\";\n\n      for (const name of names) {\n        const span = this._document.createElement(\"span\");\n\n        span.textContent = \"Hi\";\n        span.style.fontFamily = name;\n        div.append(span);\n      }\n\n      this._document.body.append(div);\n\n      isFontReady(loadTestFontId, () => {\n        div.remove();\n        request.complete();\n      });\n    }\n\n  };\n}\n\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    onUnsupportedFeature,\n    fontRegistry = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    let nativeFontFace;\n\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds;\n\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n\n      this._onUnsupportedFeature({\n        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n      });\n\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n\n    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n      const jsBuf = [];\n\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n\n}\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 12 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _pattern_helper = __w_pdfjs_require__(13);\n\nvar _image_utils = __w_pdfjs_require__(14);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = _is_node.isNodeJS && typeof Path2D === \"undefined\" ? -1 : 1000;\nconst FULL_CHUNK_HEIGHT = 16;\n\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n\n  ctx.save = function ctxSave() {\n    destCtx.save();\n\n    this.__originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n\n    this.__originalRestore();\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n\n    this.__originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n\n    this.__originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n\n    this.__originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n\n    this.__originalRotate(angle);\n  };\n\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n\n    this.__originalClip(rule);\n  };\n\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n\n    this.__originalMoveTo(x, y);\n  };\n\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n\n    this.__originalLineTo(x, y);\n  };\n\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n\n    this.__originalRect(x, y, width, height);\n  };\n\n  ctx.closePath = function () {\n    destCtx.closePath();\n\n    this.__originalClosePath();\n  };\n\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n\n    this.__originalBeginPath();\n  };\n}\n\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  getCanvas(id, width, height) {\n    let canvasEntry;\n\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n\n    return canvasEntry;\n  }\n\n  delete(id) {\n    delete this.cache[id];\n  }\n\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n\n}\n\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\n\nfunction compileType3Glyph(imgData) {\n  const {\n    width,\n    height\n  } = imgData;\n\n  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n    return null;\n  }\n\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width1 = width + 1;\n  let points = new Uint8Array(width1 * (height + 1));\n  let i, j, j0;\n  const lineSize = width + 7 & ~7;\n  let data = new Uint8Array(lineSize * height),\n      pos = 0;\n\n  for (const elem of imgData.data) {\n    let mask = 128;\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  let count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const path = new Path2D();\n\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    path.moveTo(p % width1, i);\n    const p0 = p;\n    let type = points[p];\n\n    do {\n      const step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      const pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      path.lineTo(p % width1, p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    --i;\n  }\n\n  data = null;\n  points = null;\n\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.fill(path);\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = null;\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n\n  updateRectMinMax(transform, rect) {\n    const p1 = _util.Util.applyTransform(rect, transform);\n\n    const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n\n    this.minX = Math.min(this.minX, p1[0], p2[0]);\n    this.minY = Math.min(this.minY, p1[1], p2[1]);\n    this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n    this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n  }\n\n  updateScalingPathMinMax(transform, minMax) {\n    _util.Util.scaleMinMax(transform, minMax);\n\n    this.minX = Math.min(this.minX, minMax[0]);\n    this.maxX = Math.max(this.maxX, minMax[1]);\n    this.minY = Math.min(this.minY, minMax[2]);\n    this.maxY = Math.max(this.maxY, minMax[3]);\n  }\n\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], box[0], box[2]);\n      minMax[1] = Math.max(minMax[1], box[0], box[2]);\n      minMax[2] = Math.min(minMax[2], box[1], box[3]);\n      minMax[3] = Math.max(minMax[3], box[1], box[3]);\n      return;\n    }\n\n    this.updateRectMinMax(transform, box);\n  }\n\n  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n\n    return box;\n  }\n\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n\n  isEmptyClip() {\n    return this.minX === Infinity;\n  }\n\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n\n  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n\n}\n\nfunction putBinaryImageData(ctx, imgData, transferMaps = null) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n      destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n  if (transferMaps) {\n    switch (transferMaps.length) {\n      case 1:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[0];\n        transferMapBlue = transferMaps[0];\n        transferMapGray = transferMaps[0];\n        break;\n\n      case 4:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[1];\n        transferMapBlue = transferMaps[2];\n        transferMapGray = transferMaps[3];\n        break;\n    }\n  }\n\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    let white = 0xffffffff;\n    let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n\n    if (transferMapGray) {\n      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n        [white, black] = [black, white];\n      }\n    }\n\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n\n      destPos = 0;\n\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < destPos; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\n\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n\n  const height = imgData.height,\n        width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = (0, _image_utils.applyMaskImageData)({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\n\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n  for (let i = 0, ii = properties.length; i < ii; i++) {\n    const property = properties[i];\n\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\n\nfunction resetCtxToDefault(ctx, foregroundColor) {\n  ctx.strokeStyle = ctx.fillStyle = foregroundColor || \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n}\n\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\n\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\n\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\n\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  let composeFn;\n\n  if (subtype === \"Luminosity\") {\n    composeFn = composeSMaskLuminosity;\n  } else {\n    composeFn = composeSMaskAlpha;\n  }\n\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\n\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\n\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n\n  return false;\n}\n\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\n\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.backgroundColor = pageColors?.background || null;\n    this.foregroundColor = pageColors?.foreground || null;\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n  }\n\n  getObject(data, fallback = null) {\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n\n    return fallback;\n  }\n\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const defaultBackgroundColor = background || \"#ffffff\";\n    this.ctx.save();\n\n    if (this.foregroundColor && this.backgroundColor) {\n      this.ctx.fillStyle = this.foregroundColor;\n      const fg = this.foregroundColor = this.ctx.fillStyle;\n      this.ctx.fillStyle = this.backgroundColor;\n      const bg = this.backgroundColor = this.ctx.fillStyle;\n      let isValidDefaultBg = true;\n      let defaultBg = defaultBackgroundColor;\n      this.ctx.fillStyle = defaultBackgroundColor;\n      defaultBg = this.ctx.fillStyle;\n      isValidDefaultBg = typeof defaultBg === \"string\" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);\n\n      if (fg === \"#000000\" && bg === \"#ffffff\" || fg === bg || !isValidDefaultBg) {\n        this.foregroundColor = this.backgroundColor = null;\n      } else {\n        const [rB, gB, bB] = (0, _display_utils.getRGB)(defaultBg);\n\n        const newComp = x => {\n          x /= 255;\n          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        };\n\n        const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));\n\n        this.selectColor = (r, g, b) => {\n          const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);\n          return Math.round(lumC) === lumB ? bg : fg;\n        };\n      }\n    }\n\n    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.restore();\n\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n    }\n\n    this.ctx.save();\n    resetCtxToDefault(this.ctx, this.foregroundColor);\n\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n    if (this.imageLayer) {\n      (0, _display_utils.deprecated)(\"The `imageLayer` functionality will be removed in the future.\");\n      this.imageLayer.beginLayout();\n    }\n  }\n\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n\n    if (argsArrayLen === i) {\n      return i;\n    }\n\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n\n      fnId = fnArray[i];\n\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n\n      i++;\n\n      if (i === argsArrayLen) {\n        return i;\n      }\n\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n\n        steps = 0;\n      }\n    }\n  }\n\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n\n    this.ctx.restore();\n\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n\n      cache.clear();\n    }\n\n    this._cachedBitmapsMap.clear();\n\n    if (this.imageLayer) {\n      this.imageLayer.endLayout();\n    }\n  }\n\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n        paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n          newHeight = paintHeight;\n\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = Math.ceil(paintHeight / 2);\n        heightScale /= paintHeight / newHeight;\n      }\n\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      const withoutTranslation = currentTransform.slice(0, 4);\n      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n\n      if (!cache) {\n        cache = new Map();\n\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n\n      const cachedImage = cache.get(cacheKey);\n\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n\n      scaled = cachedImage;\n    }\n\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n\n    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n\n    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n      scaled = scaled.img;\n\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n\n    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n\n  setLineWidth(width) {\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking = null;\n    }\n\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n\n  setRenderingIntent(intent) {}\n\n  setFlatness(flatness) {}\n\n  setGState(states) {\n    for (let i = 0, ii = states.length; i < ii; i++) {\n      const state = states[i];\n      const key = state[0];\n      const value = state[1];\n\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n\n        case \"CA\":\n          this.current.strokeAlpha = state[1];\n          break;\n\n        case \"ca\":\n          this.current.fillAlpha = state[1];\n          this.ctx.globalAlpha = state[1];\n          break;\n\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n\n        case \"TR\":\n          this.current.transferMaps = value;\n      }\n    }\n  }\n\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n\n    this.ctx._removeMirroring();\n\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedScaleForStroking = null;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  constructPath(ops, args, minMax) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n        y = current.y;\n    let startX, startY;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n\n          if (!isScalingMatrix) {\n            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n          }\n\n          ctx.closePath();\n          break;\n\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n\n          break;\n\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n\n          break;\n\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n          j += 6;\n          break;\n\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n          j += 4;\n          break;\n\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n\n    if (isScalingMatrix) {\n      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n    }\n\n    current.setCurrentPoint(x, y);\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n\n  stroke(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n        this.rescaleAndStroke(false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(true);\n      }\n    }\n\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n\n  fill(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n\n    const intersect = this.current.getClippedPathBoundingBox();\n\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n\n    if (needRestore) {\n      ctx.restore();\n    }\n\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n\n  endPath() {\n    this.consumePath();\n  }\n\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n\n    ctx.save();\n    ctx.beginPath();\n\n    for (const path of paths) {\n      ctx.setTransform(...path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n\n    if (fontObj.isType3Font) {\n      return;\n    }\n\n    const name = fontObj.loadedName || \"sans-serif\";\n    let bold = \"normal\";\n\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n    let browserFontSize = size;\n\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n\n  paintChar(character, x, y, patternTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n\n      if (patternTransform) {\n        ctx.setTransform(...patternTransform);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.strokeText(character, x, y);\n      }\n    }\n\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n      paths.push({\n        transform: (0, _display_utils.getCurrentTransform)(ctx),\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n\n    const fontSize = current.fontSize;\n\n    if (fontSize === 0) {\n      return undefined;\n    }\n\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n\n    let patternTransform;\n\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n\n    ctx.lineWidth = lineWidth;\n    let x = 0,\n        i;\n\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform);\n\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n          }\n        }\n      }\n\n      let charWidth;\n\n      if (vertical) {\n        charWidth = width * widthAdvanceScale - spacing * fontDirection;\n      } else {\n        charWidth = width * widthAdvanceScale + spacing * fontDirection;\n      }\n\n      x += charWidth;\n\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n\n    this._cachedScaleForStroking = null;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n\n    ctx.restore();\n    this.processingType3 = null;\n  }\n\n  setCharWidth(xWidth, yWidth) {}\n\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip();\n    this.endPath();\n  }\n\n  getColorN_Pattern(IR) {\n    let pattern;\n\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n\n    return pattern;\n  }\n\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n\n  setStrokeRGBColor(r, g, b) {\n    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n\n  setFillRGBColor(r, g, b) {\n    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);\n\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n\n  _getPattern(objId, matrix = null) {\n    let pattern;\n\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n\n    return pattern;\n  }\n\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    this.save();\n\n    const pattern = this._getPattern(objId);\n\n    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n\n    if (inv) {\n      const canvas = ctx.canvas;\n      const width = canvas.width;\n      const height = canvas.height;\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(...matrix);\n    }\n\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n      this.clip();\n      this.endPath();\n    }\n  }\n\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n\n    const currentCtx = this.ctx;\n\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n\n    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n        scaleY = 1;\n\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx, this.foregroundColor);\n    this.ctx.save();\n    this.save();\n\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        resetCtxToDefault(this.ctx, this.foregroundColor);\n      } else {\n        resetCtxToDefault(this.ctx, this.foregroundColor);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.ctx.clip();\n        this.endPath();\n      }\n    }\n\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(...transform);\n    this.transform(...matrix);\n  }\n\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const count = img.count;\n    img = this.getObject(img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const glyph = this.processingType3;\n\n    if (glyph) {\n      if (glyph.compiled === undefined) {\n        glyph.compiled = compileType3Glyph(img);\n      }\n\n      if (glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n    }\n\n    const mask = this._createMaskCanvas(img);\n\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    img = this.getObject(img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n\n    const mask = this._createMaskCanvas(img);\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n\n      ctx.drawImage(mask.canvas, x, y);\n    }\n\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = this.getObject(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    this.paintInlineImageXObject(imgData);\n  }\n\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const imgData = this.getObject(objId);\n\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n\n    if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n      imgToPaint = tmpCanvas.canvas;\n    }\n\n    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n    const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n\n    if (this.imageLayer) {\n      const [left, top] = _util.Util.applyTransform([0, -height], (0, _display_utils.getCurrentTransform)(this.ctx));\n\n      this.imageLayer.appendImage({\n        imgData,\n        left,\n        top,\n        width: rWidth,\n        height: rHeight\n      });\n    }\n\n    this.compose();\n    this.restore();\n  }\n\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    const ctx = this.ctx;\n    const w = imgData.width;\n    const h = imgData.height;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n    const tmpCtx = tmpCanvas.context;\n    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n      if (this.imageLayer) {\n        const [left, top] = _util.Util.applyTransform([entry.x, entry.y], (0, _display_utils.getCurrentTransform)(this.ctx));\n\n        this.imageLayer.appendImage({\n          imgData,\n          left,\n          top,\n          width: w,\n          height: h\n        });\n      }\n\n      ctx.restore();\n    }\n\n    this.compose();\n  }\n\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n\n  markPoint(tag) {}\n\n  markPointProps(tag, properties) {}\n\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n\n    this.contentVisible = this.isContentVisible();\n  }\n\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n\n  beginCompat() {}\n\n  endCompat() {}\n\n  consumePath(clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n\n    const ctx = this.ctx;\n\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n      }\n\n      this.pendingClip = null;\n    }\n\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n\n    return this._cachedGetSinglePixelWidth;\n  }\n\n  getScaleForStroking() {\n    if (!this._cachedScaleForStroking) {\n      const {\n        lineWidth\n      } = this.current;\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n      let scaleX, scaleY;\n\n      if (m[1] === 0 && m[2] === 0) {\n        const normX = Math.abs(m[0]);\n        const normY = Math.abs(m[3]);\n\n        if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[1]);\n        const normY = Math.hypot(m[2], m[3]);\n\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n\n      this._cachedScaleForStroking = [scaleX, scaleY];\n    }\n\n    return this._cachedScaleForStroking;\n  }\n\n  rescaleAndStroke(saveRestore) {\n    const {\n      ctx\n    } = this;\n    const {\n      lineWidth\n    } = this.current;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    ctx.lineWidth = lineWidth || 1;\n\n    if (scaleX === 1 && scaleY === 1) {\n      ctx.stroke();\n      return;\n    }\n\n    let savedMatrix, savedDashes, savedDashOffset;\n\n    if (saveRestore) {\n      savedMatrix = (0, _display_utils.getCurrentTransform)(ctx);\n      savedDashes = ctx.getLineDash().slice();\n      savedDashOffset = ctx.lineDashOffset;\n    }\n\n    ctx.scale(scaleX, scaleY);\n    const scale = Math.max(scaleX, scaleY);\n    ctx.setLineDash(ctx.getLineDash().map(x => x / scale));\n    ctx.lineDashOffset /= scale;\n    ctx.stroke();\n\n    if (saveRestore) {\n      ctx.setTransform(...savedMatrix);\n      ctx.setLineDash(savedDashes);\n      ctx.lineDashOffset = savedDashOffset;\n    }\n  }\n\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.CanvasGraphics = CanvasGraphics;\n\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 13 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || _is_node.isNodeJS) {\n    return;\n  }\n\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n\n}\n\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n\n  _createGradient(ctx) {\n    let grad;\n\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n\n    return grad;\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n\n      try {\n        pattern.setTransform(domMatrix);\n      } catch (ex) {\n        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n      }\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n\n    return pattern;\n  }\n\n}\n\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n        colors = context.colors;\n  const bytes = data.data,\n        rowSize = data.width * 4;\n  let tmp;\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n  if (y1 >= y3) {\n    return;\n  }\n\n  const c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n        maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      let k;\n\n      if (y < y1) {\n        k = 0;\n      } else {\n        k = (y1 - y) / (y1 - y2);\n      }\n\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n\n    let k;\n\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\n\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n\n      break;\n\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\n\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n\n    if (backgroundColor) {\n      const bytes = data.data;\n\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n\n}\n\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n\n}\n\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\n\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\n\nclass TilingPattern {\n  static get MAX_PATTERN_SIZE() {\n    return (0, _util.shadow)(this, \"MAX_PATTERN_SIZE\", 3000);\n  }\n\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n\n    return {\n      scale,\n      size\n    };\n  }\n\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);\n    graphics.clip();\n    graphics.endPath();\n  }\n\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n          current = graphics.current;\n\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n\n    try {\n      pattern.setTransform(domMatrix);\n    } catch (ex) {\n      (0, _util.warn)(`TilingPattern.getPattern: \"${ex?.message}\".`);\n    }\n\n    return pattern;\n  }\n\n}\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 14 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.applyMaskImageData = applyMaskImageData;\n\nvar _util = __w_pdfjs_require__(1);\n\nfunction applyMaskImageData({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height,\n  inverseDecode = false\n}) {\n  const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n\n    if (widthRemainder === 0) {\n      continue;\n    }\n\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n\n  return {\n    srcPos,\n    destPos\n  };\n}\n\n/***/ }),\n/* 15 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 16 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      const action = this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n\n    ah[actionName] = handler;\n  }\n\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = (0, _util.createPromiseCapability)();\n    this.callbackCapabilities[callbackId] = capability;\n\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n\n    return capability.promise;\n  }\n\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n          sourceName = this.sourceName,\n          targetName = this.targetName,\n          comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n\n  _createStreamSink(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const self = this,\n          action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = (0, _util.createPromiseCapability)();\n          this.ready = this.sinkCapability.promise;\n        }\n\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n\n      sinkCapability: (0, _util.createPromiseCapability)(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n\n  _processStreamMessage(data) {\n    const streamId = data.streamId,\n          sourceName = this.sourceName,\n          targetName = data.sourceName,\n          comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n          streamSink = this.streamSinks[streamId];\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull && streamSink.onPull());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.controller.enqueue(data.chunk);\n        break;\n\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n\n        if (streamController.isClosed) {\n          break;\n        }\n\n        streamController.isClosed = true;\n        streamController.controller.close();\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n\n        this._deleteStreamController(streamController, streamId);\n\n        break;\n\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n\n  async _deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);\n    delete this.streamControllers[streamId];\n  }\n\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n}\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 17 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nclass Metadata {\n  #metadataMap;\n  #data;\n\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n\n  getRaw() {\n    return this.#data;\n  }\n\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n\n}\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 18 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nconst INTERNAL = Symbol(\"INTERNAL\");\n\nclass OptionalContentGroup {\n  #visible = true;\n\n  constructor(name, intent) {\n    this.name = name;\n    this.intent = intent;\n  }\n\n  get visible() {\n    return this.#visible;\n  }\n\n  _setVisible(internal, visible) {\n    if (internal !== INTERNAL) {\n      (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n    }\n\n    this.#visible = visible;\n  }\n\n}\n\nclass OptionalContentConfig {\n  #cachedHasInitialVisibility = true;\n  #groups = new Map();\n  #initialVisibility = null;\n  #order = null;\n\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n\n    this.#initialVisibility = new Map();\n\n    for (const [id, group] of this.#groups) {\n      this.#initialVisibility.set(id, group.visible);\n    }\n  }\n\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n\n    if (length < 2) {\n      return true;\n    }\n\n    const operator = array[0];\n\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n\n          break;\n\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n\n          break;\n\n        case \"Not\":\n          return !state;\n\n        default:\n          return true;\n      }\n    }\n\n    return operator === \"And\";\n  }\n\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this.#groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n\n    this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n\n    this.#cachedHasInitialVisibility = null;\n  }\n\n  get hasInitialVisibility() {\n    if (this.#cachedHasInitialVisibility !== null) {\n      return this.#cachedHasInitialVisibility;\n    }\n\n    for (const [id, group] of this.#groups) {\n      const visible = this.#initialVisibility.get(id);\n\n      if (group.visible !== visible) {\n        return this.#cachedHasInitialVisibility = false;\n      }\n    }\n\n    return this.#cachedHasInitialVisibility = true;\n  }\n\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n\n    if (this.#order) {\n      return this.#order.slice();\n    }\n\n    return [...this.#groups.keys()];\n  }\n\n  getGroups() {\n    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n  }\n\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n\n}\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 19 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    this._contentDispositionFilename = params.contentDispositionFilename || null;\n    const initialData = params.initialData;\n\n    if (initialData?.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n\n        rangeReader._enqueue(buffer);\n\n        return true;\n      });\n\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      const firstReader = this._rangeReaders[0];\n\n      if (firstReader?.onProgress) {\n        firstReader.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n\n      if (fullReader?.onProgress) {\n        fullReader.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n    this._rangeReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n\n    this._pdfDataRangeTransport.abort();\n  }\n\n}\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n\n    this._done = true;\n  }\n\n}\n\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n\n      this._requests.length = 0;\n    }\n\n    this._done = true;\n\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._stream._removeRangeReader(this);\n  }\n\n}\n\n/***/ }),\n/* 20 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\n\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n\n      let str = null;\n      const name = node.name;\n\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n\n      if (!node.children) {\n        return;\n      }\n\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n\n    walk(xfa);\n    return output;\n  }\n\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n\n}\n\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 21 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n\nvar _base_factory = __w_pdfjs_require__(9);\n\n;\n\nconst fetchData = function (url) {\n  return new Promise((resolve, reject) => {\n    const fs = __webpack_require__(70172);\n\n    fs.readFile(url, (error, data) => {\n      if (error || !data) {\n        reject(new Error(error));\n        return;\n      }\n\n      resolve(new Uint8Array(data));\n    });\n  });\n};\n\nclass NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const Canvas = __webpack_require__(84663);\n\n    return Canvas.createCanvas(width, height);\n  }\n\n}\n\nexports.NodeCanvasFactory = NodeCanvasFactory;\n\nclass NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n\n}\n\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\nclass NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url);\n  }\n\n}\n\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\n/***/ }),\n/* 22 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditorLayer = void 0;\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _freetext = __w_pdfjs_require__(23);\n\nvar _ink = __w_pdfjs_require__(24);\n\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #boundPointerup = this.pointerup.bind(this);\n  #boundPointerdown = this.pointerdown.bind(this);\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isCleaningUp = false;\n  #uiManager;\n  static _initialized = false;\n\n  constructor(options) {\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n\n      _freetext.FreeTextEditor.initialize(options.l10n);\n\n      _ink.InkEditor.initialize(options.l10n);\n\n      options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);\n    }\n\n    this.#uiManager = options.uiManager;\n    this.annotationStorage = options.annotationStorage;\n    this.pageIndex = options.pageIndex;\n    this.div = options.div;\n    this.#accessibilityManager = options.accessibilityManager;\n    this.#uiManager.addLayer(this);\n  }\n\n  updateToolbar(mode) {\n    this.#uiManager.updateToolbar(mode);\n  }\n\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n\n    if (mode === _util.AnnotationEditorType.INK) {\n      this.addInkEditorIfNeeded(false);\n      this.disableClick();\n    } else {\n      this.enableClick();\n    }\n\n    this.#uiManager.unselectAll();\n  }\n\n  addInkEditorIfNeeded(isCommitting) {\n    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n      return;\n    }\n\n    if (!isCommitting) {\n      for (const editor of this.#editors.values()) {\n        if (editor.isEmpty()) {\n          editor.setInBackground();\n          return;\n        }\n      }\n    }\n\n    const editor = this.#createAndAddNewEditor({\n      offsetX: 0,\n      offsetY: 0\n    });\n    editor.setInBackground();\n  }\n\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n\n  enable() {\n    this.div.style.pointerEvents = \"auto\";\n\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n    }\n  }\n\n  disable() {\n    this.div.style.pointerEvents = \"none\";\n\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n    }\n  }\n\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n\n    if (currentActive === editor) {\n      return;\n    }\n\n    this.#uiManager.setActiveEditor(editor);\n  }\n\n  enableClick() {\n    this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n  }\n\n  disableClick() {\n    this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n  }\n\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n  }\n\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n  }\n\n  remove(editor) {\n    this.#uiManager.removeEditor(editor);\n    this.detach(editor);\n    this.annotationStorage.remove(editor.id);\n    editor.div.style.display = \"none\";\n    setTimeout(() => {\n      editor.div.style.display = \"\";\n      editor.div.remove();\n      editor.isAttachedToDOM = false;\n\n      if (document.activeElement === document.body) {\n        this.#uiManager.focusMainContainer();\n      }\n    }, 0);\n\n    if (!this.#isCleaningUp) {\n      this.addInkEditorIfNeeded(false);\n    }\n  }\n\n  #changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n\n    this.attach(editor);\n    editor.pageIndex = this.pageIndex;\n    editor.parent?.detach(editor);\n    editor.parent = this;\n\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n\n  add(editor) {\n    this.#changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n\n    this.moveEditorInDOM(editor);\n    editor.onceAdded();\n    this.addToAnnotationStorage(editor);\n  }\n\n  moveEditorInDOM(editor) {\n    this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {\n      this.annotationStorage.setValue(editor.id, editor);\n    }\n  }\n\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.rebuild();\n    } else {\n      this.add(editor);\n    }\n  }\n\n  addANewEditor(editor) {\n    const cmd = () => {\n      this.addOrRebuild(editor);\n    };\n\n    const undo = () => {\n      editor.remove();\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  addUndoableEditor(editor) {\n    const cmd = () => {\n      this.addOrRebuild(editor);\n    };\n\n    const undo = () => {\n      editor.remove();\n    };\n\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n\n  #createNewEditor(params) {\n    switch (this.#uiManager.getMode()) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return new _freetext.FreeTextEditor(params);\n\n      case _util.AnnotationEditorType.INK:\n        return new _ink.InkEditor(params);\n    }\n\n    return null;\n  }\n\n  deserialize(data) {\n    switch (data.annotationType) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return _freetext.FreeTextEditor.deserialize(data, this);\n\n      case _util.AnnotationEditorType.INK:\n        return _ink.InkEditor.deserialize(data, this);\n    }\n\n    return null;\n  }\n\n  #createAndAddNewEditor(event) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY\n    });\n\n    if (editor) {\n      this.add(editor);\n    }\n\n    return editor;\n  }\n\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n\n  isSelected(editor) {\n    return this.#uiManager.isSelected(editor);\n  }\n\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n\n  pointerup(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n\n    if (event.target !== this.div) {\n      return;\n    }\n\n    if (!this.#hadPointerDown) {\n      return;\n    }\n\n    this.#hadPointerDown = false;\n\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n\n    this.#createAndAddNewEditor(event);\n  }\n\n  pointerdown(event) {\n    const isMac = _tools.KeyboardManager.platform.isMac;\n\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n\n    if (event.target !== this.div) {\n      return;\n    }\n\n    this.#hadPointerDown = true;\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n\n  drop(event) {\n    const id = event.dataTransfer.getData(\"text/plain\");\n    const editor = this.#uiManager.getEditor(id);\n\n    if (!editor) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n    this.#changeParent(editor);\n    const rect = this.div.getBoundingClientRect();\n    const endX = event.clientX - rect.x;\n    const endY = event.clientY - rect.y;\n    editor.translate(endX - editor.startX, endY - editor.startY);\n    this.moveEditorInDOM(editor);\n    editor.div.focus();\n  }\n\n  dragover(event) {\n    event.preventDefault();\n  }\n\n  destroy() {\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.setActiveEditor(null);\n    }\n\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n      editor.parent = null;\n    }\n\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n\n  #cleanup() {\n    this.#isCleaningUp = true;\n\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n\n    this.#isCleaningUp = false;\n  }\n\n  render(parameters) {\n    this.viewport = parameters.viewport;\n    (0, _tools.bindEvents)(this, this.div, [\"dragover\", \"drop\"]);\n    this.setDimensions();\n\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n    }\n\n    this.updateMode();\n  }\n\n  update(parameters) {\n    this.viewport = parameters.viewport;\n    this.setDimensions();\n    this.updateMode();\n  }\n\n  get scaleFactor() {\n    return this.viewport.scale;\n  }\n\n  get pageDimensions() {\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const width = pageURx - pageLLx;\n    const height = pageURy - pageLLy;\n    return [width, height];\n  }\n\n  get viewportBaseDimensions() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.viewport;\n    return rotation % 180 === 0 ? [width, height] : [height, width];\n  }\n\n  setDimensions() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.viewport;\n    const flipOrientation = rotation % 180 !== 0,\n          widthStr = Math.floor(width) + \"px\",\n          heightStr = Math.floor(height) + \"px\";\n    this.div.style.width = flipOrientation ? heightStr : widthStr;\n    this.div.style.height = flipOrientation ? widthStr : heightStr;\n    this.div.setAttribute(\"data-main-rotation\", rotation);\n  }\n\n}\n\nexports.AnnotationEditorLayer = AnnotationEditorLayer;\n\n/***/ }),\n/* 23 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FreeTextEditor = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _editor = __w_pdfjs_require__(6);\n\nclass FreeTextEditor extends _editor.AnnotationEditor {\n  #boundEditorDivBlur = this.editorDivBlur.bind(this);\n  #boundEditorDivFocus = this.editorDivFocus.bind(this);\n  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n  #color;\n  #content = \"\";\n  #hasAlreadyBeenCommitted = false;\n  #fontSize;\n  static _freeTextDefaultContent = \"\";\n  static _l10nPromise;\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static _keyboardManager = new _tools.KeyboardManager([[[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], FreeTextEditor.prototype.commitOrRemove]]);\n  static _type = \"freetext\";\n\n  constructor(params) {\n    super({ ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n  }\n\n  static initialize(l10n) {\n    this._l10nPromise = new Map([\"free_text_default_content\", \"editor_free_text_aria_label\"].map(str => [str, l10n.get(str)]));\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];\n  }\n\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parent.scaleFactor);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n\n    const savedFontsize = this.#fontSize;\n    this.parent.addCommands({\n      cmd: () => {\n        setFontsize(fontSize);\n      },\n      undo: () => {\n        setFontsize(savedFontsize);\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateColor(color) {\n    const savedColor = this.#color;\n    this.parent.addCommands({\n      cmd: () => {\n        this.#color = color;\n        this.editorDiv.style.color = color;\n      },\n      undo: () => {\n        this.#color = savedColor;\n        this.editorDiv.style.color = savedColor;\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  getInitialTranslation() {\n    return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + this.#fontSize) * this.parent.scaleFactor];\n  }\n\n  rebuild() {\n    super.rebuild();\n\n    if (this.div === null) {\n      return;\n    }\n\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return;\n    }\n\n    this.parent.setEditingState(false);\n    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n    super.enableEditMode();\n    this.enableEditing();\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this.div.draggable = false;\n    this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n  }\n\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n\n    this.parent.setEditingState(true);\n    super.disableEditMode();\n    this.disableEditing();\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.draggable = true;\n    this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.div.focus();\n    this.isEditing = false;\n  }\n\n  focusin(event) {\n    super.focusin(event);\n\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n\n  onceAdded() {\n    if (this.width) {\n      return;\n    }\n\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n\n  remove() {\n    this.isEditing = false;\n    this.parent.setEditingState(true);\n    super.remove();\n  }\n\n  #extractText() {\n    const divs = this.editorDiv.getElementsByTagName(\"div\");\n\n    if (divs.length === 0) {\n      return this.editorDiv.innerText;\n    }\n\n    const buffer = [];\n\n    for (let i = 0, ii = divs.length; i < ii; i++) {\n      const div = divs[i];\n      const first = div.firstChild;\n\n      if (first?.nodeName === \"#text\") {\n        buffer.push(first.data);\n      } else {\n        buffer.push(\"\");\n      }\n    }\n\n    return buffer.join(\"\\n\");\n  }\n\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    const rect = this.div.getBoundingClientRect();\n    this.width = rect.width / parentWidth;\n    this.height = rect.height / parentHeight;\n  }\n\n  commit() {\n    super.commit();\n\n    if (!this.#hasAlreadyBeenCommitted) {\n      this.#hasAlreadyBeenCommitted = true;\n      this.parent.addUndoableEditor(this);\n    }\n\n    this.disableEditMode();\n    this.#content = this.#extractText().trimEnd();\n    this.#setEditorDimensions();\n  }\n\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n\n  dblclick(event) {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enableEditMode();\n      this.editorDiv.focus();\n    }\n  }\n\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n\n    let baseX, baseY;\n\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", `${this.id}-editor`);\n    this.enableEditing();\n\n    FreeTextEditor._l10nPromise.get(\"editor_free_text_aria_label\").then(msg => this.editorDiv?.setAttribute(\"aria-label\", msg));\n\n    FreeTextEditor._l10nPromise.get(\"free_text_default_content\").then(msg => this.editorDiv?.setAttribute(\"default-content\", msg));\n\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]);\n\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n\n      for (const line of this.#content.split(\"\\n\")) {\n        const div = document.createElement(\"div\");\n        div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n        this.editorDiv.append(div);\n      }\n\n      this.div.draggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this.div.draggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n\n    return this.div;\n  }\n\n  get contentDiv() {\n    return this.editorDiv;\n  }\n\n  static deserialize(data, parent) {\n    const editor = super.deserialize(data, parent);\n    editor.#fontSize = data.fontSize;\n    editor.#color = _util.Util.makeHexColor(...data.color);\n    editor.#content = data.value;\n    return editor;\n  }\n\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor;\n    const rect = this.getRect(padding, padding);\n\n    const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);\n\n    return {\n      annotationType: _util.AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#content,\n      pageIndex: this.parent.pageIndex,\n      rect,\n      rotation: this.rotation\n    };\n  }\n\n}\n\nexports.FreeTextEditor = FreeTextEditor;\n\n/***/ }),\n/* 24 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.InkEditor = void 0;\nObject.defineProperty(exports, \"fitCurve\", ({\n  enumerable: true,\n  get: function () {\n    return _pdfjsFitCurve.fitCurve;\n  }\n}));\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _editor = __w_pdfjs_require__(6);\n\nvar _pdfjsFitCurve = __w_pdfjs_require__(25);\n\nvar _tools = __w_pdfjs_require__(7);\n\nconst RESIZER_SIZE = 16;\n\nclass InkEditor extends _editor.AnnotationEditor {\n  #aspectRatio = 0;\n  #baseHeight = 0;\n  #baseWidth = 0;\n  #boundCanvasPointermove = this.canvasPointermove.bind(this);\n  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n  #boundCanvasPointerup = this.canvasPointerup.bind(this);\n  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n  #disableEditing = false;\n  #isCanvasInitialized = false;\n  #lastPoint = null;\n  #observer = null;\n  #realWidth = 0;\n  #realHeight = 0;\n  #requestFrameCallback = null;\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 1;\n  static _l10nPromise;\n  static _type = \"ink\";\n\n  constructor(params) {\n    super({ ...params,\n      name: \"inkEditor\"\n    });\n    this.color = params.color || null;\n    this.thickness = params.thickness || null;\n    this.opacity = params.opacity || null;\n    this.paths = [];\n    this.bezierPath2D = [];\n    this.currentPath = [];\n    this.scaleFactor = 1;\n    this.translationX = this.translationY = 0;\n    this.x = 0;\n    this.y = 0;\n  }\n\n  static initialize(l10n) {\n    this._l10nPromise = new Map([\"editor_ink_canvas_aria_label\", \"editor_ink_aria_label\"].map(str => [str, l10n.get(str)]));\n  }\n\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        InkEditor._defaultThickness = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        InkEditor._defaultColor = value;\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        InkEditor._defaultOpacity = value / 100;\n        break;\n    }\n  }\n\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        this.#updateThickness(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        this.#updateColor(value);\n        break;\n\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        this.#updateOpacity(value);\n        break;\n    }\n  }\n\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n  }\n\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];\n  }\n\n  #updateThickness(thickness) {\n    const savedThickness = this.thickness;\n    this.parent.addCommands({\n      cmd: () => {\n        this.thickness = thickness;\n        this.#fitToContent();\n      },\n      undo: () => {\n        this.thickness = savedThickness;\n        this.#fitToContent();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateColor(color) {\n    const savedColor = this.color;\n    this.parent.addCommands({\n      cmd: () => {\n        this.color = color;\n        this.#redraw();\n      },\n      undo: () => {\n        this.color = savedColor;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  #updateOpacity(opacity) {\n    opacity /= 100;\n    const savedOpacity = this.opacity;\n    this.parent.addCommands({\n      cmd: () => {\n        this.opacity = opacity;\n        this.#redraw();\n      },\n      undo: () => {\n        this.opacity = savedOpacity;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_OPACITY,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n\n  rebuild() {\n    super.rebuild();\n\n    if (this.div === null) {\n      return;\n    }\n\n    if (!this.canvas) {\n      this.#createCanvas();\n      this.#createObserver();\n    }\n\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n      this.#setCanvasDims();\n    }\n\n    this.#fitToContent();\n  }\n\n  remove() {\n    if (this.canvas === null) {\n      return;\n    }\n\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.remove();\n    this.canvas = null;\n    this.#observer.disconnect();\n    this.#observer = null;\n    super.remove();\n  }\n\n  enableEditMode() {\n    if (this.#disableEditing || this.canvas === null) {\n      return;\n    }\n\n    super.enableEditMode();\n    this.div.draggable = false;\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n  }\n\n  disableEditMode() {\n    if (!this.isInEditMode() || this.canvas === null) {\n      return;\n    }\n\n    super.disableEditMode();\n    this.div.draggable = !this.isEmpty();\n    this.div.classList.remove(\"editing\");\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n  }\n\n  onceAdded() {\n    this.div.draggable = !this.isEmpty();\n  }\n\n  isEmpty() {\n    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n  }\n\n  #getInitialBBox() {\n    const {\n      width,\n      height,\n      rotation\n    } = this.parent.viewport;\n\n    switch (rotation) {\n      case 90:\n        return [0, width, width, height];\n\n      case 180:\n        return [width, height, width, height];\n\n      case 270:\n        return [height, 0, width, height];\n\n      default:\n        return [0, 0, width, height];\n    }\n  }\n\n  #setStroke() {\n    this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;\n    this.ctx.lineCap = \"round\";\n    this.ctx.lineJoin = \"round\";\n    this.ctx.miterLimit = 10;\n    this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;\n  }\n\n  #startDrawing(x, y) {\n    this.isEditing = true;\n\n    if (!this.#isCanvasInitialized) {\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.thickness ||= InkEditor._defaultThickness;\n      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n      this.opacity ??= InkEditor._defaultOpacity;\n    }\n\n    this.currentPath.push([x, y]);\n    this.#lastPoint = null;\n    this.#setStroke();\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, y);\n\n    this.#requestFrameCallback = () => {\n      if (!this.#requestFrameCallback) {\n        return;\n      }\n\n      if (this.#lastPoint) {\n        if (this.isEmpty()) {\n          this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        } else {\n          this.#redraw();\n        }\n\n        this.ctx.lineTo(...this.#lastPoint);\n        this.#lastPoint = null;\n        this.ctx.stroke();\n      }\n\n      window.requestAnimationFrame(this.#requestFrameCallback);\n    };\n\n    window.requestAnimationFrame(this.#requestFrameCallback);\n  }\n\n  #draw(x, y) {\n    const [lastX, lastY] = this.currentPath.at(-1);\n\n    if (x === lastX && y === lastY) {\n      return;\n    }\n\n    this.currentPath.push([x, y]);\n    this.#lastPoint = [x, y];\n  }\n\n  #stopDrawing(x, y) {\n    this.ctx.closePath();\n    this.#requestFrameCallback = null;\n    x = Math.min(Math.max(x, 0), this.canvas.width);\n    y = Math.min(Math.max(y, 0), this.canvas.height);\n    const [lastX, lastY] = this.currentPath.at(-1);\n\n    if (x !== lastX || y !== lastY) {\n      this.currentPath.push([x, y]);\n    }\n\n    let bezier;\n\n    if (this.currentPath.length !== 1) {\n      bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);\n    } else {\n      const xy = [x, y];\n      bezier = [[xy, xy.slice(), xy.slice(), xy]];\n    }\n\n    const path2D = InkEditor.#buildPath2D(bezier);\n    this.currentPath.length = 0;\n\n    const cmd = () => {\n      this.paths.push(bezier);\n      this.bezierPath2D.push(path2D);\n      this.rebuild();\n    };\n\n    const undo = () => {\n      this.paths.pop();\n      this.bezierPath2D.pop();\n\n      if (this.paths.length === 0) {\n        this.remove();\n      } else {\n        if (!this.canvas) {\n          this.#createCanvas();\n          this.#createObserver();\n        }\n\n        this.#fitToContent();\n      }\n    };\n\n    this.parent.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n\n  #redraw() {\n    if (this.isEmpty()) {\n      this.#updateTransform();\n      return;\n    }\n\n    this.#setStroke();\n    const {\n      canvas,\n      ctx\n    } = this;\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    this.#updateTransform();\n\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n  }\n\n  commit() {\n    if (this.#disableEditing) {\n      return;\n    }\n\n    super.commit();\n    this.isEditing = false;\n    this.disableEditMode();\n    this.setInForeground();\n    this.#disableEditing = true;\n    this.div.classList.add(\"disabled\");\n    this.#fitToContent(true);\n    this.parent.addInkEditorIfNeeded(true);\n    this.parent.moveEditorInDOM(this);\n    this.div.focus();\n  }\n\n  focusin(event) {\n    super.focusin(event);\n    this.enableEditMode();\n  }\n\n  canvasPointerdown(event) {\n    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n      return;\n    }\n\n    this.setInForeground();\n\n    if (event.type !== \"mouse\") {\n      this.div.focus();\n    }\n\n    event.stopPropagation();\n    this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.#startDrawing(event.offsetX, event.offsetY);\n  }\n\n  canvasPointermove(event) {\n    event.stopPropagation();\n    this.#draw(event.offsetX, event.offsetY);\n  }\n\n  canvasPointerup(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    if (this.isInEditMode() && this.currentPath.length !== 0) {\n      event.stopPropagation();\n      this.#endDrawing(event);\n      this.setInBackground();\n    }\n  }\n\n  canvasPointerleave(event) {\n    this.#endDrawing(event);\n    this.setInBackground();\n  }\n\n  #endDrawing(event) {\n    this.#stopDrawing(event.offsetX, event.offsetY);\n    this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.parent.addToAnnotationStorage(this);\n  }\n\n  #createCanvas() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.className = \"inkEditorCanvas\";\n\n    InkEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(msg => this.canvas?.setAttribute(\"aria-label\", msg));\n\n    this.div.append(this.canvas);\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n\n      if (rect.width && rect.height) {\n        this.setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n\n    let baseX, baseY;\n\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n\n    super.render();\n\n    InkEditor._l10nPromise.get(\"editor_ink_aria_label\").then(msg => this.div?.setAttribute(\"aria-label\", msg));\n\n    const [x, y, w, h] = this.#getInitialBBox();\n    this.setAt(x, y, 0, 0);\n    this.setDims(w, h);\n    this.#createCanvas();\n\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n      this.#redraw();\n      this.#setMinDims();\n      this.div.classList.add(\"disabled\");\n    } else {\n      this.div.classList.add(\"editing\");\n      this.enableEditMode();\n    }\n\n    this.#createObserver();\n    return this.div;\n  }\n\n  #setCanvasDims() {\n    if (!this.#isCanvasInitialized) {\n      return;\n    }\n\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.canvas.width = Math.ceil(this.width * parentWidth);\n    this.canvas.height = Math.ceil(this.height * parentHeight);\n    this.#updateTransform();\n  }\n\n  setDimensions(width, height) {\n    const roundedWidth = Math.round(width);\n    const roundedHeight = Math.round(height);\n\n    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n      return;\n    }\n\n    this.#realWidth = roundedWidth;\n    this.#realHeight = roundedHeight;\n    this.canvas.style.visibility = \"hidden\";\n\n    if (this.#aspectRatio && Math.abs(this.#aspectRatio - width / height) > 1e-2) {\n      height = Math.ceil(width / this.#aspectRatio);\n      this.setDims(width, height);\n    }\n\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n\n    if (this.#disableEditing) {\n      this.#setScaleFactor(width, height);\n    }\n\n    this.#setCanvasDims();\n    this.#redraw();\n    this.canvas.style.visibility = \"visible\";\n  }\n\n  #setScaleFactor(width, height) {\n    const padding = this.#getPadding();\n    const scaleFactorW = (width - padding) / this.#baseWidth;\n    const scaleFactorH = (height - padding) / this.#baseHeight;\n    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n  }\n\n  #updateTransform() {\n    const padding = this.#getPadding() / 2;\n    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n  }\n\n  static #buildPath2D(bezier) {\n    const path2D = new Path2D();\n\n    for (let i = 0, ii = bezier.length; i < ii; i++) {\n      const [first, control1, control2, second] = bezier[i];\n\n      if (i === 0) {\n        path2D.moveTo(...first);\n      }\n\n      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n    }\n\n    return path2D;\n  }\n\n  #serializePaths(s, tx, ty, h) {\n    const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;\n    const paths = [];\n    const padding = this.thickness / 2;\n    let buffer, points;\n\n    for (const bezier of this.paths) {\n      buffer = [];\n      points = [];\n\n      for (let i = 0, ii = bezier.length; i < ii; i++) {\n        const [first, control1, control2, second] = bezier[i];\n        const p10 = s * (first[0] + tx) + padding;\n        const p11 = h - s * (first[1] + ty) - padding;\n        const p20 = s * (control1[0] + tx) + padding;\n        const p21 = h - s * (control1[1] + ty) - padding;\n        const p30 = s * (control2[0] + tx) + padding;\n        const p31 = h - s * (control2[1] + ty) - padding;\n        const p40 = s * (second[0] + tx) + padding;\n        const p41 = h - s * (second[1] + ty) - padding;\n\n        if (i === 0) {\n          buffer.push(p10, p11);\n          points.push(p10, p11);\n        }\n\n        buffer.push(p20, p21, p30, p31, p40, p41);\n        this.#extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);\n      }\n\n      paths.push({\n        bezier: buffer,\n        points\n      });\n    }\n\n    return paths;\n  }\n\n  #extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {\n    if (this.#isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41)) {\n      points.push(p40, p41);\n      return;\n    }\n\n    for (let i = 1; i < n - 1; i++) {\n      const t = i / n;\n      const mt = 1 - t;\n      let q10 = t * p10 + mt * p20;\n      let q11 = t * p11 + mt * p21;\n      let q20 = t * p20 + mt * p30;\n      let q21 = t * p21 + mt * p31;\n      const q30 = t * p30 + mt * p40;\n      const q31 = t * p31 + mt * p41;\n      q10 = t * q10 + mt * q20;\n      q11 = t * q11 + mt * q21;\n      q20 = t * q20 + mt * q30;\n      q21 = t * q21 + mt * q31;\n      q10 = t * q10 + mt * q20;\n      q11 = t * q11 + mt * q21;\n      points.push(q10, q11);\n    }\n\n    points.push(p40, p41);\n  }\n\n  #isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41) {\n    const tol = 10;\n    const ax = (3 * p20 - 2 * p10 - p40) ** 2;\n    const ay = (3 * p21 - 2 * p11 - p41) ** 2;\n    const bx = (3 * p30 - p10 - 2 * p40) ** 2;\n    const by = (3 * p31 - p11 - 2 * p41) ** 2;\n    return Math.max(ax, bx) + Math.max(ay, by) <= tol;\n  }\n\n  #getBbox() {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n\n    for (const path of this.paths) {\n      for (const [first, control1, control2, second] of path) {\n        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n\n        xMin = Math.min(xMin, bbox[0]);\n        yMin = Math.min(yMin, bbox[1]);\n        xMax = Math.max(xMax, bbox[2]);\n        yMax = Math.max(yMax, bbox[3]);\n      }\n    }\n\n    return [xMin, yMin, xMax, yMax];\n  }\n\n  #getPadding() {\n    return this.#disableEditing ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;\n  }\n\n  #fitToContent(firstTime = false) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    if (!this.#disableEditing) {\n      this.#redraw();\n      return;\n    }\n\n    const bbox = this.#getBbox();\n    const padding = this.#getPadding();\n    this.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);\n    this.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);\n    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.#aspectRatio = width / height;\n    this.#setMinDims();\n    const prevTranslationX = this.translationX;\n    const prevTranslationY = this.translationY;\n    this.translationX = -bbox[0];\n    this.translationY = -bbox[1];\n    this.#setCanvasDims();\n    this.#redraw();\n    this.#realWidth = width;\n    this.#realHeight = height;\n    this.setDims(width, height);\n    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n  }\n\n  #setMinDims() {\n    const {\n      style\n    } = this.div;\n\n    if (this.#aspectRatio >= 1) {\n      style.minHeight = `${RESIZER_SIZE}px`;\n      style.minWidth = `${Math.round(this.#aspectRatio * RESIZER_SIZE)}px`;\n    } else {\n      style.minWidth = `${RESIZER_SIZE}px`;\n      style.minHeight = `${Math.round(RESIZER_SIZE / this.#aspectRatio)}px`;\n    }\n  }\n\n  static deserialize(data, parent) {\n    const editor = super.deserialize(data, parent);\n    editor.thickness = data.thickness;\n    editor.color = _util.Util.makeHexColor(...data.color);\n    editor.opacity = data.opacity;\n    const [pageWidth, pageHeight] = parent.pageDimensions;\n    const width = editor.width * pageWidth;\n    const height = editor.height * pageHeight;\n    const scaleFactor = parent.scaleFactor;\n    const padding = data.thickness / 2;\n    editor.#aspectRatio = width / height;\n    editor.#disableEditing = true;\n    editor.#realWidth = Math.round(width);\n    editor.#realHeight = Math.round(height);\n\n    for (const {\n      bezier\n    } of data.paths) {\n      const path = [];\n      editor.paths.push(path);\n      let p0 = scaleFactor * (bezier[0] - padding);\n      let p1 = scaleFactor * (height - bezier[1] - padding);\n\n      for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n        const p10 = scaleFactor * (bezier[i] - padding);\n        const p11 = scaleFactor * (height - bezier[i + 1] - padding);\n        const p20 = scaleFactor * (bezier[i + 2] - padding);\n        const p21 = scaleFactor * (height - bezier[i + 3] - padding);\n        const p30 = scaleFactor * (bezier[i + 4] - padding);\n        const p31 = scaleFactor * (height - bezier[i + 5] - padding);\n        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n        p0 = p30;\n        p1 = p31;\n      }\n\n      const path2D = this.#buildPath2D(path);\n      editor.bezierPath2D.push(path2D);\n    }\n\n    const bbox = editor.#getBbox();\n    editor.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);\n    editor.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);\n    editor.#setScaleFactor(width, height);\n    return editor;\n  }\n\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const rect = this.getRect(0, 0);\n    const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];\n\n    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n\n    return {\n      annotationType: _util.AnnotationEditorType.INK,\n      color,\n      thickness: this.thickness,\n      opacity: this.opacity,\n      paths: this.#serializePaths(this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),\n      pageIndex: this.parent.pageIndex,\n      rect,\n      rotation: this.rotation\n    };\n  }\n\n}\n\nexports.InkEditor = InkEditor;\n\n/***/ }),\n/* 25 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fitCurve = void 0;\n\nconst fitCurve = __w_pdfjs_require__(26);\n\nexports.fitCurve = fitCurve;\n\n/***/ }),\n/* 26 */\n/***/ ((module) => {\n\n\n\nfunction fitCurve(points, maxError, progressCallback) {\n  if (!Array.isArray(points)) {\n    throw new TypeError(\"First argument should be an array\");\n  }\n\n  points.forEach(point => {\n    if (!Array.isArray(point) || point.some(item => typeof item !== 'number') || point.length !== points[0].length) {\n      throw Error(\"Each point should be an array of numbers. Each point should have the same amount of numbers.\");\n    }\n  });\n  points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));\n\n  if (points.length < 2) {\n    return [];\n  }\n\n  const len = points.length;\n  const leftTangent = createTangent(points[1], points[0]);\n  const rightTangent = createTangent(points[len - 2], points[len - 1]);\n  return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);\n}\n\nfunction fitCubic(points, leftTangent, rightTangent, error, progressCallback) {\n  const MaxIterations = 20;\n  var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;\n\n  if (points.length === 2) {\n    dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;\n    bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];\n    return [bezCurve];\n  }\n\n  u = chordLengthParameterize(points);\n  [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);\n\n  if (maxError === 0 || maxError < error) {\n    return [bezCurve];\n  }\n\n  if (maxError < error * error) {\n    uPrime = u;\n    prevErr = maxError;\n    prevSplit = splitPoint;\n\n    for (i = 0; i < MaxIterations; i++) {\n      uPrime = reparameterize(bezCurve, points, uPrime);\n      [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);\n\n      if (maxError < error) {\n        return [bezCurve];\n      } else if (splitPoint === prevSplit) {\n        let errChange = maxError / prevErr;\n\n        if (errChange > .9999 && errChange < 1.0001) {\n          break;\n        }\n      }\n\n      prevErr = maxError;\n      prevSplit = splitPoint;\n    }\n  }\n\n  beziers = [];\n  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);\n\n  if (centerVector.every(val => val === 0)) {\n    centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);\n    [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];\n  }\n\n  toCenterTangent = maths.normalize(centerVector);\n  fromCenterTangent = maths.mulItems(toCenterTangent, -1);\n  beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));\n  beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));\n  return beziers;\n}\n\n;\n\nfunction generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {\n  var bezCurve, maxError, splitPoint;\n  bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);\n  [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);\n\n  if (progressCallback) {\n    progressCallback({\n      bez: bezCurve,\n      points: points,\n      params: paramsOrig,\n      maxErr: maxError,\n      maxPoint: splitPoint\n    });\n  }\n\n  return [bezCurve, maxError, splitPoint];\n}\n\nfunction generateBezier(points, parameters, leftTangent, rightTangent) {\n  var bezCurve,\n      A,\n      a,\n      C,\n      X,\n      det_C0_C1,\n      det_C0_X,\n      det_X_C1,\n      alpha_l,\n      alpha_r,\n      epsilon,\n      segLength,\n      i,\n      len,\n      tmp,\n      u,\n      ux,\n      firstPoint = points[0],\n      lastPoint = points[points.length - 1];\n  bezCurve = [firstPoint, null, null, lastPoint];\n  A = maths.zeros_Xx2x2(parameters.length);\n\n  for (i = 0, len = parameters.length; i < len; i++) {\n    u = parameters[i];\n    ux = 1 - u;\n    a = A[i];\n    a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));\n    a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));\n  }\n\n  C = [[0, 0], [0, 0]];\n  X = [0, 0];\n\n  for (i = 0, len = points.length; i < len; i++) {\n    u = parameters[i];\n    a = A[i];\n    C[0][0] += maths.dot(a[0], a[0]);\n    C[0][1] += maths.dot(a[0], a[1]);\n    C[1][0] += maths.dot(a[0], a[1]);\n    C[1][1] += maths.dot(a[1], a[1]);\n    tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));\n    X[0] += maths.dot(a[0], tmp);\n    X[1] += maths.dot(a[1], tmp);\n  }\n\n  det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n  det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];\n  det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];\n  alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;\n  alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;\n  segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));\n  epsilon = 1.0e-6 * segLength;\n\n  if (alpha_l < epsilon || alpha_r < epsilon) {\n    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));\n    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));\n  } else {\n    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));\n    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));\n  }\n\n  return bezCurve;\n}\n\n;\n\nfunction reparameterize(bezier, points, parameters) {\n  return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p));\n}\n\n;\n\nfunction newtonRaphsonRootFind(bez, point, u) {\n  var d = maths.subtract(bezier.q(bez, u), point),\n      qprime = bezier.qprime(bez, u),\n      numerator = maths.mulMatrix(d, qprime),\n      denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));\n\n  if (denominator === 0) {\n    return u;\n  } else {\n    return u - numerator / denominator;\n  }\n}\n\n;\n\nfunction chordLengthParameterize(points) {\n  var u = [],\n      currU,\n      prevU,\n      prevP;\n  points.forEach((p, i) => {\n    currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;\n    u.push(currU);\n    prevU = currU;\n    prevP = p;\n  });\n  u = u.map(x => x / prevU);\n  return u;\n}\n\n;\n\nfunction computeMaxError(points, bez, parameters) {\n  var dist, maxDist, splitPoint, v, i, count, point, t;\n  maxDist = 0;\n  splitPoint = Math.floor(points.length / 2);\n  const t_distMap = mapTtoRelativeDistances(bez, 10);\n\n  for (i = 0, count = points.length; i < count; i++) {\n    point = points[i];\n    t = find_t(bez, parameters[i], t_distMap, 10);\n    v = maths.subtract(bezier.q(bez, t), point);\n    dist = v[0] * v[0] + v[1] * v[1];\n\n    if (dist > maxDist) {\n      maxDist = dist;\n      splitPoint = i;\n    }\n  }\n\n  return [maxDist, splitPoint];\n}\n\n;\n\nvar mapTtoRelativeDistances = function (bez, B_parts) {\n  var B_t_curr;\n  var B_t_dist = [0];\n  var B_t_prev = bez[0];\n  var sumLen = 0;\n\n  for (var i = 1; i <= B_parts; i++) {\n    B_t_curr = bezier.q(bez, i / B_parts);\n    sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));\n    B_t_dist.push(sumLen);\n    B_t_prev = B_t_curr;\n  }\n\n  B_t_dist = B_t_dist.map(x => x / sumLen);\n  return B_t_dist;\n};\n\nfunction find_t(bez, param, t_distMap, B_parts) {\n  if (param < 0) {\n    return 0;\n  }\n\n  if (param > 1) {\n    return 1;\n  }\n\n  var lenMax, lenMin, tMax, tMin, t;\n\n  for (var i = 1; i <= B_parts; i++) {\n    if (param <= t_distMap[i]) {\n      tMin = (i - 1) / B_parts;\n      tMax = i / B_parts;\n      lenMin = t_distMap[i - 1];\n      lenMax = t_distMap[i];\n      t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;\n      break;\n    }\n  }\n\n  return t;\n}\n\nfunction createTangent(pointA, pointB) {\n  return maths.normalize(maths.subtract(pointA, pointB));\n}\n\nclass maths {\n  static zeros_Xx2x2(x) {\n    var zs = [];\n\n    while (x--) {\n      zs.push([0, 0]);\n    }\n\n    return zs;\n  }\n\n  static mulItems(items, multiplier) {\n    return items.map(x => x * multiplier);\n  }\n\n  static mulMatrix(m1, m2) {\n    return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);\n  }\n\n  static subtract(arr1, arr2) {\n    return arr1.map((x1, i) => x1 - arr2[i]);\n  }\n\n  static addArrays(arr1, arr2) {\n    return arr1.map((x1, i) => x1 + arr2[i]);\n  }\n\n  static addItems(items, addition) {\n    return items.map(x => x + addition);\n  }\n\n  static sum(items) {\n    return items.reduce((sum, x) => sum + x);\n  }\n\n  static dot(m1, m2) {\n    return maths.mulMatrix(m1, m2);\n  }\n\n  static vectorLen(v) {\n    return Math.hypot(...v);\n  }\n\n  static divItems(items, divisor) {\n    return items.map(x => x / divisor);\n  }\n\n  static squareItems(items) {\n    return items.map(x => x * x);\n  }\n\n  static normalize(v) {\n    return this.divItems(v, this.vectorLen(v));\n  }\n\n}\n\nclass bezier {\n  static q(ctrlPoly, t) {\n    var tx = 1.0 - t;\n    var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),\n        pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),\n        pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),\n        pD = maths.mulItems(ctrlPoly[3], t * t * t);\n    return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));\n  }\n\n  static qprime(ctrlPoly, t) {\n    var tx = 1.0 - t;\n    var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),\n        pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),\n        pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);\n    return maths.addArrays(maths.addArrays(pA, pB), pC);\n  }\n\n  static qprimeprime(ctrlPoly, t) {\n    return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));\n  }\n\n}\n\nmodule.exports = fitCurve;\nmodule.exports.fitCubic = fitCubic;\nmodule.exports.createTangent = createTangent;\n\n/***/ }),\n/* 27 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationLayer = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _annotation_storage = __w_pdfjs_require__(5);\n\nvar _scripting_utils = __w_pdfjs_require__(28);\n\nvar _xfa_layer = __w_pdfjs_require__(29);\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\n\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\n\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n\n            return new PushButtonWidgetAnnotationElement(parameters);\n\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n\n        return new WidgetAnnotationElement(parameters);\n\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n\n}\n\nclass AnnotationElement {\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n    const container = document.createElement(\"section\");\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    container.setAttribute(\"data-annotation-id\", data.id);\n\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n\n        default:\n          break;\n      }\n\n      const borderColor = data.borderColor || null;\n\n      if (borderColor) {\n        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;\n    container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n\n    if (data.hasOwnCanvas || rotation === 0) {\n      container.style.width = `${100 * width / pageWidth}%`;\n      container.style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n\n    return container;\n  }\n\n  setRotation(angle, container = this.container) {\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    const {\n      width,\n      height\n    } = getRectDims(this.data.rect);\n    let elementWidth, elementHeight;\n\n    if (angle % 180 === 0) {\n      elementWidth = 100 * width / pageWidth;\n      elementHeight = 100 * height / pageHeight;\n    } else {\n      elementWidth = 100 * height / pageWidth;\n      elementHeight = 100 * width / pageHeight;\n    }\n\n    container.style.width = `${elementWidth}%`;\n    container.style.height = `${elementHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n    };\n\n    return (0, _util.shadow)(this, \"_commonActions\", {\n      display: event => {\n        const hidden = event.detail.display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden,\n          print: event.detail.display === 0 || event.detail.display === 3\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          print: event.detail.print\n        });\n      },\n      hidden: event => {\n        this.container.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden: event.detail.hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        if (event.detail.readonly) {\n          event.target.setAttribute(\"readonly\", \"\");\n        } else {\n          event.target.removeAttribute(\"readonly\");\n        }\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n\n      if (action) {\n        action(jsEvent);\n      }\n    }\n  }\n\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n\n    if (!storedData) {\n      return;\n    }\n\n    const commonActions = this._commonActions;\n\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n\n  _createQuadrilaterals(ignoreBorder = false) {\n    if (!this.data.quadPoints) {\n      return null;\n    }\n\n    const quadrilaterals = [];\n    const savedRect = this.data.rect;\n\n    for (const quadPoint of this.data.quadPoints) {\n      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n      quadrilaterals.push(this._createContainer(ignoreBorder));\n    }\n\n    this.data.rect = savedRect;\n    return quadrilaterals;\n  }\n\n  _createPopup(trigger, data) {\n    let container = this.container;\n\n    if (this.quadrilaterals) {\n      trigger = trigger || this.quadrilaterals;\n      container = this.quadrilaterals[0];\n    }\n\n    if (!trigger) {\n      trigger = document.createElement(\"div\");\n      trigger.className = \"popupTriggerArea\";\n      container.append(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      titleObj: data.titleObj,\n      modificationDate: data.modificationDate,\n      contentsObj: data.contentsObj,\n      richText: data.richText,\n      hideWrapper: true\n    });\n    const popup = popupElement.render();\n    popup.style.left = \"100%\";\n    container.append(popup);\n  }\n\n  _renderQuadrilaterals(className) {\n    for (const quadrilateral of this.quadrilaterals) {\n      quadrilateral.className = className;\n    }\n\n    return this.quadrilaterals;\n  }\n\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n\n          if (id === skipId) {\n            continue;\n          }\n\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n\n      return fields;\n    }\n\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        id,\n        exportValue\n      } = domElement;\n\n      if (id === skipId) {\n        continue;\n      }\n\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n\n    return fields;\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n    return (0, _util.shadow)(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\")\n    });\n  }\n\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n\n        isBound = true;\n      }\n\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n\n        isBound = true;\n      }\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n        const linkElement = index === 0 ? link : link.cloneNode();\n        quadrilateral.append(linkElement);\n        return quadrilateral;\n      });\n    }\n\n    this.container.className = \"linkAnnotation\";\n\n    if (isBound) {\n      this.container.append(link);\n    }\n\n    return this.container;\n  }\n\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n\n      return false;\n    };\n\n    if (destination || destination === \"\") {\n      link.className = \"internalLink\";\n    }\n  }\n\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n\n    link.className = \"internalLink\";\n  }\n\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n\n      if (!jsName) {\n        continue;\n      }\n\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n\n    link.className = \"internalLink\";\n  }\n\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n\n    link.className = \"internalLink\";\n\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n\n      return;\n    }\n\n    link.onclick = () => {\n      if (otherClickAction) {\n        otherClickAction();\n      }\n\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n\n      const storage = this.annotationStorage;\n      const allIds = [];\n\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n\n          default:\n            continue;\n        }\n\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n\n      return false;\n    };\n  }\n\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    this.container.className = \"textAnnotation\";\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(image, this.data);\n    }\n\n    this.container.append(image);\n    return this.container;\n  }\n\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n\n    return this.container;\n  }\n\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = AnnotationElement.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n\n  _setEventListener(element, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n\n  _setEventListeners(element, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        this._setEventListener(element, baseName, eventName, getter);\n      }\n    }\n  }\n\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);\n      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util.LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);\n      computedFontSize = Math.min(fontSize, Math.round(height / _util.LINE_FACTOR));\n    }\n\n    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.className = \"textWidgetAnnotation\";\n    let element = null;\n\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.formattedValue || storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n\n      const elementData = {\n        userValue: textContent,\n        formattedValue: null,\n        valueOnFocus: \"\"\n      };\n\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = textContent;\n\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", textContent);\n\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n\n      this._setRequired(element, this.data.required);\n\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n\n        event.target.scrollLeft = 0;\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.userValue) {\n            event.target.value = elementData.userValue;\n          }\n\n          elementData.valueOnFocus = event.target.value;\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n              event.target.value = elementData.userValue;\n            },\n\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n\n              storage.setValue(id, {\n                formattedValue\n              });\n            },\n\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          let commitKey = -1;\n\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\") {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            commitKey = 3;\n          }\n\n          if (commitKey === -1) {\n            return;\n          }\n\n          const {\n            value\n          } = event.target;\n\n          if (elementData.valueOnFocus === value) {\n            return;\n          }\n\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          const {\n            value\n          } = event.target;\n          elementData.userValue = value;\n\n          if (this._mouseState.isDown && elementData.valueOnFocus !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: 1,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n\n          _blurListener(event);\n        });\n\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n                selEnd = selectionEnd;\n\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n\n                  break;\n                }\n\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n\n                  break;\n                }\n\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n\n                break;\n\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n\n                break;\n            }\n\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n\n        this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n\n    this._setTextStyle(element);\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n\n    this._setRequired(element, this.data.required);\n\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n\n    this._setRequired(element, this.data.required);\n\n    element.type = \"radio\";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n\n    this._setBackgroundColor(element);\n\n    this._setDefaultPropertiesFromJS(element);\n\n    this.container.append(element);\n    return this.container;\n  }\n\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n\n  render() {\n    const container = super.render();\n    container.className = \"buttonWidgetAnnotation pushButton\";\n\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n\n    const linkElement = container.lastChild;\n\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n\n    return container;\n  }\n\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n\n  render() {\n    this.container.className = \"choiceWidgetAnnotation\";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n\n    this._setRequired(selectElement, this.data.required);\n\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n\n      selectElement.append(optionElement);\n    }\n\n    let removeEmptyEntry = null;\n\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n\n    const getValue = (event, isExport) => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const options = event.target.options;\n\n      if (!event.target.multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n          },\n\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          items(event) {\n            const {\n              items\n            } = event.detail;\n\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true),\n              items: getItems(event)\n            });\n          },\n\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n\n            storage.setValue(id, {\n              value: getValue(event, true)\n            });\n          },\n\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n\n        };\n\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(event, true);\n        const value = getValue(event, false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value,\n            changeEx: exportValue,\n            willCommit: true,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n\n      this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(event, true)\n        });\n      });\n    }\n\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n\n    this._setBackgroundColor(selectElement);\n\n    this._setDefaultPropertiesFromJS(selectElement);\n\n    this.container.append(selectElement);\n    return this.container;\n  }\n\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable\n    });\n  }\n\n  render() {\n    const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n    this.container.className = \"popupAnnotation\";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n    const parentElements = this.layer.querySelectorAll(selector);\n\n    if (parentElements.length === 0) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: Array.from(parentElements),\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText\n    });\n    const page = this.page;\n\n    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n    const popupTop = rect[1];\n    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;\n    const pageWidth = pageURx - pageLLx;\n    const pageHeight = pageURy - pageLLy;\n    this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;\n    this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;\n    this.container.append(popup.render());\n    return this.container;\n  }\n\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.titleObj = parameters.titleObj;\n    this.modificationDate = parameters.modificationDate;\n    this.contentsObj = parameters.contentsObj;\n    this.richText = parameters.richText;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"popupWrapper\";\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.hidden = true;\n    const popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    const color = this.color;\n\n    if (color) {\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement(\"h1\");\n    title.dir = this.titleObj.dir;\n    title.textContent = this.titleObj.str;\n    popup.append(title);\n\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n    if (dateObject) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.textContent = \"{{date}}, {{time}}\";\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n      popup.append(modificationDate);\n    }\n\n    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: this.richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n\n      popup.lastChild.className = \"richText popupContent\";\n    } else {\n      const contents = this._formatContents(this.contentsObj);\n\n      popup.append(contents);\n    }\n\n    if (!Array.isArray(this.trigger)) {\n      this.trigger = [this.trigger];\n    }\n\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this._toggle.bind(this));\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n    }\n\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\n    wrapper.append(popup);\n    return wrapper;\n  }\n\n  _formatContents({\n    str,\n    dir\n  }) {\n    const p = document.createElement(\"p\");\n    p.className = \"popupContent\";\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n\n    return p;\n  }\n\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n\n    if (this.hideElement.hidden) {\n      this.hideElement.hidden = false;\n      this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000;\n    }\n  }\n\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n\n    if (!this.hideElement.hidden && !this.pinned) {\n      this.hideElement.hidden = true;\n      this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000;\n    }\n  }\n\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n  }\n\n  render() {\n    this.container.className = \"freeTextAnnotation\";\n\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.className = \"annotationTextContent\";\n      content.setAttribute(\"role\", \"comment\");\n\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n\n      this.container.append(content);\n    }\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"lineAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n\n    this._createPopup(line, data);\n\n    return this.container;\n  }\n\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"squareAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n\n    this._createPopup(square, data);\n\n    return this.container;\n  }\n\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"circleAnnotation\";\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n\n    this._createPopup(circle, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n\n    points = points.join(\" \");\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n\n    this._createPopup(polyline, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"caretAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n\n    for (const inkList of data.inkLists) {\n      let points = [];\n\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n\n      this._createPopup(polyline, data);\n\n      svg.append(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\n    }\n\n    this.container.className = \"highlightAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\n    }\n\n    this.container.className = \"underlineAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\n    }\n\n    this.container.className = \"squigglyAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n    }\n\n    this.container.className = \"strikeoutAnnotation\";\n    return this.container;\n  }\n\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  render() {\n    this.container.className = \"stampAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      filename,\n      content\n    });\n  }\n\n  render() {\n    this.container.className = \"fileAttachmentAnnotation\";\n    const trigger = document.createElement(\"div\");\n    trigger.className = \"popupTriggerArea\";\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {\n      this._createPopup(trigger, this.data);\n    }\n\n    this.container.append(trigger);\n    return this.container;\n  }\n\n  _download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n\n}\n\nclass AnnotationLayer {\n  static #appendElement(element, id, div, accessibilityManager) {\n    const contentElement = element.firstChild || element;\n    contentElement.id = `${_display_utils.AnnotationPrefix}${id}`;\n    div.append(element);\n    accessibilityManager?.moveElementInDOM(div, element, contentElement, false);\n  }\n\n  static render(parameters) {\n    const {\n      annotations,\n      div,\n      viewport,\n      accessibilityManager\n    } = parameters;\n    this.#setDimensions(div, viewport);\n    let zIndex = 0;\n\n    for (const data of annotations) {\n      if (data.annotationType !== _util.AnnotationType.POPUP) {\n        const {\n          width,\n          height\n        } = getRectDims(data.rect);\n\n        if (width <= 0 || height <= 0) {\n          continue;\n        }\n      }\n\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: div,\n        page: parameters.page,\n        viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\n        renderForms: parameters.renderForms !== false,\n        svgFactory: new _display_utils.DOMSVGFactory(),\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n        enableScripting: parameters.enableScripting,\n        hasJSActions: parameters.hasJSActions,\n        fieldObjects: parameters.fieldObjects,\n        mouseState: parameters.mouseState || {\n          isDown: false\n        }\n      });\n\n      if (element.isRenderable) {\n        const rendered = element.render();\n\n        if (data.hidden) {\n          rendered.style.visibility = \"hidden\";\n        }\n\n        if (Array.isArray(rendered)) {\n          for (const renderedElement of rendered) {\n            renderedElement.style.zIndex = zIndex++;\n            AnnotationLayer.#appendElement(renderedElement, data.id, div, accessibilityManager);\n          }\n        } else {\n          rendered.style.zIndex = zIndex++;\n\n          if (element instanceof PopupAnnotationElement) {\n            div.prepend(rendered);\n          } else {\n            AnnotationLayer.#appendElement(rendered, data.id, div, accessibilityManager);\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n  }\n\n  static update(parameters) {\n    const {\n      annotationCanvasMap,\n      div,\n      viewport\n    } = parameters;\n    this.#setDimensions(div, viewport);\n    this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n    div.hidden = false;\n  }\n\n  static #setDimensions(div, {\n    width,\n    height,\n    rotation\n  }) {\n    const {\n      style\n    } = div;\n    const flipOrientation = rotation % 180 !== 0,\n          widthStr = Math.floor(width) + \"px\",\n          heightStr = Math.floor(height) + \"px\";\n    style.width = flipOrientation ? heightStr : widthStr;\n    style.height = flipOrientation ? widthStr : heightStr;\n    div.setAttribute(\"data-main-rotation\", rotation);\n  }\n\n  static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n    if (!annotationCanvasMap) {\n      return;\n    }\n\n    for (const [id, canvas] of annotationCanvasMap) {\n      const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n\n      if (!element) {\n        continue;\n      }\n\n      const {\n        firstChild\n      } = element;\n\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else {\n        firstChild.before(canvas);\n      }\n    }\n\n    annotationCanvasMap.clear();\n  }\n\n}\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 28 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\n\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return \"#00000000\";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n\n}\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 29 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\n\nvar _xfa_text = __w_pdfjs_require__(20);\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n\n        if (intent === \"print\") {\n          break;\n        }\n\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n\n          if (intent === \"print\") {\n            break;\n          }\n\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n\n        break;\n\n      case \"select\":\n        if (storedData.value !== null) {\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            }\n          }\n        }\n\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n\n          break;\n\n        case \"dataId\":\n          break;\n\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n\n        case \"textContent\":\n          html.textContent = value;\n          break;\n\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n\n      }\n    }\n\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n\n    const textDivs = [];\n\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n\n      const child = parent.children[++stack.at(-1)[1]];\n\n      if (child === null) {\n        continue;\n      }\n\n      const {\n        name\n      } = child;\n\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n\n      let childHtml;\n\n      if (child?.attributes?.xmlns) {\n        childHtml = document.createElementNS(child.attributes.xmlns, name);\n      } else {\n        childHtml = document.createElement(name);\n      }\n\n      html.append(childHtml);\n\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n\n        childHtml.append(node);\n      }\n    }\n\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n\n    return {\n      textDivs\n    };\n  }\n\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n\n}\n\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 30 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TextLayerRenderTask = void 0;\nexports.renderTextLayer = renderTextLayer;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nconst AllWhitespaceRegexp = /^\\s+$/g;\n\nfunction getAscent(fontFamily, ctx) {\n  const cachedAscent = ascentCache.get(fontFamily);\n\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n\n  ctx.save();\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n\n  if (ascent) {\n    ctx.restore();\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.restore();\n\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\n\nfunction appendText(task, geom, styles, ctx) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = task._enhanceTextSelection ? {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    originalTransform: null,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 0,\n    scale: 1,\n    fontSize: 0\n  } : {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    fontSize: 0\n  };\n\n  task._textDivs.push(textDiv);\n\n  const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n  let left, top;\n\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n\n  textDiv.style.left = `${left}px`;\n  textDiv.style.top = `${top}px`;\n  textDiv.style.fontSize = `${fontHeight}px`;\n  textDiv.style.fontFamily = style.fontFamily;\n  textDivProperties.fontSize = fontHeight;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n\n  let shouldScaleText = false;\n\n  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n\n  if (shouldScaleText) {\n    if (style.vertical) {\n      textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n    } else {\n      textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n    }\n  }\n\n  task._textDivProperties.set(textDiv, textDivProperties);\n\n  if (task._textContentStream) {\n    task._layoutText(textDiv);\n  }\n\n  if (task._enhanceTextSelection && textDivProperties.hasText) {\n    let angleCos = 1,\n        angleSin = 0;\n\n    if (angle !== 0) {\n      angleCos = Math.cos(angle);\n      angleSin = Math.sin(angle);\n    }\n\n    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n    const divHeight = fontHeight;\n    let m, b;\n\n    if (angle !== 0) {\n      m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n    } else {\n      b = [left, top, left + divWidth, top + divHeight];\n    }\n\n    task._bounds.push({\n      left: b[0],\n      top: b[1],\n      right: b[2],\n      bottom: b[3],\n      div: textDiv,\n      size: [divWidth, divHeight],\n      m\n    });\n  }\n}\n\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    task._renderingDone = true;\n    capability.resolve();\n    return;\n  }\n\n  if (!task._textContentStream) {\n    for (let i = 0; i < textDivsLength; i++) {\n      task._layoutText(textDivs[i]);\n    }\n  }\n\n  task._renderingDone = true;\n  capability.resolve();\n}\n\nfunction findPositiveMin(ts, offset, count) {\n  let result = 0;\n\n  for (let i = 0; i < count; i++) {\n    const t = ts[offset++];\n\n    if (t > 0) {\n      result = result ? Math.min(t, result) : t;\n    }\n  }\n\n  return result;\n}\n\nfunction expand(task) {\n  const bounds = task._bounds;\n  const viewport = task._viewport;\n  const expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n  for (let i = 0; i < expanded.length; i++) {\n    const div = bounds[i].div;\n\n    const divProperties = task._textDivProperties.get(div);\n\n    if (divProperties.angle === 0) {\n      divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n      divProperties.paddingTop = bounds[i].top - expanded[i].top;\n      divProperties.paddingRight = expanded[i].right - bounds[i].right;\n      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n      task._textDivProperties.set(div, divProperties);\n\n      continue;\n    }\n\n    const e = expanded[i],\n          b = bounds[i];\n    const m = b.m,\n          c = m[0],\n          s = m[1];\n    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n    const ts = new Float64Array(64);\n\n    for (let j = 0, jj = points.length; j < jj; j++) {\n      const t = _util.Util.applyTransform(points[j], m);\n\n      ts[j + 0] = c && (e.left - t[0]) / c;\n      ts[j + 4] = s && (e.top - t[1]) / s;\n      ts[j + 8] = c && (e.right - t[0]) / c;\n      ts[j + 12] = s && (e.bottom - t[1]) / s;\n      ts[j + 16] = s && (e.left - t[0]) / -s;\n      ts[j + 20] = c && (e.top - t[1]) / c;\n      ts[j + 24] = s && (e.right - t[0]) / -s;\n      ts[j + 28] = c && (e.bottom - t[1]) / c;\n      ts[j + 32] = c && (e.left - t[0]) / -c;\n      ts[j + 36] = s && (e.top - t[1]) / -s;\n      ts[j + 40] = c && (e.right - t[0]) / -c;\n      ts[j + 44] = s && (e.bottom - t[1]) / -s;\n      ts[j + 48] = s && (e.left - t[0]) / s;\n      ts[j + 52] = c && (e.top - t[1]) / -c;\n      ts[j + 56] = s && (e.right - t[0]) / s;\n      ts[j + 60] = c && (e.bottom - t[1]) / -c;\n    }\n\n    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n    task._textDivProperties.set(div, divProperties);\n  }\n}\n\nfunction expandBounds(width, height, boxes) {\n  const bounds = boxes.map(function (box, i) {\n    return {\n      x1: box.left,\n      y1: box.top,\n      x2: box.right,\n      y2: box.bottom,\n      index: i,\n      x1New: undefined,\n      x2New: undefined\n    };\n  });\n  expandBoundsLTR(width, bounds);\n  const expanded = new Array(boxes.length);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i] = {\n      left: b.x1New,\n      top: 0,\n      right: b.x2New,\n      bottom: 0\n    };\n  }\n\n  boxes.map(function (box, i) {\n    const e = expanded[i],\n          b = bounds[i];\n    b.x1 = box.top;\n    b.y1 = width - e.right;\n    b.x2 = box.bottom;\n    b.y2 = width - e.left;\n    b.index = i;\n    b.x1New = undefined;\n    b.x2New = undefined;\n  });\n  expandBoundsLTR(height, bounds);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i].top = b.x1New;\n    expanded[i].bottom = b.x2New;\n  }\n\n  return expanded;\n}\n\nfunction expandBoundsLTR(width, bounds) {\n  bounds.sort(function (a, b) {\n    return a.x1 - b.x1 || a.index - b.index;\n  });\n  const fakeBoundary = {\n    x1: -Infinity,\n    y1: -Infinity,\n    x2: 0,\n    y2: Infinity,\n    index: -1,\n    x1New: 0,\n    x2New: 0\n  };\n  const horizon = [{\n    start: -Infinity,\n    end: Infinity,\n    boundary: fakeBoundary\n  }];\n\n  for (const boundary of bounds) {\n    let i = 0;\n\n    while (i < horizon.length && horizon[i].end <= boundary.y1) {\n      i++;\n    }\n\n    let j = horizon.length - 1;\n\n    while (j >= 0 && horizon[j].start >= boundary.y2) {\n      j--;\n    }\n\n    let horizonPart, affectedBoundary;\n    let q,\n        k,\n        maxXNew = -Infinity;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      let xNew;\n\n      if (affectedBoundary.x2 > boundary.x1) {\n        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n      } else if (affectedBoundary.x2New === undefined) {\n        xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n      } else {\n        xNew = affectedBoundary.x2New;\n      }\n\n      if (xNew > maxXNew) {\n        maxXNew = xNew;\n      }\n    }\n\n    boundary.x1New = maxXNew;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        if (affectedBoundary.x2 > boundary.x1) {\n          if (affectedBoundary.index > boundary.index) {\n            affectedBoundary.x2New = affectedBoundary.x2;\n          }\n        } else {\n          affectedBoundary.x2New = maxXNew;\n        }\n      } else if (affectedBoundary.x2New > maxXNew) {\n        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n      }\n    }\n\n    const changedHorizon = [];\n    let lastBoundary = null;\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n      if (lastBoundary === useBoundary) {\n        changedHorizon.at(-1).end = horizonPart.end;\n      } else {\n        changedHorizon.push({\n          start: horizonPart.start,\n          end: horizonPart.end,\n          boundary: useBoundary\n        });\n        lastBoundary = useBoundary;\n      }\n    }\n\n    if (horizon[i].start < boundary.y1) {\n      changedHorizon[0].start = boundary.y1;\n      changedHorizon.unshift({\n        start: horizon[i].start,\n        end: boundary.y1,\n        boundary: horizon[i].boundary\n      });\n    }\n\n    if (boundary.y2 < horizon[j].end) {\n      changedHorizon.at(-1).end = boundary.y2;\n      changedHorizon.push({\n        start: boundary.y2,\n        end: horizon[j].end,\n        boundary: horizon[j].boundary\n      });\n    }\n\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New !== undefined) {\n        continue;\n      }\n\n      let used = false;\n\n      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n\n      for (k = 0; !used && k < changedHorizon.length; k++) {\n        used = changedHorizon[k].boundary === affectedBoundary;\n      }\n\n      if (!used) {\n        affectedBoundary.x2New = maxXNew;\n      }\n    }\n\n    Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);\n  }\n\n  for (const horizonPart of horizon) {\n    const affectedBoundary = horizonPart.boundary;\n\n    if (affectedBoundary.x2New === undefined) {\n      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n    }\n  }\n}\n\nclass TextLayerRenderTask {\n  constructor({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection\n  }) {\n    if (enhanceTextSelection) {\n      (0, _display_utils.deprecated)(\"The `enhanceTextSelection` functionality will be removed in the future.\");\n    }\n\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n    this._devicePixelRatio = globalThis.devicePixelRatio || 1;\n\n    this._capability.promise.finally(() => {\n      if (!this._enhanceTextSelection) {\n        this._textDivProperties = null;\n      }\n\n      if (this._layoutTextCtx) {\n        this._layoutTextCtx.canvas.width = 0;\n        this._layoutTextCtx.canvas.height = 0;\n        this._layoutTextCtx = null;\n      }\n    }).catch(() => {});\n  }\n\n  get promise() {\n    return this._capability.promise;\n  }\n\n  cancel() {\n    this._canceled = true;\n\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n\n      this._reader = null;\n    }\n\n    if (this._renderTimer !== null) {\n      clearTimeout(this._renderTimer);\n      this._renderTimer = null;\n    }\n\n    this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n  }\n\n  _processItems(items, styleCache) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      if (items[i].str === undefined) {\n        if (items[i].type === \"beginMarkedContentProps\" || items[i].type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n\n          this._container.classList.add(\"markedContent\");\n\n          if (items[i].id !== null) {\n            this._container.setAttribute(\"id\", `${items[i].id}`);\n          }\n\n          parent.append(this._container);\n        } else if (items[i].type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n\n        continue;\n      }\n\n      this._textContentItemsStr.push(items[i].str);\n\n      appendText(this, items[i], styleCache, this._layoutTextCtx);\n    }\n  }\n\n  _layoutText(textDiv) {\n    const textDivProperties = this._textDivProperties.get(textDiv);\n\n    let transform = \"\";\n\n    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n      const {\n        fontFamily\n      } = textDiv.style;\n      const {\n        fontSize\n      } = textDivProperties;\n\n      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n        this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;\n        this._layoutTextLastFontSize = fontSize;\n        this._layoutTextLastFontFamily = fontFamily;\n      }\n\n      const {\n        width\n      } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n      if (width > 0) {\n        const scale = this._devicePixelRatio * textDivProperties.canvasWidth / width;\n\n        if (this._enhanceTextSelection) {\n          textDivProperties.scale = scale;\n        }\n\n        transform = `scaleX(${scale})`;\n      }\n    }\n\n    if (textDivProperties.angle !== 0) {\n      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n    }\n\n    if (transform.length > 0) {\n      if (this._enhanceTextSelection) {\n        textDivProperties.originalTransform = transform;\n      }\n\n      textDiv.style.transform = transform;\n    }\n\n    if (textDivProperties.hasText) {\n      this._container.append(textDiv);\n    }\n\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n\n      this._container.append(br);\n    }\n  }\n\n  _render(timeout = 0) {\n    const capability = (0, _util.createPromiseCapability)();\n    let styleCache = Object.create(null);\n\n    const canvas = this._document.createElement(\"canvas\");\n\n    canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n    this._layoutTextCtx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n\n    if (this._textContent) {\n      const textItems = this._textContent.items;\n      const textStyles = this._textContent.styles;\n\n      this._processItems(textItems, textStyles);\n\n      capability.resolve();\n    } else if (this._textContentStream) {\n      const pump = () => {\n        this._reader.read().then(({\n          value,\n          done\n        }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n\n          Object.assign(styleCache, value.styles);\n\n          this._processItems(value.items, styleCache);\n\n          pump();\n        }, capability.reject);\n      };\n\n      this._reader = this._textContentStream.getReader();\n      pump();\n    } else {\n      throw new Error('Neither \"textContent\" nor \"textContentStream\" parameters specified.');\n    }\n\n    capability.promise.then(() => {\n      styleCache = null;\n\n      if (!timeout) {\n        render(this);\n      } else {\n        this._renderTimer = setTimeout(() => {\n          render(this);\n          this._renderTimer = null;\n        }, timeout);\n      }\n    }, this._capability.reject);\n  }\n\n  expandTextDivs(expandDivs = false) {\n    if (!this._enhanceTextSelection || !this._renderingDone) {\n      return;\n    }\n\n    if (this._bounds !== null) {\n      expand(this);\n      this._bounds = null;\n    }\n\n    const transformBuf = [],\n          paddingBuf = [];\n\n    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n      const div = this._textDivs[i];\n\n      const divProps = this._textDivProperties.get(div);\n\n      if (!divProps.hasText) {\n        continue;\n      }\n\n      if (expandDivs) {\n        transformBuf.length = 0;\n        paddingBuf.length = 0;\n\n        if (divProps.originalTransform) {\n          transformBuf.push(divProps.originalTransform);\n        }\n\n        if (divProps.paddingTop > 0) {\n          paddingBuf.push(`${divProps.paddingTop}px`);\n          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingRight > 0) {\n          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingBottom > 0) {\n          paddingBuf.push(`${divProps.paddingBottom}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        if (divProps.paddingLeft > 0) {\n          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n\n        div.style.padding = paddingBuf.join(\" \");\n\n        if (transformBuf.length) {\n          div.style.transform = transformBuf.join(\" \");\n        }\n      } else {\n        div.style.padding = null;\n        div.style.transform = divProps.originalTransform;\n      }\n    }\n  }\n\n}\n\nexports.TextLayerRenderTask = TextLayerRenderTask;\n\nfunction renderTextLayer(renderParameters) {\n  const task = new TextLayerRenderTask({\n    textContent: renderParameters.textContent,\n    textContentStream: renderParameters.textContentStream,\n    container: renderParameters.container,\n    viewport: renderParameters.viewport,\n    textDivs: renderParameters.textDivs,\n    textContentItemsStr: renderParameters.textContentItemsStr,\n    enhanceTextSelection: renderParameters.enhanceTextSelection\n  });\n\n  task._render(renderParameters.timeout);\n\n  return task;\n}\n\n/***/ }),\n/* 31 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nlet SVGGraphics = class {\n  constructor() {\n    (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n  }\n\n};\nexports.SVGGraphics = SVGGraphics;\n{\n  const SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  const createObjectURL = function (data, contentType = \"\", forceDataSchema = false) {\n    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n      return URL.createObjectURL(new Blob([data], {\n        type: contentType\n      }));\n    }\n\n    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let buffer = `data:${contentType};base64,`;\n\n    for (let i = 0, ii = data.length; i < ii; i += 3) {\n      const b1 = data[i] & 0xff;\n      const b2 = data[i + 1] & 0xff;\n      const b3 = data[i + 2] & 0xff;\n      const d1 = b1 >> 2,\n            d2 = (b1 & 3) << 4 | b2 >> 4;\n      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n\n  const convertImgDataToPng = function () {\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    const CHUNK_WRAPPER_SIZE = 12;\n    const crcTable = new Int32Array(256);\n\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      const crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        let input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        const output = (__webpack_require__(62216).deflateSync)(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      let pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      const adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++;\n\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      const idat = deflateSync(literals);\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return createObjectURL(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n  }\n\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === \"save\") {\n        opTree.push({\n          fnId: 92,\n          fn: \"group\",\n          items: []\n        });\n        tmp.push(opTree);\n        opTree = opTree.at(-1).items;\n        continue;\n      }\n\n      if (opListElement.fn === \"restore\") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n\n    return opTree;\n  }\n\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  }\n\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = Math.acos(m[0]) * 180 / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n  }\n\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n  exports.SVGGraphics = SVGGraphics = class {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (const op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== _util.OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i]\n        });\n      }\n\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case _util.OPS.beginText:\n            this.beginText();\n            break;\n\n          case _util.OPS.dependency:\n            break;\n\n          case _util.OPS.setLeading:\n            this.setLeading(args);\n            break;\n\n          case _util.OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setFont:\n            this.setFont(args);\n            break;\n\n          case _util.OPS.showText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.endText:\n            this.endText();\n            break;\n\n          case _util.OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n\n          case _util.OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n\n          case _util.OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n\n          case _util.OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n\n          case _util.OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n\n          case _util.OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n\n          case _util.OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n\n          case _util.OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n\n          case _util.OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n\n          case _util.OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n\n          case _util.OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n\n          case _util.OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n\n          case _util.OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n\n          case _util.OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n\n          case _util.OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n\n          case _util.OPS.setGState:\n            this.setGState(args[0]);\n            break;\n\n          case _util.OPS.fill:\n            this.fill();\n            break;\n\n          case _util.OPS.eoFill:\n            this.eoFill();\n            break;\n\n          case _util.OPS.stroke:\n            this.stroke();\n            break;\n\n          case _util.OPS.fillStroke:\n            this.fillStroke();\n            break;\n\n          case _util.OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n\n          case _util.OPS.clip:\n            this.clip(\"nonzero\");\n            break;\n\n          case _util.OPS.eoClip:\n            this.clip(\"evenodd\");\n            break;\n\n          case _util.OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n\n          case _util.OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n\n          case _util.OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n\n          case _util.OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n\n          case _util.OPS.closePath:\n            this.closePath();\n            break;\n\n          case _util.OPS.closeStroke:\n            this.closeStroke();\n            break;\n\n          case _util.OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n\n          case _util.OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n\n          case _util.OPS.nextLine:\n            this.nextLine();\n            break;\n\n          case _util.OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n\n          case _util.OPS.endPath:\n            this.endPath();\n            break;\n\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.hypot(a, b);\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtElement.append(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = _util.IDENTITY_MATRIX;\n      current.lineMatrix = _util.IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n      let x = 0;\n\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (typeof glyph === \"number\") {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n\n          current.tspan.textContent += character;\n        } else {}\n\n        let charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n\n      current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n      if (vertical) {\n        current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n      } else {\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n      }\n\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n      }\n\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n        }\n\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n      } else {\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      let textMatrix = current.textMatrix;\n\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n      current.txtElement.append(current.tspan);\n      current.txtgrp.append(current.txtElement);\n\n      this._ensureTransformGroup().append(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n      }\n\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n        this.defs.append(this.cssStyle);\n      }\n\n      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n      this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      let bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n        current.element = current.txtElement;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", x0);\n      rect.setAttributeNS(null, \"y\", y0);\n      rect.setAttributeNS(null, \"width\", x1 - x0);\n      rect.setAttributeNS(null, \"height\", y1 - y0);\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n      }\n\n      this._ensureTransformGroup().append(rect);\n    }\n\n    _makeColorN_Pattern(args) {\n      if (args[0] === \"TilingPattern\") {\n        return this._makeTilingPattern(args);\n      }\n\n      return this._makeShadingPattern(args);\n    }\n\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n      const tilingId = `shading${shadingCount++}`;\n\n      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\n      tiling.setAttributeNS(null, \"id\", tilingId);\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n      tiling.setAttributeNS(null, \"width\", txstep);\n      tiling.setAttributeNS(null, \"height\", tystep);\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n\n      if (paintType === 2) {\n        const cssColor = _util.Util.makeHexColor(...color);\n\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n\n      this.executeOpTree(this.convertOpList(operatorList));\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n      tiling.append(bbox.childNodes[0]);\n      this.defs.append(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    _makeShadingPattern(args) {\n      if (typeof args === \"string\") {\n        args = this.objs.get(args);\n      }\n\n      switch (args[0]) {\n        case \"RadialAxial\":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case \"axial\":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\n              break;\n\n            case \"radial\":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n              gradient.setAttributeNS(null, \"r\", circleRadius);\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\n              break;\n\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement(\"svg:stop\");\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n            gradient.append(stop);\n          }\n\n          this.defs.append(gradient);\n          return `url(#${shadingId})`;\n\n        case \"Mesh\":\n          (0, _util.warn)(\"Unimplemented pattern Mesh\");\n          return null;\n\n        case \"Dummy\":\n          return \"hotpink\";\n\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n          y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"M\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"L\", pf(x), pf(y));\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            d.push(\"Z\");\n            break;\n        }\n      }\n\n      d = d.join(\" \");\n\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n        d = current.path.getAttributeNS(null, \"d\") + d;\n      } else {\n        current.path = this.svgFactory.createElement(\"svg:path\");\n\n        this._ensureTransformGroup().append(current.path);\n      }\n\n      current.path.setAttributeNS(null, \"d\", d);\n      current.path.setAttributeNS(null, \"fill\", \"none\");\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n      clipPath.setAttributeNS(null, \"id\", clipId);\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      const clipElement = current.element.cloneNode(true);\n\n      if (this.pendingClip === \"evenodd\") {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n      } else {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n      }\n\n      this.pendingClip = null;\n      clipPath.append(clipElement);\n      this.defs.append(clipPath);\n\n      if (current.activeClipUrl) {\n        current.clipGroup = null;\n\n        for (const prev of this.extraStack) {\n          prev.clipGroup = null;\n        }\n\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n      }\n\n      current.activeClipUrl = `url(#${clipId})`;\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n        current.path.setAttributeNS(null, \"d\", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {}\n\n    setFlatness(flatness) {}\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value);\n            break;\n\n          case \"CA\":\n            this.setStrokeAlpha(value);\n            break;\n\n          case \"ca\":\n            this.setFillAlpha(value);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n\n      if (current.element) {\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n\n        current.element.setAttributeNS(null, \"fill\", \"none\");\n        this.endPath();\n      }\n    }\n\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n      element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n      element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n      element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fill();\n    }\n\n    fillStroke() {\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", \"1px\");\n      rect.setAttributeNS(null, \"height\", \"1px\");\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n      this._ensureTransformGroup().append(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", \"0\");\n      cliprect.setAttributeNS(null, \"y\", \"0\");\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n      imgEl.setAttributeNS(null, \"x\", \"0\");\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n      imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n      if (mask) {\n        mask.append(imgEl);\n      } else {\n        this._ensureTransformGroup().append(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement(\"svg:mask\");\n      mask.setAttributeNS(null, \"id\", current.maskId);\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", pf(width));\n      rect.setAttributeNS(null, \"height\", pf(height));\n      rect.setAttributeNS(null, \"fill\", fillColor);\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n      this.defs.append(mask);\n\n      this._ensureTransformGroup().append(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\n      svg.append(definitions);\n      this.defs = definitions;\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n      svg.append(rootGroup);\n      this.svg = rootGroup;\n      return svg;\n    }\n\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n        this.svg.append(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n\n      return this.current.clipGroup;\n    }\n\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().append(this.tgrp);\n        } else {\n          this.svg.append(this.tgrp);\n        }\n      }\n\n      return this.tgrp;\n    }\n\n  };\n}\n\n/***/ }),\n/* 32 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\n\nconst fs = __webpack_require__(70172);\n\nconst http = __webpack_require__(2001);\n\nconst https = __webpack_require__(33779);\n\nconst url = __webpack_require__(11987);\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n    this._rangeRequestReaders.push(rangeReader);\n\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNodeStream = PDFNodeStream;\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._headersCapability.resolve();\n\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n\n      this._headersCapability.reject(reason);\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      this._httpHeaders[property] = value;\n    }\n\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n\n      this._headersCapability.resolve();\n    });\n  }\n\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n\n}\n\n/***/ }),\n/* 33 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _content_disposition = __w_pdfjs_require__(34);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 34 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nvar _util = __w_pdfjs_require__(1);\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch (e) {}\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    const parts = [];\n\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n\n      if (quot) {\n        part = unescape(part);\n\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n\n      parts.push(part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 35 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  const array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      xhr.setRequestHeader(property, value);\n    }\n\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n\n    xhr.responseType = \"arraybuffer\";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    pendingRequest.onProgress?.(evt);\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    const xhr = pendingRequest.xhr;\n\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n\n}\n\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n\n    this._done = true;\n\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    this._headersReceivedCapability.reject(this._storedError);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._headersReceivedCapability.reject(reason);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n\n    this._fullRequestReader = null;\n  }\n\n}\n\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    this.onClosed?.(this);\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    this._close();\n  }\n\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this._requests.length = 0;\n\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n\n    this._close();\n  }\n\n}\n\n/***/ }),\n/* 36 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _network_utils = __w_pdfjs_require__(33);\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n\n}\n\nexports.PDFFetchStream = PDFFetchStream;\n\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._reader = response.body.getReader();\n\n      this._headersCapability.resolve();\n\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    this._abortController.abort();\n  }\n\n}\n\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._readCapability.resolve();\n\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    this._abortController.abort();\n  }\n\n}\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AnnotationEditorLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_editor_layer.AnnotationEditorLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorParamsType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorParamsType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorUIManager\", ({\n  enumerable: true,\n  get: function () {\n    return _tools.AnnotationEditorUIManager;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"LoopbackPort\", ({\n  enumerable: true,\n  get: function () {\n    return _api.LoopbackPort;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _svg.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createPromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createPromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\n\nvar _util = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(4);\n\nvar _display_utils = __w_pdfjs_require__(8);\n\nvar _annotation_editor_layer = __w_pdfjs_require__(22);\n\nvar _tools = __w_pdfjs_require__(7);\n\nvar _annotation_layer = __w_pdfjs_require__(27);\n\nvar _worker_options = __w_pdfjs_require__(15);\n\nvar _is_node = __w_pdfjs_require__(3);\n\nvar _text_layer = __w_pdfjs_require__(30);\n\nvar _svg = __w_pdfjs_require__(31);\n\nvar _xfa_layer = __w_pdfjs_require__(29);\n\nconst pdfjsVersion = '2.16.105';\nconst pdfjsBuild = '172ccdbe5';\n{\n  if (_is_node.isNodeJS) {\n    const {\n      PDFNodeStream\n    } = __w_pdfjs_require__(32);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const {\n      PDFNetworkStream\n    } = __w_pdfjs_require__(35);\n\n    const {\n      PDFFetchStream\n    } = __w_pdfjs_require__(36);\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      if ((0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map\n\n/***/ })\n\n}]);"],"names":["self","push","module","__unused_webpack_exports","__webpack_require__","root","factory","process","Buffer","globalThis","__webpack_modules__","__unused_webpack_module","exports","__w_pdfjs_require__","Object","defineProperty","value","VerbosityLevel","Util","UnknownErrorException","UnexpectedResponseException","UNSUPPORTED_FEATURES","TextRenderingMode","StreamType","RenderingIntentFlag","PermissionFlag","PasswordResponses","PasswordException","PageActionEventType","OPS","MissingPDFException","LINE_FACTOR","LINE_DESCENT_FACTOR","InvalidPDFException","ImageKind","IDENTITY_MATRIX","FormatError","FontType","FeatureTest","FONT_IDENTITY_MATRIX","DocumentActionEventType","CMapCompressionType","BaseException","AnnotationType","AnnotationStateModelType","AnnotationReviewState","AnnotationReplyType","AnnotationMode","AnnotationMarkedState","AnnotationFlag","AnnotationFieldFlag","AnnotationEditorType","AnnotationEditorPrefix","AnnotationEditorParamsType","AnnotationBorderStyleType","AnnotationActionEventType","AbortException","arrayByteLength","arraysToBytes","assert","bytesToString","createPromiseCapability","createValidAbsoluteUrl","escapeString","getModificationDate","getVerbosityLevel","info","isArrayBuffer","isArrayEqual","isAscii","objectFromMap","objectSize","setVerbosityLevel","shadow","string32","stringToBytes","stringToPDFString","stringToUTF16BEString","stringToUTF8String","unreachable","utf8StringToString","warn","ANY","DISPLAY","PRINT","ANNOTATIONS_FORMS","ANNOTATIONS_STORAGE","ANNOTATIONS_DISABLE","OPLIST","DISABLE","ENABLE","ENABLE_FORMS","ENABLE_STORAGE","NONE","FREETEXT","INK","FREETEXT_SIZE","FREETEXT_COLOR","FREETEXT_OPACITY","INK_COLOR","INK_THICKNESS","INK_OPACITY","MODIFY_CONTENTS","COPY","MODIFY_ANNOTATIONS","FILL_INTERACTIVE_FORMS","COPY_FOR_ACCESSIBILITY","ASSEMBLE","PRINT_HIGH_QUALITY","FILL","STROKE","FILL_STROKE","INVISIBLE","FILL_ADD_TO_PATH","STROKE_ADD_TO_PATH","FILL_STROKE_ADD_TO_PATH","ADD_TO_PATH","FILL_STROKE_MASK","ADD_TO_PATH_FLAG","GRAYSCALE_1BPP","RGB_24BPP","RGBA_32BPP","TEXT","LINK","LINE","SQUARE","CIRCLE","POLYGON","POLYLINE","HIGHLIGHT","UNDERLINE","SQUIGGLY","STRIKEOUT","STAMP","CARET","POPUP","FILEATTACHMENT","SOUND","MOVIE","WIDGET","SCREEN","PRINTERMARK","TRAPNET","WATERMARK","THREED","REDACT","MARKED","REVIEW","UNMARKED","ACCEPTED","REJECTED","CANCELLED","COMPLETED","GROUP","REPLY","HIDDEN","NOZOOM","NOROTATE","NOVIEW","READONLY","LOCKED","TOGGLENOVIEW","LOCKEDCONTENTS","REQUIRED","NOEXPORT","MULTILINE","PASSWORD","NOTOGGLETOOFF","RADIO","PUSHBUTTON","COMBO","EDIT","SORT","FILESELECT","MULTISELECT","DONOTSPELLCHECK","DONOTSCROLL","COMB","RICHTEXT","RADIOSINUNISON","COMMITONSELCHANGE","SOLID","DASHED","BEVELED","INSET","E","X","D","U","Fo","Bl","PO","PC","PV","PI","K","F","V","C","WC","WS","DS","WP","DP","O","UNKNOWN","FLATE","LZW","DCT","JPX","JBIG","A85","AHX","CCF","RLX","TYPE1","TYPE1STANDARD","TYPE1C","CIDFONTTYPE0","CIDFONTTYPE0C","TRUETYPE","CIDFONTTYPE2","TYPE3","OPENTYPE","TYPE0","MMTYPE1","ERRORS","WARNINGS","INFOS","BINARY","STREAM","dependency","setLineWidth","setLineCap","setLineJoin","setMiterLimit","setDash","setRenderingIntent","setFlatness","setGState","save","restore","transform","moveTo","lineTo","curveTo","curveTo2","curveTo3","closePath","rectangle","stroke","closeStroke","fill","eoFill","fillStroke","eoFillStroke","closeFillStroke","closeEOFillStroke","endPath","clip","eoClip","beginText","endText","setCharSpacing","setWordSpacing","setHScale","setLeading","setFont","setTextRenderingMode","setTextRise","moveText","setLeadingMoveText","setTextMatrix","nextLine","showText","showSpacedText","nextLineShowText","nextLineSetSpacingShowText","setCharWidth","setCharWidthAndBounds","setStrokeColorSpace","setFillColorSpace","setStrokeColor","setStrokeColorN","setFillColor","setFillColorN","setStrokeGray","setFillGray","setStrokeRGBColor","setFillRGBColor","setStrokeCMYKColor","setFillCMYKColor","shadingFill","beginInlineImage","beginImageData","endInlineImage","paintXObject","markPoint","markPointProps","beginMarkedContent","beginMarkedContentProps","endMarkedContent","beginCompat","endCompat","paintFormXObjectBegin","paintFormXObjectEnd","beginGroup","endGroup","beginAnnotations","endAnnotations","beginAnnotation","endAnnotation","paintJpegXObject","paintImageMaskXObject","paintImageMaskXObjectGroup","paintImageXObject","paintInlineImageXObject","paintInlineImageXObjectGroup","paintImageXObjectRepeat","paintImageMaskXObjectRepeat","paintSolidColorImageMask","constructPath","unknown","forms","javaScript","signatures","smask","shadingPattern","font","errorTilingPattern","errorExtGState","errorXObject","errorFontLoadType3","errorFontState","errorFontMissing","errorFontTranslate","errorColorSpace","errorOperatorList","errorFontToUnicode","errorFontLoadNative","errorFontBuildPath","errorFontGetPath","errorMarkedContent","errorContentSubStream","NEED_PASSWORD","INCORRECT_PASSWORD","verbosity","level","Number","isInteger","msg","console","log","cond","_isValidProtocol","url","protocol","baseUrl","options","addDefaultProtocol","startsWith","dots","match","length","tryConvertEncoding","ex","absoluteUrl","URL","obj","prop","enumerable","configurable","writable","message","name","constructor","prototype","code","details","status","bytes","undefined","MAX_ARGUMENT_COUNT","String","fromCharCode","apply","strBuf","i","chunkEnd","Math","min","chunk","subarray","join","str","Uint8Array","charCodeAt","arr","byteLength","resultLength","pos","data","item","itemLength","set","keys","map","create","key","isLittleEndian","buffer8","view32","Uint32Array","buffer","isEvalSupported","e","isOffscreenCanvasSupported","OffscreenCanvas","hexNumbers","Array","n","toString","padStart","makeHexColor","r","g","b","scaleMinMax","minMax","temp","m1","m2","applyTransform","p","m","xt","yt","applyInverseTransform","d","getAxialAlignedBoundingBox","p1","p2","slice","p3","p4","max","inverseTransform","apply3dTransform","v","singularValueDecompose2dScale","transpose","a","c","first","second","sqrt","sx","sy","normalizeRect","rect","intersect","rect1","rect2","xLow","xHigh","yLow","yHigh","bezierBoundingBox","x0","y0","x1","y1","x2","y2","x3","y3","t","t1","t2","b2ac","sqrtb2ac","tvalues","bounds","abs","j","mt","jlen","PDFStringTranslateTable","encoding","decoder","TextDecoder","fatal","decode","ii","charAt","replace","test","buf","char","decodeURIComponent","escape","unescape","encodeURIComponent","arr1","arr2","date","Date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","capability","isSettled","get","promise","Promise","resolve","reject","reason","isNodeJS","versions","nw","electron","type","createPDFNetworkStream","build","RenderTask","PDFWorkerUtil","PDFWorker","PDFPageProxy","PDFDocumentProxy","PDFDocumentLoadingTask","PDFDataRangeTransport","LoopbackPort","DefaultStandardFontDataFactory","DefaultCanvasFactory","DefaultCMapReaderFactory","getDocument","setPDFNetworkStreamFactory","version","_util","_annotation_storage","_display_utils","_font_loader","_canvas","_worker_options","_is_node","_message_handler","_metadata","_optional_content_config","_transport_stream","_xfa_text","DEFAULT_RANGE_CHUNK_SIZE","RENDERING_CANCELLED_TIMEOUT","DOMCanvasFactory","DOMCMapReaderFactory","DOMStandardFontDataFactory","NodeCanvasFactory","NodeCMapReaderFactory","NodeStandardFontDataFactory","pdfNetworkStreamFactory","src","source","task","range","params","rangeTransport","worker","window","location","href","isNaN","CMapReaderFactory","StandardFontDataFactory","ignoreErrors","stopAtErrors","fontExtraProperties","pdfBug","enableXfa","rangeChunkSize","docBaseUrl","isDataScheme","maxImageSize","cMapUrl","standardFontDataUrl","useWorkerFetch","disableFontFace","useSystemFonts","ownerDocument","document","disableRange","disableStream","disableAutoFetch","workerParams","port","GlobalWorkerOptions","workerPort","fromPort","_worker","docId","then","destroyed","workerIdPromise","_fetchDocument","networkStreamPromise","networkStream","PDFDataTransportStream","initialData","progressiveDone","contentDispositionFilename","httpHeaders","withCredentials","all","workerId","messageHandler","MessageHandler","transport","WorkerTransport","_transport","send","catch","_capability","pdfDataRangeTransport","sendWithPromise","apiVersion","password","onPassword","onProgress","onUnsupportedFeature","destroy","_rangeListeners","_progressListeners","_progressiveReadListeners","_progressiveDoneListeners","_readyCapability","addRangeListener","listener","addProgressListener","addProgressiveReadListener","addProgressiveDoneListener","onDataRange","begin","onDataProgress","loaded","total","onDataProgressiveRead","onDataProgressiveDone","transportReady","requestDataRange","end","abort","pdfInfo","_pdfInfo","deprecated","fingerprints","stats","streamTypes","fontTypes","annotationStorage","numPages","isPureXfa","_htmlForXfa","allXfaHtml","getPage","pageNumber","getPageIndex","ref","getDestinations","getDestination","id","getPageLabels","getPageLayout","getPageMode","getViewerPreferences","getOpenAction","getAttachments","getJavaScript","getJSActions","getDocJSActions","getOutline","getOptionalContentConfig","getPermissions","getMetadata","getMarkInfo","getData","getDownloadInfo","downloadInfoCapability","cleanup","keepLoadedFonts","startCleanup","loadingTask","loadingParams","saveDocument","size","getFieldObjects","hasJSActions","getCalculationOrderIds","pageIndex","pageInfo","_pageIndex","_pageInfo","_ownerDocument","_stats","StatTimer","_pdfBug","commonObjs","objs","PDFObjects","_bitmaps","Set","cleanupAfterRender","pendingCleanup","_intentStates","Map","_annotationPromises","rotate","userUnit","view","getViewport","scale","rotation","offsetX","offsetY","dontFlip","PageViewport","viewBox","getAnnotations","intent","intentArgs","getRenderingIntent","cacheKey","renderingIntent","annotations","annotation","titleObj","contentsObj","_jsActionsPromise","getPageJSActions","getXfa","children","render","canvasContext","viewport","annotationMode","imageLayer","canvasFactory","background","optionalContentConfigPromise","annotationCanvasMap","pageColors","printAnnotationStorage","arguments","renderInteractiveForms","includeAnnotationStorage","time","intentState","streamReaderCancelTimeout","clearTimeout","canvasFactoryInstance","intentPrint","displayReadyCapability","operatorList","fnArray","argsArray","lastChunk","separateAnnots","_pumpOperatorList","complete","error","renderTasks","delete","internalRenderTask","_tryCleanup","_abortOperatorList","Error","timeEnd","InternalRenderTask","callback","useRequestAnimationFrame","add","renderTask","transparency","optionalContentConfig","initializeGraphics","operatorListChanged","getOperatorList","opListTask","opListReadCapability","streamTextContent","disableCombineTextItems","includeMarkedContent","TEXT_CONTENT_CHUNK_SIZE","sendWithStream","combineTextItems","highWaterMark","textContent","items","getTextContent","xfa","XfaText","readableStream","pump","reader","read","done","assign","styles","getReader","getStructTree","_structTreePromise","_destroy","waitOn","values","force","completed","cancel","bitmap","clear","close","resetStats","_startRenderPage","_renderPageChunk","operatorListChunk","annotationStorageMap","streamReader","RenderingCancelledException","setTimeout","curCacheKey","curIntentState","_listeners","_deferred","postMessage","transfers","event","structuredClone","call","addEventListener","removeEventListener","indexOf","splice","terminate","isWorkerDisabled","fallbackWorkerSrc","fakeWorkerId","pdfjsFilePath","currentScript","isSameOrigin","otherUrl","base","origin","other","createCDNWrapper","wrapper","createObjectURL","Blob","workerPorts","WeakMap","has","_port","_webWorker","_messageHandler","_initializeFromPort","_initialize","on","_mainThreadWorkerMessageHandler","workerSrc","Worker","terminateEarly","onWorkerError","_setupFakeWorker","sendTest","testObj","_setupFakeWorkerGlobal","WorkerMessageHandler","workerHandler","setup","pdfjsWorker","loader","mainWorkerMessageHandler","eval","loadScript","getWorkerSrc","docStats","pageCache","pagePromises","metadataPromise","fontLoader","FontLoader","_onUnsupportedFeature","bind","styleElement","_params","isCompressed","cMapPacked","destroyCapability","_passwordCapability","_networkStream","_fullReader","_lastProgress","setupMessageHandler","AnnotationStorage","isOpList","annotationMap","PrintAnnotationStorage","serializable","getHash","page","hasOwnProperty","resetModified","terminated","_getFieldObjectsPromise","_hasJSActionsPromise","cancelAllRequests","sink","getFullReader","evt","onPull","enqueue","onCancel","ready","readyReason","headersCapability","fullReader","headersReady","isStreamingSupported","isRangeSupported","contentLength","rangeReader","getRangeReader","_numPages","htmlForXfa","exception","updatePassword","exportedData","exportedError","fontRegistry","FontInspector","enabled","registerFont","fontAdded","FontFaceObject","finally","imageData","pageProxy","MAX_IMAGE_SIZE_TO_STORE","width","height","freeze","fetch","featureId","cachedPromise","num","gen","filename","results","OptionalContentConfig","metadata","Metadata","cleanupSuccessful","ensureObj","objId","settled","onContinue","form","canvas","canvasInUse","WeakSet","operatorListIdx","running","graphicsReadyCallback","graphicsReady","_useRequestAnimationFrame","cancelled","_cancelBound","_continueBound","_continue","_scheduleNextBound","_scheduleNext","_nextBound","_next","StepperManager","stepper","init","nextBreakPoint","getNextBreakPoint","gfx","CanvasGraphics","beginDrawing","endDrawing","updateOperatorList","requestAnimationFrame","executeOperatorList","_editor","_murmurhash","_storage","_modified","onSetModified","onResetModified","onAnnotationEditor","getValue","defaultValue","getRawValue","remove","AnnotationEditor","setValue","modified","entry","val","entries","setModified","_type","getAll","print","clone","serialized","serialize","hash","MurmurHash3_64","update","JSON","stringify","hexdigest","parent","_tools","boundFocusin","focusin","boundFocusout","focusout","hasBeenSelected","isEditing","isInEditMode","zIndex","_zIndex","_colorManager","ColorManager","parameters","div","viewportBaseDimensions","x","y","isAttachedToDOM","_defaultLineColor","getHexCode","setInBackground","style","setInForeground","setSelected","target","relatedTarget","closest","preventDefault","isMultipleSelection","commitOrRemove","isEmpty","commit","addToAnnotationStorage","dragstart","getBoundingClientRect","startX","clientX","startY","clientY","dataTransfer","setData","effectAllowed","setAt","tx","ty","screenToPageTranslation","left","top","translate","setDims","parentWidth","parentHeight","getInitialTranslation","createElement","setAttribute","className","bindEvents","pointerdown","isMac","KeyboardManager","platform","button","ctrlKey","shiftKey","metaKey","toggleSelected","getRect","pageWidth","pageHeight","pageDimensions","shiftX","shiftY","getRectInCurrentCoords","onceAdded","enableEditMode","disableEditMode","shouldGetKeyboardEvents","needsToBeRebuilt","rebuild","deserialize","editor","getNextId","select","classList","unselect","updateParams","disableEditing","enableEditing","propertiesToUpdate","contentDiv","setActiveEditor","CommandManager","AnnotationEditorUIManager","opacityToHex","element","names","opacity","round","IdManager","getId","commands","locked","maxSize","position","cmd","undo","mustExec","NaN","overwriteIfSameType","keepUndo","next","redo","hasSomethingToUndo","hasSomethingToRedo","callbacks","allKeys","isMacKey","split","at","navigator","isWin","includes","altKey","exec","stopPropagation","ClipboardManager","elements","copy","isArray","el","filter","paste","_colorsMapping","_colors","colors","getColorValues","convert","color","rgb","getRGB","matchMedia","matches","RGB","every","activeEditor","allEditors","allLayers","clipboardManager","commandManager","currentPageIndex","editorTypes","eventBus","idManager","isEnabled","mode","selectedEditors","boundKeydown","keydown","boundOnEditingAction","onEditingAction","boundOnPageChanging","onPageChanging","previousStates","hasEmptyClipboard","hasSelectedEditor","container","_keyboardManager","selectAll","cut","unselectAll","_on","layer","removeKeyboardManager","_off","focusMainContainer","focus","addKeyboardManager","getActive","dispatchUpdateStates","hasChanged","some","dispatch","dispatchUpdateUI","setEditingState","registerEditorTypes","types","editorType","defaultPropertiesToUpdate","addLayer","enable","disable","removeLayer","updateMode","disableAll","enableAll","updateToolbar","updateDefaultParams","getEditors","editors","getEditor","addEditor","removeEditor","addEditorToLayer","addOrRebuild","hasSelection","ed","isSelected","addCommands","newEditors","selectEditors","isActive","getMode","pdfDateStringRegex","PixelsPerInch","PDFDateString","DOMSVGFactory","AnnotationPrefix","getCurrentTransform","getCurrentTransformInverse","getFilenameFromUrl","getPdfFilenameFromUrl","getXfaPageViewport","isPdfFile","isValidFetchUrl","_base_factory","SVG_NS","CSS","PDF","PDF_TO_CSS_UNITS","BaseCanvasFactory","_document","_createCanvas","fetchData","asTypedArray","baseURI","response","ok","statusText","arrayBuffer","text","request","XMLHttpRequest","open","responseType","onreadystatechange","readyState","DONE","responseText","BaseCMapReaderFactory","_fetchData","compressionType","cMapData","BaseStandardFontDataFactory","BaseSVGFactory","_createSVG","createElementNS","rotateA","rotateB","rotateC","rotateD","offsetCanvasX","offsetCanvasY","centerX","centerY","convertToViewportPoint","convertToViewportRectangle","topLeft","bottomRight","convertToPdfPoint","trim","substring","toLowerCase","anchor","query","lastIndexOf","defaultFilename","reURI","reFilename","splitURI","suggestedFilename","started","times","now","start","outBuf","longest","duration","padEnd","removeScriptElement","script","onload","onerror","head","documentElement","append","toDateObject","input","year","parseInt","month","day","hour","minute","universalTimeRelation","offsetHour","offsetMinute","UTC","xfaPage","attributes","colorRGB","span","visibility","body","computedColor","getComputedStyle","ctx","f","getTransform","invertSelf","context","getContext","reset","canvasAndContext","skipDimensions","svg","SEED","MASK_HIGH","MASK_LOW","seed","h1","h2","blockCounts","tailLength","dataUint32","k1","k2","C1","C2","C1_LOW","C2_LOW","hex1","hex2","BaseFontLoader","nativeFontFaces","addNativeFontFace","nativeFontFace","fonts","insertRule","rule","getElementsByTagName","styleSheet","sheet","cssRules","attached","missingFile","isFontLoadingAPISupported","createNativeFontFace","family","createFontFaceRule","isSyncFontLoadingSupported","_queueLoadingCallback","_prepareFontLoadEvent","hasFonts","_loadTestFont","rules","fontsToLoad","loadingContext","requests","nextRequestId","loadTestFontId","supported","userAgent","completeRequest","otherRequest","shift","getLoadTestFont","atob","int32","offset","spliceString","s","insert","chunk1","chunk2","called","isFontReady","fillText","getImageData","COMMENT_OFFSET","CFF_CHECKSUM_OFFSET","XXXX_VALUE","checksum","btoa","loadedName","fontFamily","translatedData","compiledGlyphs","cssFontInfo","css","weight","fontWeight","italicAngle","FontFace","mimetype","getPathGenerator","character","cmds","jsBuf","current","args","_pattern_helper","_image_utils","MIN_FONT_SIZE","MAX_FONT_SIZE","MAX_GROUP_SIZE","EXECUTION_TIME","EXECUTION_STEPS","MAX_SIZE_TO_COMPILE","Path2D","FULL_CHUNK_HEIGHT","mirrorContextOperations","destCtx","_removeMirroring","__originalSave","__originalRestore","__originalRotate","__originalScale","__originalTranslate","__originalTransform","__originalSetTransform","setTransform","__originalResetTransform","resetTransform","__originalClip","__originalMoveTo","__originalLineTo","__originalBezierCurveTo","bezierCurveTo","__originalRect","__originalClosePath","__originalBeginPath","beginPath","angle","cp1x","cp1y","cp2x","cp2y","CachedCanvases","cache","getCanvas","canvasEntry","drawImageAtIntegerCoords","srcImg","srcX","srcY","srcW","srcH","destX","destY","destW","destH","tlX","rTlX","tlY","rTlY","brX","rWidth","brY","rHeight","sign","drawImage","scaleX","hypot","scaleY","compileType3Glyph","imgData","j0","POINT_TO_PROCESS_LIMIT","POINT_TYPES","width1","points","lineSize","elem","mask","count","sum","steps","Int32Array","path","p0","step","pp","drawOutline","CanvasExtraState","alphaIsShape","fontSize","fontSizeScale","textMatrix","textMatrixScale","fontMatrix","leading","lineX","lineY","charSpacing","wordSpacing","textHScale","textRenderingMode","textRise","fillColor","strokeColor","patternFill","fillAlpha","strokeAlpha","lineWidth","activeSMask","transferMaps","startNewPathAndClipBox","clipBox","setCurrentPoint","updatePathMinMax","minX","minY","maxX","maxY","updateRectMinMax","updateScalingPathMinMax","updateCurvePathMinMax","box","getPathBoundingBox","pathType","PathType","xStrokePad","yStrokePad","updateClipFromPath","isEmptyClip","Infinity","getClippedPathBoundingBox","putBinaryImageData","thisChunkHeight","elemsInThisChunk","transferMapRed","transferMapGreen","transferMapBlue","transferMapGray","ImageData","putImageData","partialChunkHeight","fullChunks","totalChunks","chunkImgData","createImageData","srcPos","destPos","dest","kind","srcLength","dest32","dest32DataLength","fullSrcDiff","white","black","srcDiff","k","kEnd","kEndUnrolled","srcByte","hasTransferMaps","putBinaryImageMask","applyMaskImageData","copyCtxState","sourceCtx","properties","property","setLineDash","getLineDash","lineDashOffset","resetCtxToDefault","foregroundColor","strokeStyle","fillStyle","fillRule","globalAlpha","lineCap","lineJoin","miterLimit","globalCompositeOperation","composeSMaskBackdrop","r0","g0","b0","alpha","alpha_","composeSMaskAlpha","maskData","layerData","transferMap","composeSMaskLuminosity","genericComposeSMask","maskCtx","layerCtx","subtype","backdrop","layerOffsetX","layerOffsetY","maskOffsetX","maskOffsetY","composeFn","hasBackdrop","PIXELS_TO_PROCESS","chunkSize","ceil","row","chunkHeight","composeSMask","layerBox","layerWidth","layerHeight","getImageSmoothingEnabled","interpolate","fround","actualScale","devicePixelRatio","LINE_CAP_STYLES","LINE_JOIN_STYLES","NORMAL_CLIP","EO_CLIP","canvasCtx","stateStack","pendingClip","pendingEOFill","res","xobjs","groupStack","processingType3","baseTransform","baseTransformStack","groupLevel","smaskStack","smaskCounter","tempSMask","suspendedCtx","contentVisible","markedContentStack","cachedCanvases","cachedPatterns","viewportScale","outputScaleX","outputScaleY","backgroundColor","foreground","_cachedScaleForStroking","_cachedGetSinglePixelWidth","_cachedBitmapsMap","getObject","fallback","defaultBackgroundColor","fg","bg","isValidDefaultBg","defaultBg","rB","gB","bB","newComp","lumB","selectColor","lumC","fillRect","transparentCanvas","compositeCtx","beginLayout","executionStartIdx","continueCallback","fnId","argsArrayLen","chunkOperations","endTime","breakIt","depObjId","objsPool","restoreInitialState","inSMaskMode","HTMLCanvasElement","endLayout","_scaleImage","img","tmpCanvas","tmpCtx","widthScale","heightScale","paintWidth","paintHeight","tmpCanvasId","newWidth","newHeight","clearRect","_createMaskCanvas","scaled","maskCanvas","isPatternFill","currentTransform","mainKey","withoutTranslation","cachedImage","maskToCanvas","cord1","cord2","drawnWidth","drawnHeight","fillCanvas","fillCtx","imageSmoothingEnabled","inverse","getPattern","limit","dashArray","dashPhase","flatness","states","state","checkSMaskState","beginSMaskMode","endSMaskMode","cacheId","scratchCanvas","compose","dirtyBox","floor","old","pop","ops","isScalingMatrix","minMaxForBezier","xw","yh","consumePath","rescaleAndStroke","needRestore","paths","pendingTextPaths","addToPath","spacing","fontRefName","fontObj","fontDirection","isType3Font","bold","italic","typeface","fallbackName","browserFontSize","rise","paintChar","patternTransform","fillStrokeMode","isAddToPathSet","strokeText","isFontSubpixelAAEnabled","glyphs","showType3Text","glyphsLength","vertical","spacingDir","defaultVMetrics","widthAdvanceScale","simpleFillText","pattern","getSinglePixelWidth","scaledX","scaledY","charWidth","glyph","restoreNeeded","isSpace","fontChar","accent","vmetric","vx","vy","remeasure","measuredWidth","measureText","characterScaleX","isInFont","scaledAccentX","scaledAccentY","spacingLength","isTextInvisible","charProcOperatorList","operatorListId","transformed","xWidth","yWidth","llx","lly","urx","ury","getColorN_Pattern","IR","canvasGraphicsFactory","createCanvasGraphics","TilingPattern","_getPattern","matrix","getShadingPattern","SHADING","inv","bl","br","ul","ur","bbox","group","currentCtx","isolated","knockout","canvasBounds","groupCtx","startTransformInverse","currentMtx","hasOwnCanvas","canvasWidth","canvasHeight","annotationCanvas","savedCtx","compiled","skewX","skewY","positions","trans","images","image","w","h","imgToPaint","HTMLElement","appendImage","tag","visible","isVisible","isContentVisible","absDet","normX","normY","getScaleForStroking","scaledXLineWidth","scaledYLineWidth","baseArea","saveRestore","savedMatrix","savedDashes","savedDashOffset","op","applyBoundingBox","region","BaseShadingPattern","RadialAxialShadingPattern","_bbox","_colorStops","_p0","_p1","_r0","_r1","_createGradient","grad","colorStop","createLinearGradient","createRadialGradient","addColorStop","owner","ownerBBox","createPattern","domMatrix","DOMMatrix","drawTriangle","c1","c2","c3","tmp","xa","car","cag","cab","xb","cbr","cbg","cbb","coords","rowSize","c1r","c1g","c1b","c2r","c2g","c2b","c3r","c3g","c3b","x1_","x2_","drawFigure","figure","ps","cs","verticesPerRow","rows","cols","q","MeshShadingPattern","_coords","_figures","_bounds","_background","_createMeshCanvas","combinedScale","EXPECTED_SCALE","MAX_PATTERN_SIZE","BORDER_SIZE","boundsWidth","boundsHeight","paddedWidth","paddedHeight","matrixScale","temporaryPatternCanvas","DummyShadingPattern","PaintType","COLORED","UNCOLORED","xstep","ystep","paintType","tilingType","createPatternCanvas","curMatrixScale","dimx","getSizeAndScale","dimy","graphics","setFillAndStrokeStyleToContext","adjustedX0","adjustedY0","adjustedX1","adjustedY1","clipBbox","realOutputSize","bboxWidth","bboxHeight","cssColor","inverseDecode","opaque","zeroMapping","oneMapping","widthInSource","widthRemainder","CallbackKind","DATA","ERROR","StreamKind","CANCEL","CANCEL_COMPLETE","CLOSE","ENQUEUE","PULL","PULL_COMPLETE","START_COMPLETE","wrapReason","sourceName","targetName","comObj","callbackId","streamId","streamSinks","streamControllers","callbackCapabilities","actionHandler","_onComObjOnMessage","stream","_processStreamMessage","action","cbSourceName","cbTargetName","result","_createStreamSink","actionName","handler","ah","queueingStrategy","ReadableStream","controller","startCapability","startCall","pullCall","cancelCall","isClosed","desiredSize","pull","pullCapability","cancelCapability","streamSink","isCancelled","lastDesiredSize","sinkCapability","success","streamController","_deleteStreamController","allSettled","metadataMap","parsedData","rawData","getRaw","INTERNAL","Symbol","OptionalContentGroup","_setVisible","internal","cachedHasInitialVisibility","groups","initialVisibility","order","creator","baseState","off","evaluateVisibilityExpression","array","operator","expression","policy","ids","setVisibility","hasInitialVisibility","getOrder","getGroups","getGroup","_queuedChunks","_progressiveDone","_contentDispositionFilename","_pdfDataRangeTransport","_isStreamingSupported","_isRangeSupported","_contentLength","_fullRequestReader","_rangeReaders","_onReceiveData","_onProgress","_onProgressiveDone","_enqueue","found","_begin","_progressiveDataLength","_loaded","firstReader","_removeRangeReader","queuedChunks","PDFDataTransportStreamReader","PDFDataTransportStreamRangeReader","_stream","_done","_filename","_requests","_headersReady","requestCapability","_end","_queuedChunk","requestsCapability","output","walk","node","shouldBuildText","child","fs","readFile","Canvas","createCanvas","AnnotationEditorLayer","_freetext","_ink","accessibilityManager","allowClick","boundPointerup","pointerup","boundPointerdown","hadPointerDown","isCleaningUp","uiManager","_initialized","FreeTextEditor","initialize","l10n","InkEditor","addInkEditorIfNeeded","disableClick","enableClick","isCommitting","createAndAddNewEditor","pointerEvents","currentActive","attach","detach","removePointerInTextLayer","display","activeElement","changeParent","moveEditorInDOM","moveElementInDOM","addANewEditor","addUndoableEditor","createNewEditor","annotationType","drop","dropEffect","endX","endY","dragover","setDimensions","scaleFactor","pageLLx","pageLLy","pageURx","pageURy","flipOrientation","widthStr","heightStr","boundEditorDivBlur","editorDivBlur","boundEditorDivFocus","editorDivFocus","boundEditorDivKeydown","editorDivKeydown","content","hasAlreadyBeenCommitted","_freeTextDefaultContent","_l10nPromise","_internalPadding","_defaultColor","_defaultFontSize","parseFloat","getPropertyValue","updateFontSize","updateColor","setFontsize","editorDiv","setEditorDimensions","savedFontsize","savedColor","overlayDiv","contentEditable","draggable","innerText","extractText","divs","firstChild","nodeName","trimEnd","dblclick","removeAttribute","baseX","baseY","line","createTextNode","padding","_pdfjsFitCurve","fitCurve","RESIZER_SIZE","aspectRatio","baseHeight","baseWidth","boundCanvasPointermove","canvasPointermove","boundCanvasPointerleave","canvasPointerleave","boundCanvasPointerup","canvasPointerup","boundCanvasPointerdown","canvasPointerdown","isCanvasInitialized","lastPoint","observer","realWidth","realHeight","requestFrameCallback","_defaultOpacity","_defaultThickness","thickness","bezierPath2D","currentPath","translationX","translationY","updateThickness","updateOpacity","savedThickness","fitToContent","redraw","savedOpacity","createObserver","setCanvasDims","disconnect","getInitialBBox","setStroke","startDrawing","draw","lastX","lastY","stopDrawing","bezier","xy","path2D","buildPath2D","updateTransform","ResizeObserver","contentRect","observe","setMinDims","roundedWidth","roundedHeight","setScaleFactor","getPadding","scaleFactorW","scaleFactorH","control1","control2","serializePaths","NUMBER_OF_POINTS_ON_BEZIER_CURVE","p10","p11","p20","p21","p30","p31","p40","p41","extractPointsOnBezier","isAlmostFlat","q10","q11","q20","q21","q30","q31","tol","ax","ay","bx","by","getBbox","xMin","xMax","yMin","yMax","firstTime","prevTranslationX","prevTranslationY","unscaledPadding","minHeight","minWidth","maxError","progressCallback","forEach","point","len","leftTangent","createTangent","rightTangent","fitCubic","bezCurve","u","uPrime","prevErr","splitPoint","prevSplit","centerVector","toCenterTangent","fromCenterTangent","beziers","dist","MaxIterations","maths","vectorLen","subtract","addArrays","mulItems","chordLengthParameterize","generateAndReport","reparameterize","errChange","normalize","concat","paramsOrig","paramsPrime","generateBezier","computeMaxError","bez","maxErr","maxPoint","A","det_C0_C1","det_C0_X","det_X_C1","alpha_l","alpha_r","epsilon","segLength","ux","firstPoint","zeros_Xx2x2","dot","newtonRaphsonRootFind","qprime","numerator","mulMatrix","denominator","squareItems","qprimeprime","currU","prevU","prevP","maxDist","t_distMap","mapTtoRelativeDistances","find_t","B_parts","B_t_curr","B_t_dist","B_t_prev","sumLen","param","lenMin","tMax","tMin","lenMax","pointA","pointB","zs","multiplier","reduce","addItems","addition","divItems","divisor","ctrlPoly","pA","pB","pC","pD","AnnotationLayer","_scripting_utils","_xfa_layer","DEFAULT_TAB_INDEX","DEFAULT_FONT_SIZE","GetElementsByNameSet","getRectDims","AnnotationElementFactory","LinkAnnotationElement","TextAnnotationElement","fieldType","TextWidgetAnnotationElement","radioButton","RadioButtonWidgetAnnotationElement","checkBox","CheckboxWidgetAnnotationElement","PushButtonWidgetAnnotationElement","ChoiceWidgetAnnotationElement","WidgetAnnotationElement","PopupAnnotationElement","FreeTextAnnotationElement","LineAnnotationElement","SquareAnnotationElement","CircleAnnotationElement","PolylineAnnotationElement","CaretAnnotationElement","InkAnnotationElement","PolygonAnnotationElement","HighlightAnnotationElement","UnderlineAnnotationElement","SquigglyAnnotationElement","StrikeOutAnnotationElement","StampAnnotationElement","FileAttachmentAnnotationElement","AnnotationElement","isRenderable","ignoreBorder","createQuadrilaterals","linkService","downloadManager","imageResourcesPath","renderForms","svgFactory","enableScripting","_fieldObjects","fieldObjects","_mouseState","mouseState","_createContainer","quadrilaterals","_createQuadrilaterals","borderStyle","borderWidth","horizontalRadius","horizontalCornerRadius","verticalRadius","verticalCornerRadius","radius","borderRadius","borderBottomStyle","borderColor","setRotation","elementWidth","elementHeight","_commonActions","setColor","jsName","styleName","detail","ColorConverters","hidden","preventScroll","title","userName","readonly","required","_setRequired","_dispatchEventFromSandbox","actions","jsEvent","commonActions","_setDefaultPropertiesFromJS","storedData","eventProxy","quadPoints","savedRect","quadPoint","_createPopup","trigger","popupElement","PopupElement","modificationDate","richText","hideWrapper","popup","_renderQuadrilaterals","quadrilateral","_getElementsByName","skipId","fields","fieldObj","exportValues","exportValue","domElement","querySelector","getElementsByName","isTooltipOnly","link","isBound","addLinkAttributes","newWindow","_bindNamedAction","_bindLink","Action","_bindJSAction","resetForm","_bindResetFormAction","index","linkElement","cloneNode","destination","getDestinationHash","onclick","goToDestination","getAnchorUrl","executeNamedAction","otherClickAction","resetFormFields","refs","resetFormRefs","include","allFields","fieldIds","fieldName","field","storage","allIds","dispatchEvent","Event","hasPopup","alt","dataset","l10nId","l10nArgs","alternativeText","_getKeyModifier","_setEventListener","baseName","eventName","valueGetter","modifier","_setEventListeners","getter","_setBackgroundColor","_setTextStyle","computedFontSize","TEXT_ALIGNMENT","fontColor","defaultAppearanceData","multiLine","numberOfLines","lineHeight","textAlignment","textAlign","isRequired","hasAppearance","fieldValue","setPropertyOnSiblings","keyInStorage","formattedValue","maxLen","charLimit","elementData","userValue","valueOnFocus","doNotScroll","overflowY","overflowX","disabled","readOnly","tabIndex","maxLength","defaultFieldValue","blurListener","scrollLeft","selRange","setSelectionRange","willCommit","commitKey","selStart","selectionStart","selEnd","selectionEnd","_blurListener","isDown","Keystroke","inputType","change","comb","fieldWidth","combWidth","letterSpacing","verticalAlign","checked","checkbox","curChecked","buttonValue","radio","pdfButtonValue","lastChild","selectElement","addAnEmptyEntry","combo","option","multiSelect","multiple","selected","optionElement","displayValue","removeEmptyEntry","noneOptionElement","prepend","isExport","selectedIndex","getItems","multipleSelection","findIndex","selectChild","before","indices","editable","changeEx","keyDown","IGNORE_TYPES","parentType","selector","parentId","parentElements","querySelectorAll","from","parentRect","popupLeft","popupTop","pinned","BACKGROUND_ENLIGHT","hideElement","dir","dateObject","toLocaleDateString","toLocaleTimeString","XfaLayer","xfaHtml","html","contents","_formatContents","_toggle","_show","_hide","lines","pin","unpin","lineSpan","lineCoordinates","square","circle","containerClassName","svgElementName","coordinate","vertices","polyline","inkList","inkLists","file","_download","openOrDownloadData","appendElement","contentElement","rendered","renderedElement","setAnnotationCanvasMap","replaceWith","makeColorComp","CMYK_G","G_CMYK","G_RGB","G_HTML","G","RGB_G","RGB_HTML","R","B","T_HTML","CMYK_RGB","CMYK_HTML","components","RGB_CMYK","setupStorage","xfaOn","xfaOff","getAttribute","setAttributes","isHTMLAnchorElement","HTMLAnchorElement","dataId","rootHtml","stack","rootDiv","textDivs","childHtml","xmlns","TextLayerRenderTask","renderTextLayer","MAX_TEXT_DIVS_TO_RENDER","DEFAULT_FONT_ASCENT","ascentCache","AllWhitespaceRegexp","getAscent","cachedAscent","metrics","ascent","fontBoundingBoxAscent","descent","fontBoundingBoxDescent","ratio","pixels","appendText","geom","textDiv","textDivProperties","_enhanceTextSelection","hasText","hasEOL","originalTransform","paddingBottom","paddingLeft","paddingRight","paddingTop","_textDivs","_viewport","atan2","fontName","fontHeight","fontAscent","sin","cos","_fontInspectorEnabled","shouldScaleText","absScaleX","absScaleY","_textDivProperties","_textContentStream","_layoutText","angleCos","angleSin","divWidth","divHeight","right","bottom","_canceled","textDivsLength","_renderingDone","findPositiveMin","ts","expand","expanded","expandBounds","divProperties","Float64Array","jj","boxScale","boxes","x1New","x2New","expandBoundsLTR","sort","fakeBoundary","horizon","boundary","horizonPart","affectedBoundary","maxXNew","xNew","changedHorizon","lastBoundary","useBoundary","unshift","used","textContentStream","textContentItemsStr","enhanceTextSelection","_textContent","_container","_textContentItemsStr","_reader","_layoutTextLastFontSize","_layoutTextLastFontFamily","_layoutTextCtx","_renderTimer","_devicePixelRatio","_processItems","styleCache","parentNode","_render","timeout","textItems","textStyles","expandTextDivs","expandDivs","transformBuf","paddingBuf","divProps","renderParameters","SVGGraphics","SVG_DEFAULTS","fontStyle","XML_NS","XLINK_NS","contentType","forceDataSchema","digits","b1","b2","b3","d1","d2","d3","d4","convertImgDataToPng","PNG_HEADER","CHUNK_WRAPPER_SIZE","crcTable","crc32","crc","writePngChunk","adler32","deflateSync","literals","deflateSyncUncompressed","maxBlockLength","deflateBlocks","idat","pi","adler","encode","isMask","bitDepth","colorType","offsetLiterals","offsetBytes","ihdr","pngLength","SVGExtraState","dependencies","activeClipUrl","clipGroup","maskId","opListToTree","opList","opTree","opListElement","fn","pf","toFixed","pm","acos","clipCount","maskCount","shadingCount","transformMatrix","transformStack","extraStack","embedFonts","embeddedFonts","cssStyle","_operatorIdMapping","tgrp","executeOpTree","loadDependencies","getSVG","svgElement","convertOpList","operatorIdMapping","opTreeElement","lineMatrix","xcoords","ycoords","tspan","setAttributeNS","txtElement","txtgrp","lineWidthScale","_setStrokeAttributes","_ensureTransformGroup","addFontStyle","defs","hasChildNodes","setStrokeAlpha","setFillAlpha","_makeColorN_Pattern","_makeShadingPattern","_makeTilingPattern","tilingId","tx0","ty0","tx1","ty1","xscale","yscale","txstep","tystep","tiling","childNodes","gradient","shadingId","colorStops","point0","point1","focalPoint","circlePoint","focalRadius","circleRadius","stop","getAttributeNS","clipId","clipPath","clipElement","prev","imgSrc","cliprect","imgEl","definitions","rootGroup","_ensureClipGroup","PDFNodeStream","_network_utils","http","https","fileUriRegex","parseUrl","sourceUrl","parsedUrl","parse","host","isHttp","isFsUrl","_rangeRequestReaders","PDFNodeStreamFsFullReader","PDFNodeStreamFullReader","PDFNodeStreamFsRangeReader","PDFNodeStreamRangeReader","BaseFullReader","_url","_storedError","_disableRange","_rangeChunkSize","_readableStream","_readCapability","_headersCapability","_error","_setReadableStream","BaseRangeReader","createRequestOptions","headers","auth","hostname","method","handleResponse","statusCode","getResponseHeader","allowRangeRequests","suggestedLength","validateRangeRequestCapabilities","extractFilenameFromHeader","_request","_httpHeaders","Range","lstat","stat","createReadStream","createResponseStatusError","validateResponseStatus","_content_disposition","returnValues","contentEncoding","contentDisposition","getFilenameFromContentDispositionHeader","needsEncodingFixup","toParamRegExp","rfc2616unquote","fixupEncoding","rfc2047decode","rfc5987decode","rfc2231getparam","attributePattern","flags","textdecode","contentDispositionStr","iter","quot","part","parts","quotindex","extvalue","encodingend","langvalue","charset","hex","PDFNetworkStream","OK_RESPONSE","PARTIAL_CONTENT_RESPONSE","getArrayBuffer","xhr","NetworkManager","getXhr","currXhrId","pendingRequests","requestRange","listeners","requestFull","xhrId","pendingRequest","setRequestHeader","expectedStatus","onError","onStateChange","onprogress","onHeadersReceived","onDone","xhrStatus","ok_response_on_range_request","rangeHeader","getRequestXhr","isPendingRequest","abortRequest","_source","_manager","_onRangeRequestReaderClosed","PDFNetworkStreamFullRequestReader","PDFNetworkStreamRangeRequestReader","onClosed","manager","_onHeadersReceived","_onDone","_onError","_fullRequestId","_headersReceivedCapability","_cachedChunks","fullRequestXhrId","fullRequestXhr","lengthComputable","_requestId","_close","PDFFetchStream","createFetchOptions","abortController","signal","credentials","redirect","createHeaders","Headers","PDFFetchStreamReader","PDFFetchStreamRangeReader","_withCredentials","_abortController","AbortController","_headers","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__","_annotation_editor_layer","_annotation_layer","_api","_svg","_text_layer"],"sourceRoot":""}